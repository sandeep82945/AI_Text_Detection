{
    "abstractText": "The class of tree-adjoining languages can be characterized by various two-level formalisms, consisting of a context-free grammar (CFG) or pushdown automaton (PDA) controlling another CFG or PDA. These four formalisms are equivalent to tree-adjoining grammars (TAG), linear indexed grammars (LIG), pushdownadjoining automata (PAA), and embedded pushdown automata (EPDA). We define semiringweighted versions of the above two-level formalisms, and we design new algorithms for computing their stringsums (the weight of all derivations of a string) and allsums (the weight of all derivations). From these, we also immediately obtain stringsum and allsum algorithms for TAG, LIG, PAA, and EPDA. For LIG, our algorithm is more time-efficient by a factor of O(n|N |) (where n is the string length and |N | is the size of the nonterminal set) and more space-efficient by a factor of O(|\u0393|) (where \u0393 is the size of the stack alphabet) than the algorithm of Vijay-Shanker and Weir (1989). For EPDA, our algorithm is both more spaceefficient and time-efficient than the algorithm of Alonso et al. (2001) by factors of O(|\u0393|) and O(|\u0393|), respectively. Finally, we give the first PAA stringsum and allsum algorithms.",
    "authors": [
        {
            "affiliations": [],
            "name": "Alexandra Butoi"
        },
        {
            "affiliations": [],
            "name": "Tim Vieira"
        },
        {
            "affiliations": [],
            "name": "Ryan Cotterell"
        },
        {
            "affiliations": [],
            "name": "David Chiang"
        }
    ],
    "id": "SP:6685b248d165d2a4fc9c523aa1472d7fa3d82010",
    "references": [
        {
            "authors": [
                "Alfred V. Aho",
                "Jeffrey D. Ullman."
            ],
            "title": "The Theory of Parsing, Translation, and Compiling, volume 1",
            "venue": "Prentice-Hall.",
            "year": 1972
        },
        {
            "authors": [
                "Miguel A. Alonso",
                "\u00c9ric Villemonte de la Clergerie",
                "Manuel Vilares."
            ],
            "title": "A formal definition of bottomup embedded push-down automata and their tabulation technique",
            "venue": "Proceedings of the International Conference on Logical Aspects of Computational Lin-",
            "year": 2001
        },
        {
            "authors": [
                "Miguel A. Alonso",
                "\u00c9ric Villemonte de la Clergerie",
                "Manuel Vilares."
            ],
            "title": "A redefinition of embedded push-down automata",
            "venue": "Proceedings of the Fifth International Workshop on Tree Adjoining Grammar and Related Frameworks (TAG+5), pages 19\u201326.",
            "year": 2000
        },
        {
            "authors": [
                "Y. Bar-Hillel",
                "M. Perles",
                "E. Shamir."
            ],
            "title": "On formal properties of simple phrase structure grammars",
            "venue": "14:143\u2013172.",
            "year": 1961
        },
        {
            "authors": [
                "Alexandra Butoi",
                "Ryan Cotterell",
                "David Chiang."
            ],
            "title": "Convergence and diversity in the control hierarchy",
            "venue": "Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 7597\u20137616. Association",
            "year": 2023
        },
        {
            "authors": [
                "Alexandra Butoi",
                "Brian DuSell",
                "Tim Vieira",
                "Ryan Cotterell",
                "David Chiang."
            ],
            "title": "Algorithms for weighted pushdown automata",
            "venue": "Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP).",
            "year": 2022
        },
        {
            "authors": [
                "Javier Esparza",
                "Stefan Kiefer",
                "Michael Luttenberger."
            ],
            "title": "On fixed point equations over commutative semirings",
            "venue": "Proceedings of the Annual Symposium",
            "year": 2007
        },
        {
            "authors": [
                "Gerald Gazdar."
            ],
            "title": "Applicability of indexed grammars to natural languages",
            "venue": "Natural Language Parsing and Linguistic Theories, pages 69\u201394.",
            "year": 1988
        },
        {
            "authors": [
                "Joshua Goodman."
            ],
            "title": "Semiring parsing",
            "venue": "Computational Linguistics, 25(4):573\u2013606.",
            "year": 1999
        },
        {
            "authors": [
                "John E. Hopcroft",
                "Rajeev Motwani",
                "Jeffrey D. Ullman."
            ],
            "title": "Introduction to Automata Theory, Languages, and Computation, 3rd edition",
            "venue": "AddisonWesley Longman Publishing Co.",
            "year": 2006
        },
        {
            "authors": [
                "Aravind K. Joshi",
                "Leon S. Levy",
                "Masako Takahashi."
            ],
            "title": "Tree adjunct grammars",
            "venue": "Journal of Computer and System Sciences, 10(1):136\u2013163.",
            "year": 1975
        },
        {
            "authors": [
                "Aravind K. Joshi",
                "K. Vijay-Shanker",
                "David J. Weir."
            ],
            "title": "The convergence of mildly context-sensitive grammar formalisms",
            "venue": "Foundational Issues in Natural Language Processing, pages 31\u201381.",
            "year": 1991
        },
        {
            "authors": [
                "Makoto Kanazawa."
            ],
            "title": "A generalization of linear indexed grammars equivalent to simple context-free tree grammars",
            "venue": "Formal Grammar, pages 86\u2013103.",
            "year": 2014
        },
        {
            "authors": [
                "Marco Kuhlmann",
                "Carlos G\u00f3mez-Rodr\u00edguez",
                "Giorgio Satta."
            ],
            "title": "Dynamic programming algorithms for transition-based dependency parsers",
            "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language",
            "year": 2011
        },
        {
            "authors": [
                "Bernard Lang."
            ],
            "title": "Deterministic techniques for efficient non-deterministic parsers",
            "venue": "ICALP 1974: Automata, Languages and Programming, pages 255\u2013 269.",
            "year": 1974
        },
        {
            "authors": [
                "Harry R. Lewis",
                "Christos H. Papadimitriou."
            ],
            "title": "Elements of the Theory of Computation, 2nd edition",
            "venue": "Prentice-Hall.",
            "year": 1997
        },
        {
            "authors": [
                "Andreas Stolcke."
            ],
            "title": "An efficient probabilistic context-free parsing algorithm that computes prefix probabilities",
            "venue": "Computational Linguistics, 21(2):165\u2013 201.",
            "year": 1995
        },
        {
            "authors": [
                "K. Vijay-Shanker."
            ],
            "title": "A Study of Tree Adjoining grammars",
            "venue": "Ph.D. thesis, University of Pennsylvania.",
            "year": 1987
        },
        {
            "authors": [
                "K. Vijay-Shanker",
                "David J. Weir."
            ],
            "title": "Recognition of combinatory categorial grammars and linear indexed grammars",
            "venue": "Proceedings of the First International Workshop on Parsing Technologies (IWPT), pages 172\u2013181.",
            "year": 1989
        },
        {
            "authors": [
                "David J. Weir."
            ],
            "title": "A geometric hierarchy beyond context-free languages",
            "venue": "Theoretical Computer Science, 104(2):235\u2013261.",
            "year": 1992
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Weir (1992) introduced a hierarchy of formal languages whose first level (L1) is the class of contextfree languages and second level (L2) is the class of tree-adjoining languages. Just as context-free languages can be characterized by both context-free grammars and pushdown automata, tree-adjoining languages are characterized by multiple formalisms as well, including tree-adjoining grammars (TAG; Joshi et al., 1975), linear indexed grammars (LIG; Gazdar, 1988), embedded pushdown automata (EPDA; Vijay-Shanker, 1987), and pushdownadjoining automata (PAA; Butoi et al., 2023).\nTree-adjoining languages can further be characterized through the mechanism of control (Weir, 1992), which yields various two-level formalisms. Specifically, we have shown that\nCFGs controlled by CFGs, CFGs controlled by PDAs, PDAs controlled by CFGs, and PDAs controlled by PDAs are equivalent to TAG, LIG, PAA, and EPDA, respectively, in a strict sense called d-strong equivalence (Butoi et al., 2023).\nWhen designing statistical parsers for treeadjoining formalisms, it is often useful to consider their semiring-weighted generalizations. In this paper, we introduce semiring-weighted versions of the above two-level formalisms, and we give new, more efficient algorithms for computing stringsums (the total weight of all derivations of a string) in these formalisms.\nLang (1974) gives a recognition algorithm for (what we call) simple PDAs, which can pop and push at most one stack symbol. We have shown that this algorithm is suboptimal, and that (what we call) top-down PDAs, which always pop exactly one stack symbol, allow computing stringsums more\nefficiently (Butoi et al., 2022). Existing definitions of LIG (Vijay-Shanker and Weir, 1989; Joshi et al., 1991; Kanazawa, 2014) are equivalent to CFGs controlled by simple PDAs, and existing recognition algorithms (e.g., Vijay-Shanker and Weir, 1989) have the same limitation that makes Lang\u2019s algorithm suboptimal. By using a top-down PDA as a controller instead, we obtain a new stringsum algorithm that is more space-efficient and runs asymptotically faster. Additionally, we obtain an algorithm for allsums (the total weight of all derivations) that is more space-efficient.\nAll stringsum algorithms that operate directly on EPDAs that we are aware of (Alonso et al., 2000, 2001) are designed for specific types of EPDAs, failing to take advantage of the structure of computation in top-down PDAs. We design a new stringsum algorithm for a subclass of EPDA that is equivalent to a top-down PDA controlled by a top-down PDA, and we obtain both time and space improvements over these previous algorithms. Additionally, we design a more space-efficient EPDA allsum algorithm.\nOur algorithms assume that CFGs are given in Chomsky normal form, and for PDAs, we define a new normal form that is exactly analogous to the Chomsky normal form. We show that applying these normal forms to controllers and controllees induces, for free, normal forms for the two-level formalisms and for TAG, LIG, PAA, and EPDA. The conversions into the normal forms for all these formalisms become simpler than direct conversions, as they only require CFG or PDA conversions. We leave extensions of our stringsum and allsum algorithms to general CFGs/PDAs for future work.\nThe main contributions of this paper are: \u2022 Semiring-weighted versions of the formalisms\nCFG \u25b7 CFG (\u00a73), PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA (App. B.1). \u2022 Normal forms for these formalisms that arise, for free, from the normal forms of the controller/controllee CFGs/PDAs (\u00a73.2 and App. B.2). \u2022 Stringsum algorithms for CFG \u25b7 CFG (\u00a74), PDA \u25b7 CFG, and PDA \u25b7 PDA (App. C.2) that are more time-efficient or space-efficient than the existing algorithms for their equivalent LIG and EPDA. \u2022 The first stringsum algorithm for CFG \u25b7 PDA, and therefore, for PAA (App. C.2). \u2022 Algorithms for computing allsums in these two-\nlevel formalisms (\u00a75 and App. D)."
        },
        {
            "heading": "2 Preliminaries",
            "text": "Let [i:j] denote the sequence of integers (i, . . . , j). If s is a string, we write |s| for the length of s, si for the ith symbol of s, and s(i:j] for the substring si+1 \u00b7 \u00b7 \u00b7 sj ."
        },
        {
            "heading": "2.1 Semiring-Weighted Languages",
            "text": "Throughout this paper, we assume that W = (W,\u2295,\u2297,0,1) is a commutative semiring. We also sometimes assume that W is \u03c9-continuous, which makes it possible to take (countably) infinite sums. Please see App. A.1 for definitions of these terms. Readers not familiar with semirings may safely assume that W = R\u22650 \u222a {\u221e}, 0 = 0, 1 = 1, and \u2295 and \u2297 are the usual addition and multiplication operations, respectively.\nDefinition 1. An alphabet \u03a3 is a non-empty finite set of symbols. A language over \u03a3 is a subset of \u03a3\u2019s Kleene closure \u03a3\u2217 def= \u22c3 n\u22650\u03a3\nn. A weighted language over \u03a3 with weights from W = (W,\u2295,\u2297,0,1) is a mapping from \u03a3\u2217 to W .\nThis paper considers weighted formalisms, where the weights are taken from W . Rather than just producing or recognizing strings from a formal language, these formalisms define a weighting function over \u03a3\u2217. When W is the boolean semiring ({0, 1},\u2228,\u2227, 0, 1), we recover the usual notion of a formal language defined as a set of strings."
        },
        {
            "heading": "2.2 Weighted Context-Free Grammars",
            "text": "Definition 2. A weighted context-free grammar (WCFG) over a semiring W = (W,\u2295,\u2297,0,1) is a tuple G = (N ,\u03a3,R,w,S ), where N , \u03a3 are finite sets of nonterminal symbols and terminal symbols, respectively, R \u2286 N \u00d7 (\u03a3 \u222aN )\u2217 is a finite set of productions, w: R \u2192 W is a productionweighting function, and S \u2208 N is the start symbol.\nWe write a production (X ,\u03b1) \u2208 R as X \u2192 \u03b1, and if w(X \u2192 \u03b1) = w, we write X w\u2212\u2192 \u03b1.\nA WCFG produces strings by starting from the symbol S and repeatedly replacing the leftmost nonterminal X with the right-hand side of a production X \u2192 \u03b1 until no more nonterminals are left. In the following definitions, let G = (N ,\u03a3,R,w,S ) be a WCFG.\nDefinition 3. If \u03b1 = \u03b21X\u03b22 and \u03b1\u2032 = \u03b21\u03b3\u03b22 are sequences of terminals and nonterminals of G, where \u03b21 \u2208 \u03a3\u2217 and \u03b22 \u2208 (\u03a3 \u222aN )\u2217, and p =\n(X w\u2212\u2192 \u03b3) is a production of G, we write \u03b1 p=\u21d2\n\u03b1\u2032 to denote that \u03b1 derives \u03b1\u2032 in one step using production p.\nDefinition 4. A partial derivation in G from \u03b10 to \u03b1n is a sequence of steps d = \u03b10 p1 =\u21d2 \u00b7 \u00b7 \u00b7 pn=\u21d2 \u03b1n. We write \u03b10 \u2217 =\u21d2 \u03b1n to assert that some partial\nderivation from \u03b10 to \u03b1n exists, or to denote the set of all such partial derivations. If \u03b10 = S and \u03b1n = s \u2208 \u03a3\u2217, we call d a derivation of s, or that G derives s.\nThe weight of d is the product of its production weights,\nw(d) def = n\u2297 i=1 w(pi).\nWe denote by D(G, s) the set of all derivations in G of s and by D(G) the set of all derivations in G.\nDefinition 5. The stringsum w(G, s) of a string s under G is the total weight of all derivations in G for s,\nw(G, s) def = \u2295 d\u2208D(G,s) w(d).\nDefinition 6. The allsum w(G) of G is the total weight of all its derivations,\nw(G) def = \u2295 d\u2208D(G) w(d)."
        },
        {
            "heading": "3 Semiring-Weighted CFG \u25b7 CFG",
            "text": "Weir (1992) defined a hierarchy of formal languages and showed that its second level, which is commonly known as the class of tree-adjoining languages, can be obtained through the mechanism of control, using a CFG (the controllee) whose derivations are controlled by another CFG (the controller). In previous work (Butoi et al., 2023), we extended this mechanism to PDAs, both as controllers and controllees, and obtained four distinct formalisms by mixing a controller CFG or PDA with a controllee CFG or PDA. In this paper, we use semiringweighted versions of these formalisms. We give a formal definition of a weighted CFG \u25b7 CFG here (see App. B.1 for the other three definitions).\nWe denote such a grammar by G1 \u25b7 G2, where G1 is the controller and G2 is the controllee. Additionally, we use symbols X ,Y ,Z , . . . and a, b, c, . . . for nonterminals and terminals of the controllee, and A,B,C, . . . and a, b, c, . . . for nonterminals and terminals of the controller."
        },
        {
            "heading": "3.1 Definition",
            "text": "A weighted labeled distinguished CFG (WLDCFG) is simply a WCFG where each production has a label, and its right-hand side has one \u201cdistinguished\u201d occurrence of a nonterminal symbol. These two extensions allow its derivations to be controlled by another formalism.\nDefinition 7. A weighted labeled distinguished context-free grammar (WLD-CFG) over a semiring W = (W,\u2295,\u2297,0,1) is a tuple G = (N ,\u03a3, L,R,w,S ), where\n\u2022 N , \u03a3, and L are finite sets of nonterminal symbols, terminal symbols, and labels, respectively,\n\u2022 R \u2286 L \u00d7 N \u00d7 N \u00d7 (N \u222a \u03a3)\u2217 is a finite set of productions,\n\u2022 w: R \u2192 W is a production-weighting function, and\n\u2022 S \u2208 N is the start symbol.\nIf (\u2113, i, A, \u03b21 \u00b7 \u00b7 \u00b7\u03b2n) is a production in R, we must have either i = 0, which we write as\n\u2113 : A \u2192 \u03b21 \u00b7 \u00b7 \u00b7\u03b2n\nor 1 \u2264 i \u2264 n and \u03b2i \u2208 N , which we write as\n\u2113 : A \u2192 \u03b21 \u00b7 \u00b7 \u00b7\u03b2i\u22121\n(\n\u03b2i\u03b2i+1 \u00b7 \u00b7 \u00b7\u03b2n.\nWeir (1992) gave two definitions of a derivation in an LD-CFG (the controllee) controlled by another CFG (the controller). In his first definition, the controllee nonterminals keep a record of the productions used, called a control word (a string in L\u2217). At the end of the derivation, each control word is checked for membership in the language of the controller. In his second definition, the controllee nonterminals run a controller derivation. When the controller generates a label \u2113 \u2208 L, it causes the controllee to apply production \u2113. We use the latter definition, which allows one to think of the controller and the controllee as a single grammar, merging their productions into a single set of rules.\nFor any sets X and Y , we define X [Y] = {X [Y ] | X \u2208 X ,Y \u2208 Y}, where X [Y ] is just another way of writing the ordered pair of X and Y . If \u03b1 = X1 \u00b7 \u00b7 \u00b7Xk \u2208 X \u2217 is a sequence of nonterminals, we use the notation \u03b1[Y ] = X1[Y ] \u00b7 \u00b7 \u00b7Xk[Y ] for any Y \u2208 Y .\nTo make the following definition more readable, we assume that the controller\u2019s right-hand sides are either a single label or a string of nonterminals, and that the controllee right-hand sides are either a single terminal or a string of nonterminals with exactly one distinguished position. It would be possible, but more tedious, to write the definition for the general case.\nDefinition 8. Let G1 be a WCFG with nonterminals N 1 and terminals L, called the controller, and let G2 be a WLD-CFG with nonterminals N 2 and labels L, called the controllee. Then G1 \u25b7 G2 is a rewriting system with the following rules:\n\u2022 If (A w\u2212\u2192 \u03b2) is a production of G1 where \u03b2 \u2208 N \u22171, then G1 \u25b7 G2 has a rule X [A \u00b7\u00b7] w\u2212\u2192 X [\u03b2 \u00b7\u00b7] for each X \u2208 N 2.\n\u2022 If (A w1\u2212\u2192 \u2113) is a production of G1 and (\u2113 : X w2\u2212\u2192 \u03b11 (\nY\u03b12) is a production of G2, then G1 \u25b7 G2 has a rule X [A \u00b7\u00b7] w1\u2297w2\u2212\u2212\u2212\u2212\u2192 \u03b11[S]Y [\u00b7\u00b7]\u03b12[S].\nA derivation in G1 \u25b7 G2 starts with S [S]. If there is a rule p = (X [A \u00b7\u00b7] w\u2212\u2192 \u03b11Y [\u03b21 \u00b7\u00b7]\u03b12), then for any \u03b10 \u2208 \u03a3\u2217, \u03b22 \u2208 N \u22172, and \u03b13 \u2208 (\u03a3 \u222aN 1[N \u22172])\u2217, we write\n\u03b10X [A\u03b22]\u03b13 p =\u21d2 \u03b10\u03b11Y [\u03b21\u03b22]\u03b12\u03b13.\nSimilarly, if there is a rule p = (X [A] w\u2212\u2192 \u03b1), then for any \u03b10 \u2208 \u03a3\u2217, and \u03b13 \u2208 (\u03a3 \u222aN 1[N \u22172])\u2217, we write\n\u03b10X [A]\u03b13 p =\u21d2 \u03b10\u03b1\u03b13.\nWe write \u2217=\u21d2 to denote a derivation with zero or\nmore steps, as in Def. 4. If S [S] \u2217=\u21d2 s \u2208 \u03a3\u2217, we say that G1 \u25b7 G2 derives s.\nExample 1. Consider the following G1 \u25b7 G2 that generates the language {anbncndn | n \u2208 N}. The controller is a WCFG G1 with the start symbol S1 and the set of productions\nR1 =  S1 1\u2212\u2192 TL3 T 1\u2212\u2192 L1TL2 T 1\u2212\u2192 \u03b5 Li 1\u2212\u2192 \u2113i (i \u2208 [1 : 3])\nS1 1\u2212\u2192 \u2113i (i \u2208 [4 : 7])\n\nand the controllee is a WLD-CFG G2 with start symbol S2 and the set of productions\nR2 =  \u21131 : S2 1\u2212\u2192 A ( S2D \u21134 : A 1\u2212\u2192 a \u21132 : S2 1\u2212\u2192 B ( S2C \u21135 : B 1\u2212\u2192 b \u21133 : S2 1\u2212\u2192 \u03b5 \u21136 : C\n1\u2212\u2192 c \u21137 : D 1\u2212\u2192 d . Below is a derivation of the string aabbccdd.\nS2[S1] \u21d2 S2[TL3] \u21d2 S2[L1TL2L3] \u21d2 A[S1]S2[TL2L3]D[S1] \u21d2 aS2[TL2L3]D[S1] \u21d2 aS2[L1TL2L2L3]D[S1] \u2217 =\u21d2 aaS2[L2L2L3]D[S1]D[S1]\n\u21d2 aaB[S1]S2[L2L3]C[S1]D[S1]D[S1] \u21d2 aabS2[L2L3]C[S1]D[S1]D[S1] \u2217 =\u21d2 aabbccdd.\nAnalogous definitions for when the controller is a WPDA and/or the controllee is a WLD-PDA are given in App. B.1."
        },
        {
            "heading": "3.2 Normal Form",
            "text": "In this section, we define a normal form for CFG \u25b7 CFG that will help us design fast stringsum and allsum algorithms. Interestingly, this normal form arises naturally from the normal forms of the controllee and the controller. Analogous normal forms are derived for PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA in App. B.2.3.\nDefinition 9. A WCFG is in Chomsky normal form if all of its productions are of one of the following types: (1) S \u2192 \u03b5, (2) X \u2192 a , or (3) X \u2192 YZ , where S ,X ,Y ,Z \u2208 N and a \u2208 \u03a3. Moreover, S does not appear on the right-hand side of any production.\nA WLD-CFG is in Chomsky normal form if all of its productions are of type (1) or (2) above, (3a) X \u2192 ( YZ , or (3b) X \u2192 Y ( Z .\nProposition 1. For any WCFG G1 with weights in an \u03c9-continuous semiring, there is a WCFG in Chomsky normal form that defines the same weighted language as G1.\nFor any WLD-CFG G2 with weights in an \u03c9-continuous semiring, there is a WLD-CFG in Chomsky normal form that is equivalent to G2.\nProof. See App. B.2.1.\nRecall that a CFG \u25b7 CFG is defined as a LD-CFG whose derivations are controlled by another CFG. When we consider only W(LD-)CFGs in Chomsky normal form, we obtain, for free, a normal form for CFG \u25b7 CFG only by mixing their rules, as shown in Fig. 2. For the epsilon rule, in principle the lefthand side could be S [A] for any A, but such rules would never be used.\nDue to d-strong equivalence, this normal form also induces a normal form for TAG. But, in order to convert a TAG into the normal form, one needs to first extract the controller and the controllee as shown by Butoi et al. (2023), then convert these to the Chomsky normal form, merge their rules, and convert them back to a TAG, also shown by Butoi et al. (2023) (see App. E for a complexity analysis of these transformations). Although these transformations add some extra complexity, the conversion into the normal form becomes simpler as it only requires (LD-)CFG conversions, rather than a direct TAG conversion. We leave a direct conversion for future work."
        },
        {
            "heading": "4 Computing Stringsums",
            "text": "In this section, we give a deduction system for computing stringsums of a particular string s in CFG \u25b7 CFG in normal form. Stringsums of a string s can be computed analogously in PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA; we show the deduction systems for these in App. C.2. Due to d-strong equivalence, these deduction systems can also be used for spinal TAG, LIG, EPDA, and spinal PAA by first converting them to their equivalent twolevel formalism. Our algorithms have improved space requirements and run asymptotically faster than the best algorithms for LIG and EPDA. Moreover, it is the only stringsum algorithm for PAA\nthat we are aware of."
        },
        {
            "heading": "4.1 Pop Computations",
            "text": "In order to compute stringsums efficiently, we decompose derivations into shareable smaller parts. Our decomposition is based on a concept that has been extensively used in the literature (Kuhlmann et al., 2011; Butoi et al., 2022) for decomposing runs of pushdown automata, namely pop computations. In the context of WPDAs, a pop computation is a partial derivation that has the overall effect of popping a single stack symbol, leaving the rest of the stack unchanged (Butoi et al., 2022). We can define pop computations of CFG \u25b7 CFG with a similar interpretation: partial derivations that \u201cpop\u201d a single leftmost nonterminal symbol, leaving the rest of the nonterminals unchanged. We define pop computations of CFG \u25b7 CFG formally below. The pop computations of PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA are defined similarly; we present these in App. C.1. Definition 10. Let G1 be a controller WCFG and G2 be a WLD-CFG, with nonterminal alphabets N 1 and N 2, respectively. Let s \u2208 \u03a3\u2217 be a string of length |s| = n. A pop computation of G1 \u25b7 G2 of\ntype\nX [A \u00b7\u00b7]\ni l\nj k\nY [\u00b7\u00b7] , where 0 \u2264 i \u2264 j \u2264 k \u2264 l \u2264 n,\nX ,Y \u2208 N 2, and A \u2208 N 1, is a pair of partial derivations (d1, d2), where\nd1 \u2208 (X [A] \u2217 =\u21d2 s(i:j]Y [\u03b5]\u03a52)\nd2 \u2208 (\u03a52 \u2217 =\u21d2 s(k:l]).\nThe weight of the pop computation is w(d1, d2) = w(d1)\u2297w(d2).\nA pop computation of type X [A] i j is a partial\nderivation X [A] \u2217=\u21d2 s(i:j].\nIn words, a pop computation of a CFG \u25b7 CFG pops a single controller symbol and derives a string possibly with a gap. Fig. 3 shows a visual representation of a pop computation of a CFG \u25b7 CFG."
        },
        {
            "heading": "4.2 Deduction System",
            "text": "We compute stringsums of CFG \u25b7 CFG efficiently by exploiting the decomposable structure of the pop computations. We give the stringsum algorithm as a weighted deduction system (Goodman, 1999), shown in Fig. 4a.\nItems. The deductive system has two types of items, which correspond to the two types of pop computations (one with a gap and one without a gap). The weights of these items are the total weights of the pop computations of those types.\nDeduction rules. We distinguish several types of pop computations based on their first production and include a deduction rule for each. The weight of each pop computation can be derived recursively from the weights of shorter pop computations. The weight of each deduction rule is the weight of the production in the side condition. Notice that the deduction system only shows how to derive further items, leaving the order in which these items should be derived by an algorithm unspecified.\nGoal item. The goal item is S [S] 0 n , which stands for all derivations from S [S] to s, where |s| = n. Its weight is the total weight of all such derivations, which is exactly the stringsum."
        },
        {
            "heading": "4.3 Correctness",
            "text": "We prove the correctness of the deduction system for CFG \u25b7 CFG using the following theorem.\nTheorem 1. Let G1 be a controller WCFG with nonterminal alphabet N 1 and start symbol S, and G2 a WLD-CFG with nonterminal alphabet N 2. Let s \u2208 \u03a3\u2217 be a string of length |s| = n.\n(a) The weight w of an item X [A]\ni j , where X \u2208\nN 2, and 0 \u2264 i \u2264 j \u2264 n, is the total weight of all pop computations of this type.\n(b) The weight of an item\nX [A \u00b7\u00b7]\ni l\nj k\nY [\u00b7\u00b7] , where\nA \u2208 N 1, X ,Y \u2208 N 2, and 0 \u2264 i \u2264 j \u2264 k \u2264 l \u2264 n, is the total weight of all pop computations of this type.\nProof. Define the span of item X [A] i j to be j \u2212 i,\nand that of item\nX [A \u00b7\u00b7]\ni l\nj k\nY [\u00b7\u00b7] to be j \u2212 i+ l \u2212 k.\nWe proceed by induction on the span \u2113.\nBase Case. When \u2113 = 1, the pop computation consists of a single step X [A] p =\u21d2 a . The weight of\nitem X [A] i \u2212 1 i is w(p) according to inference rule (terminal).\nInductive Step. Assume that the statement holds for pop computations with span at most (\u2113 \u2212 1) and consider pop computations with span \u2113. The weight of all pop computations of a certain type is the sum of various cases, distinguished by their first production.\nStarting with left pop rules. Any pop computation starting with X [A] and a left pop production p has the form (X [A] p =\u21d2 Y [\u03b5]Z [S],Z [S] \u2217=\u21d2 s(j:k]).\nBy the inductive hypothesis, the weight w1 of item Z [S]\nj k is the total weight of all partial deriva-\ntions such that Z [S] \u2217=\u21d2 s(j:k]. By distributivity, the total weight of all pop computations of the above form is w(p) \u2297 w1. This weight is added to the\nweight of the item\nX [A \u00b7\u00b7]\ni o\nk l\nY [\u00b7\u00b7] in inference rule\n(left pop). Since the rules are symmetric, a similar argument can be used for pop computations that start with right pop rules.\nStarting with push rules. Any pop computation starting with X [A] and a push production p has the\nform (d1, d2), where\nd1 = X [A] p =\u21d2 X [BC] \u2217=\u21d2 s(i:j]Y [C]\u03a52\n\u2217 =\u21d2 s(i:j]s(j:k]Z [\u03b5]\u03a51\u03a52,\nd2 = \u03a51\u03a52 \u2217 =\u21d2 s(l:m]\u03a52 \u2217 =\u21d2 s(l:m]s(m:o].\nBy the inductive hypothesis, the weight w1 of item X [B \u00b7\u00b7]\ni o\nj m\nY [\u00b7\u00b7] is the weight of all pop computa-\ntions (X [B] \u2217=\u21d2 s(i:j]Y [\u03b5]\u03a52,\u03a52 \u2217 =\u21d2 s(m:o]). Sim-\nilarly, the weight w2 of item\nY [C \u00b7\u00b7]\nj m\nk l\nZ [\u00b7\u00b7] is the\ntotal weight of all pop computations (Y [C] \u2217=\u21d2\ns(j:k]Z [\u03b5]\u03a51,\u03a51 \u2217 =\u21d2 s(l:m]). By distributivity, the total weight of all such partial derivations is w(p) \u2297 w1 \u2297 w2. This weight is added to the\nweight of the item\nX [A \u00b7\u00b7]\ni o\nk l\nW [\u00b7\u00b7] in inference rule\n(push-1).\nAny pop computation starting with X [A] and a\npush production p has the form\nX [A] p =\u21d2 X [BC] \u2217=\u21d2 s(i:j]Y [C]\u03a52\n\u2217 =\u21d2 s(i:j]s(j:k]\u03a52 \u2217 =\u21d2 s(i:j]s(j:k]s(k:l].\nBy the inductive hypothesis, the weight w1 of item X [B \u00b7\u00b7]\ni l\nj k\nY [\u00b7\u00b7] is the weight of all pop computations\n(X [B] \u2217=\u21d2 s(i:j]Y [\u03b5]\u03a52,\u03a52 \u2217 =\u21d2 s(k:l]), while the\nweight w2 of item Y [C]\nj k is the weight of all pop\ncomputations Y [C] \u2217=\u21d2 s(j:k]. By distributivity, the total weight of all such partial derivations is w(p)\u2297w1\u2297w2. This weight is added to the weight of the item X [A]\ni l in inference rule (push-2)."
        },
        {
            "heading": "4.4 Complexity Analysis",
            "text": "Let X1 and X2 be the sets of nonterminals or stack symbols of the controllers and of the controllees, respectively. An algorithm based on one of our deductive systems would would need to store a\nweight for each item\nX [A \u00b7\u00b7]\ni l\nj k\nY [\u00b7\u00b7] and X [A] i j , for\nall i, j, k, l \u2208 [0:n], A \u2208 X1, and X ,Y \u2208 X2, giving a space complexity of O(n4|X1||X2|2) and O(n2|X1||X2|), respectively. Overall we get a space complexity of O(n4|X1|2|X2|).\nComputing the weight of each new item requires in the worst case inference rule (push-1), iterating over indices i, j, k, l,m, n \u2208 [0:n], and symbols X ,Y ,Z \u2208 X2 and A,B,C \u2208 X1. This gives a runtime of O(n6|X1|3|X2|3)."
        },
        {
            "heading": "4.5 Comparison with Existing Algorithms",
            "text": "Vijay-Shanker and Weir (1989) designed a recognition (which is essentially computing stringsums in the boolean semiring) algorithm for a type of LIG that is d-strongly equivalent to a CFG in Chomsky normal form controlled by a simple PDA. Our stringsum algorithm is more space-efficient than theirs by a factor of |\u0393| and more time-efficient by a factor of n|N |, where n is the string length, |\u0393| is the size of the stack alphabet, and |N | is the size of the alphabet of nonterminals. Their algorithm could be improved using a trick similar to\nthe one used by Butoi et al. (2022), resulting in an algorithm with the same runtime as ours. But, in order to do so, it is necessary to store additional items, which increases the space complexity by another factor of |\u0393|. Additionally, on the type of LIG used by Vijay-Shanker and Weir, we get a further runtime improvementof a factor of O(|\u0393|).\nFor EPDA, our stringsum algorithm is more space-efficient than the algorithm of Alonso et al. (2001) by a factor of |\u0393|2 and has an improved runtime by a factor of |\u0393|3, where |\u0393| is the size of the stack alphabet. Their algorithm is designed for an EPDA without finite-state control, which is equivalent to a PDA \u25b7 PDA where both the controller and the controllee are single-state. Therefore, we exclude the states when comparing the two algorithms."
        },
        {
            "heading": "5 Computing Allsums",
            "text": "We reuse the notion of pop computation that we defined in \u00a74.1 in order to derive a space-efficient algorithm for computing allsums of CFG \u25b7 CFG. Allsums of PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA can be computed similarly (see App. D). We define a new type of pop computation that will help us compute the weight of all derivations instead of derivations of a particular string.\nDefinition 11. Let G1 be a controller WCFG and G2 a WLD-CFG, with nonterminal alphabets N 1 and N 2, respectively. Let be a symbol not occurring in the rules of G1 \u25b7 G2. A pop computation of\ntype\nX [A \u00b7\u00b7]\nY [\u00b7\u00b7] , where A \u2208 N 1 and X ,Y \u2208 N 2,\nis a pair of partial derivations (d1, d2), where\nd1 \u2208 (X [A] \u2217 =\u21d2 s1Y [\u03b5]\u03a52)\nd2 \u2208 (\u03a52 \u2217 =\u21d2 s2)\nwhere s1, s2 \u2208 \u03a3\u2217 and \u03a52 \u2208 N 1[N \u22172]\u2217. The weight of this pop computation is w(d1, d2) = w(d1)\u2297w(d2).\nA pop computation of type X [A] is a partial\nderivation X [A] \u2217=\u21d2 s, where s \u2208 \u03a3\u2217.\nFig. 4b shows the deduction system for computing allsums. Just as for stringsums, we distinguish\ntwo types of items, those of type\nX [A \u00b7\u00b7]\nY [\u00b7\u00b7] and\nX [A] .\nTheorem 2. Let G1 be a controller WCFG with nonterminal alphabet N 1 and start symbol S, and G2 a WLD-CFG with nonterminal alphabet N 2. Assume that both have weights in an \u03c9-continuous semiring (App. A.1). Then the allsum of G1 \u25b7 G2 is the value of the item S [S] in the deductive system\nof Fig. 4b.\nUnlike for stringsums, this deduction system has cycles. The value of the goal item S [S] can be\nfound using fixed-point iteration (Goodman, 1999) or the semiring generalization of Newton\u2019s method (Esparza et al., 2007).\nSince there are various algorithms for computing item values, we don\u2019t analyze time complexity, but only space complexity. Let N 1 and N 2 be the sets of nonterminals or stack symbols of the controller and the controllee, respectively. As the algorithm\nneeds to store an item of the form\nX [A \u00b7\u00b7]\nY [\u00b7\u00b7] for\neach X ,Y \u2208 N 2 and A \u2208 N 1, and an item of the form X [A] for each X \u2208 N 2 and A \u2208 N 1, it has a\nspace complexity of O(|N 1||N 2|2). If we were to compute allsums in LIG using an algorithm based on Vijay-Shanker and Weir\u2019s (1989) algorithm, we would have stored O(|N 1|2|N 2|2) items, therefore we have a space improvement of a factor of |N 1|. Similarly, we get a space improvement for EPDA of a factor of |N 1|2 over the allsum algorithm based on Alonso et al.\u2019s (2001) algorithm."
        },
        {
            "heading": "6 Conclusion",
            "text": "Our work has contributed several new results and algorithms for L2 formalisms. We introduced semiring-weighted versions of controllable CFGs and PDAs, which give rise naturally to four semiring-weighted two-level formalisms when they are controlled by semiring-weighted CFGs and PDAs. We also introduced a WPDA normal form that is completely analogous to the Chomsky normal form for CFGs and showed that one can derive normal forms for the two-level formalisms only from the normal forms of the controller and of the controllee. These normal forms are also normal forms for TAG, LIG, PAA, and EPDA, respectively, and the conversions only require conversions of the controller and the controllee. Finally, we designed new stringsum and allsum algorithms for all of these formalisms, some of which are faster or more space-efficient than several existing algorithms."
        },
        {
            "heading": "Limitations",
            "text": "Our stringsum algorithms can be used for LIG, EPDA, spinal TAG, and spinal PAA by first converting them to a two-level formalism, converting the resulting controller and controllee grammar/automaton into the normal form, and then merging their rules into a single set of rules. Similarly, for a general two-level formalism, the rules of the controller and the controllee would have to be extracted from the merged rules, converted into the normal form, and merged back before using the stringsum or allsum algorithm. Although simpler, requiring only CFG and PDA conversions, these transformations add some extra complexity. We leave direct normal form conversions for future work."
        },
        {
            "heading": "Ethics Statement",
            "text": "The authors foresee no ethical concerns with the research presented in this paper."
        },
        {
            "heading": "A Additional Preliminaries",
            "text": ""
        },
        {
            "heading": "A.1 Semirings",
            "text": "Definition 12. A monoid is a tuple (W,\u2299, I), where W is a set, \u2299 is an associative binary operation, and I \u2208 W , called the identity element, satisfies I \u2299 a = a\u2299 I = a for all a \u2208 W . If a\u2299 b = b\u2299 a for all a, b, we say that the monoid is commutative.\nDefinition 13. A semiring is a tuple W = (W,\u2295,\u2297,0,1) such that (W,\u2295,0) is a commutative monoid and (W,\u2297,1) is a monoid. Additionally, \u2297 distributes over \u2295, that is, a\u2297 (b\u2295 c) = a\u2297 b\u2295 a\u2297 c and (a\u2295 b)\u2297 c = a\u2297 c\u2295 b\u2297 c, and 0 is absorbing with respect to \u2297, that is, 0\u2297 a = a\u2297 0 = 0. If \u2297 is commutative, then we say that W is commutative.\nThe following definitions are from Esparza et al. (2007):\nDefinition 14. If W = (W,\u2295,\u2297,0,1) is a semiring, the natural order on W is the relation \u2264, defined such that a \u2264 b \u21d4 \u2203d \u2208 W : a \u2295 d = b. If \u2264 is a partial order (i.e., reflexive, antisymmetric, and transitive), then we say that W is naturally ordered. Definition 15. A naturally ordered semiring W = (W,\u2295,\u2297,0,1) is \u03c9-continuous if it is additionally equipped with an infinite summation operator \u2295 such that:\n\u2022 For any countable sequence (a1, a2, . . .), the sequence (\u2295k i=1 ai ) k\u22650 has a least upper bound in\nW and is equal to \u2295 i ai.\n\u2022 Multiplication distributes over infinite sums:\u2295 i (c\u2297 ai) = c\u2297 (\u2295 i ai ) \u2295 i (ai \u2297 c) = (\u2295 i ai ) \u2297 c.\n\u2022 For any partition (I1, I2, . . .) of N, \u2295 j \u2295 i\u2208Ij ai = \u2295 i ai."
        },
        {
            "heading": "A.2 Weighted Pushdown Automata",
            "text": "We use a definition of WPDA (Butoi et al., 2022) that is more general than usual and roughly a weighted version of the extended PDAs of Aho and Ullman (1972, p. 173) and the PDAs of Lewis and Papadimitriou (1997, p. 131).\nDefinition 16. A weighted pushdown automaton (WPDA) over a semiring W = W is a tuple P = (Q,\u03a3,\u0393, \u03b4,w, (q\u03b9,\u03b3\u03b9), (qf ,\u03b3f )), where\n\u2022 Q, \u03a3, and \u0393 are finite sets of states, input symbols, and stack symbols, respectively,\n\u2022 \u03b4 \u2286 Q\u00d7 \u0393\u2217 \u00d7 (\u03a3 \u222a {\u03b5})\u00d7Q\u00d7 \u0393\u2217 is a finite set of transitions,\n\u2022 w: \u03b4 \u2192 W is a transition-weighting function, and\n\u2022 (q\u03b9,\u03b3\u03b9) and (qf ,\u03b3f ), where q\u03b9, qf \u2208 Q,\u03b3\u03b9,\u03b3f \u2208 \u0393\u2217, are called the initial and final configurations.\nIf (p,\u03b3, a, q,\u03b3 \u2032) \u2208 \u03b4 is a transition, we write it as p,\u03b3 a\u2212\u2192 q,\u03b3 \u2032. If w(p,\u03b3 a\u2212\u2192 q,\u03b3 \u2032) = w, we use the notation p,\u03b3 a/w\u2212\u2212\u2192 q,\u03b3 \u2032.\nWe treat strings in \u0393\u2217 as stacks, with the first symbol being the top of the stack and the last symbol being the bottom.\nA WPDA moves from one configuration to another by following transitions of the form (p,\u03b3 a\u2212\u2192 q,\u03b3 \u2032), which represents a move from state p to state q, while scanning the symbol a , popping the sequence \u03b3 from the top of the stack and pushing the sequence \u03b3 \u2032. In the following definitions, let P = (Q,\u03a3,\u0393, \u03b4,w, (q\u03b9,\u03b3\u03b9), (qf ,\u03b3f )) be a WPDA. Definition 17. A configuration of P is a pair (q,\u03b3), where q \u2208 Q is the current state and \u03b3 \u2208 \u0393\u2217 is the current contents of the stack. We write C(P) for the set of all configurations of P. Definition 18. If (p,\u03b3\u03b1) and (q,\u03b3 \u2032\u03b1) are configurations of P and \u03c4 = (p,\u03b3 a\u2212\u2192 w, q\u03b3 \u2032) is a transition of P, we write (p,\u03b3\u03b1) \u03c4=\u21d2 (q,\u03b3 \u2032\u03b1) to denote that configuration (q,\u03b3 \u2032\u03b1) can be reached from (p,\u03b3\u03b1) in one step using transition \u03c4 .\nDefinition 19. We say that a transition \u03c4 is k-pop, l-push if |\u03b3| = k and |\u03b3 \u2032| = l. We say that \u03c4 scans a , and if a \u0338= \u03b5, we call \u03c4 scanning; otherwise, we call it non-scanning.\nThe following type of WPDA is a weighted version of the PDA used by Lang (1974) for his recognition algorithm.\nDefinition 20. A WPDA is called simple if each of its transitions is k-pop, l-push for some k \u2264 1 and l \u2264 1.\nThe following type of WPDA is a weighted version of the PDA used by (Hopcroft et al., 2006) and others.\nDefinition 21. A WPDA is called top-down if all of its transitions are 1-pop, and the initial and final configurations are (q\u03b9,S ) and (qf , \u03b5), respectively. Definition 22. A run of P from (q0,\u03b30) to (qn,\u03b3n) is a sequence of steps \u03c0 = (q0,\u03b30) \u03c41=\u21d2 \u00b7 \u00b7 \u00b7 \u03c4n==\u21d2 (qn,\u03b3n). We write (q0,\u03b30) \u2217 =\u21d2 (qn,\u03b3n) to assert that a run from (p,\u03b3) to (q,\u03b3 \u2032) exists, or to denote the\nset of all such runs. If (q0,\u03b30) = (q\u03b9,\u03b3\u03b9) and (qn,\u03b3n) = (qf ,\u03b3f ), we call \u03c0 accepting. If \u03c4 i scans ai, for i \u2208 [1:n], then we say that \u03c0 scans s = a1 \u00b7 \u00b7 \u00b7 an.\nThe weight of \u03c0 is the product of its transition weights,\nw(\u03c0) def = n\u2297 i=1 w(\u03c4 i).\nWe denote by \u03a0(P, s) the set all accepting runs of P scanning s, and by \u03a0(P) the set of all accepting runs of P.\nDefinition 23. The stringsum w(P, s) of a string s under P is the total weight of all accepting runs scanning s,\nw(P, s) def = \u2295 \u03c0\u2208\u03a0(P,s) w(\u03c0).\nDefinition 24. The allsum w(P) of P is the total weight of all its accepting runs,\nw(P) def = \u2295 \u03c0\u2208\u03a0(P) w(\u03c0)."
        },
        {
            "heading": "B Two-Level Formal Systems",
            "text": ""
        },
        {
            "heading": "B.1 Definitions",
            "text": "Having defined both WPDA (Def. 16) and WLD-CFG (Def. 7), we can give a definition for weighted PDA \u25b7 CFG.\nDefinition 25. Let P1 be a controller WPDA with states Q, stack alphabet \u03931 and initial configuration (q\u03b9,\u03b3\u03b9), and let G2 be a controllee WLD-CFG with nonterminals N 2. Then P1 \u25b7 G2 is a rewriting system with rules as follows.\n(a) If (q,A \u03b5/w\u2212\u2212\u2192 r,\u03b3) is a transition of P1, then P1 \u25b7 G2 has a rule for each X \u2208 N 2:\nX [q,A \u00b7\u00b7] w\u2212\u2192 X [r,\u03b3 \u00b7\u00b7].\n(b) If (r,A \u2113/w1\u2212\u2212\u2212\u2192 s, \u03b5) is a transition of P1, and (\u2113 : X w2\u2212\u2192 \u03b11\n(\nY\u03b12) is a production of G2, then G1 \u25b7 G2 has a rule\nX [r,A \u00b7\u00b7] w1\u2297w2\u2212\u2212\u2212\u2212\u2192 \u03b11[q\u03b9,\u03b3\u03b9]Y [s, \u00b7\u00b7]\u03b12[q\u03b9,\u03b3\u03b9].\nNext, we define WLD-PDAs by analogy with WLD-CFGs. This definition is a weighted version of our previous definition (Butoi et al., 2023).\nDefinition 26. A weighted labeled distinguished pushdown automaton (WLD-PDA) over a semiring W = (W,\u2295,\u2297,0,1) is a tuple P = (Q,\u03a3,\u0393, L, \u03b4,w, (q\u03b9,S ), (qf , \u03b5)), where\n\u2022 Q, \u03a3, \u0393 and L are finite sets of states, input symbols, stack symbols and labels, respectively,\n\u2022 \u03b4 \u2286 L\u00d7 N\u00d7Q\u00d7 \u0393\u00d7 (\u03a3 \u222a {\u03b5})\u00d7Q\u00d7 \u0393\u2217 is a finite set of transitions,\n\u2022 w: \u03b4 \u2192 W is the transition-weighting function, and\n\u2022 (q\u03b9,S ) and (qf , \u03b5), where q\u03b9, qf \u2208 Q,S \u2208 \u0393, are the initial and final configurations.\nIf (\u2113, i, q,A, a, r,B1 \u00b7 \u00b7 \u00b7Bn) is a transition in \u03b4, we must have either i = 0, which we write as q,A a\u2212\u2192 r,B1 \u00b7 \u00b7 \u00b7Bn, or 1 \u2264 i \u2264 n, which we write as q,A a\u2212\u2192 r,B1 \u00b7 \u00b7 \u00b7Bi\u22121 (\nBiBi+1 \u00b7 \u00b7 \u00b7Bn. A WLD-PDA behaves similarly to a WPDA, but its runs are controlled by either a controller CFG or\nPDA. As in \u00a73, the rules of the controller and of the controllee can be merged into a single system.\nDefinition 27. Let G1 be a controller CFG with nonterminals N and start symbol S, and let P2 be a WLD-PDA with stack alphabet \u0393 and states Q. Then G1 \u25b7 P2 is a rewriting system with rules as follows.\n(a) If (A w\u2212\u2192 \u03b2) is a production of G1, where \u03b2 \u2208 N \u2217, then G \u25b7 P2 has a transition for each X \u2208 \u0393 and q \u2208 Q:\nq,X [A \u00b7\u00b7] \u03b5/w\u2212\u2212\u2192 q,X [\u03b2 \u00b7\u00b7].\n(b) If (A w1\u2212\u2192 \u2113) is a production of G1, and \u2113 : q,X a/w2\u2212\u2212\u2212\u2192 r,\u03b11\n(\nY\u03b12 is a transition of P2, then G \u25b7 P2 has a transition\nq,X [A \u00b7\u00b7] a/w1\u2297w2\u2212\u2212\u2212\u2212\u2212\u2212\u2192 r,\u03b11[S]Y [\u00b7\u00b7]\u03b12[S].\nDefinition 28. Let P1 be a controller PDA with stack alphabet \u03931 and start configuration (q\u03b9,\u03b3\u03b9), and let P2 be a WLD-PDA with stack alphabet \u03932 and states Q2. Then P1 \u25b7 P2 is a rewriting system with rules as follows.\n(a) If (q,A \u03b5/w\u2212\u2212\u2192 r,\u03b3) is a transition of P1, then P1 \u25b7 P2 has a transition for each X \u2208 N 2 and\np \u2208 Q2: p,X [q,A \u00b7\u00b7] \u03b5/w\u2212\u2212\u2192 p,X [r,\u03b3 \u00b7\u00b7].\n(b) If (r,A \u2113/w1\u2212\u2212\u2212\u2192 s, \u03b5) is a transition of P1, and \u2113 : p,X a/w2\u2212\u2212\u2212\u2192 q,\u03b11\n(\nY\u03b12 is a transition of P2, then G \u25b7 P2 has a transition\np,X [r,A \u00b7\u00b7] a/w1\u2297w2\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q,\u03b11[q\u03b9,\u03b3\u03b9]Y [s, \u00b7\u00b7]\u03b12[q\u03b9,\u03b3\u03b9].\nThe terms scanning/non-scanning transitions and (accepting) runs are defined analogously to those for WPDAs."
        },
        {
            "heading": "B.2 Normal Forms",
            "text": "B.2.1 WCFG normal form Proposition 1. For any WCFG G1 with weights in an \u03c9-continuous semiring, there is a WCFG in Chomsky normal form that defines the same weighted language as G1.\nFor any WLD-CFG G2 with weights in an \u03c9-continuous semiring, there is a WLD-CFG in Chomsky normal form that is equivalent to G2.\nProof. The proof for WCFGs is a generalization of the standard conversion for unweighted grammars (Hopcroft et al., 2006), and is related to the Earley-style algorithm of Stolcke (1995).\n1. If S is the old start symbol, add a new nonterminal S\u2032, a production S\u2032 1\u2212\u2192 S, and make S\u2032 the new start symbol.\n2. For every terminal a, create a production Ta 1\u2212\u2192 a, where Ta is a fresh nonterminal, and replace every\nright-hand side occurrence of a with Ta.\n3. Replace every production X w\u2212\u2192 Y1 \u00b7 \u00b7 \u00b7Yk, where k > 2, with the productions\nX w\u2212\u2192 Y1Z1\nZ1 1\u2212\u2192 Y2Z2 ...\nZk\u22122 1\u2212\u2192 Yk\u22121Yk\nwhere Z1, . . . , Zk\u22122 are fresh nonterminals.\n4. For each nonterminal X , compute the weight of all partial derivations X \u2217=\u21d2 \u03b5 using the deductive system\nA \u2217 =\u21d2\u03b5 A\nw\u2212\u2192 \u03b5\nB \u2217 =\u21d2\u03b5 A \u2217 =\u21d2\u03b5 A w\u2212\u2192 B\nB \u2217 =\u21d2\u03b5 C \u2217=\u21d2\u03b5\nA \u2217 =\u21d2\u03b5 A\nw\u2212\u2192 BC\nThen for every production X w\u2212\u2192 Y Z with w(Y \u2217=\u21d2 \u03b5) = wY and w(Z \u2217 =\u21d2 \u03b5) = wZ , add productions X w1\u2297wY\u2212\u2212\u2212\u2212\u2212\u2192 Z and X w1\u2297wZ\u2212\u2212\u2212\u2212\u2212\u2192 Y . Finally, for all X , remove all productions X \u2192 \u03b5.\n5. For all nonterminals X and Y , compute the weight of all partial derivations X \u2217=\u21d2 Y using the deductive system\nA \u2217 =\u21d2A A \u2217 =\u21d2B A \u2217 =\u21d2C B w\u2212\u2192 C\nThen for every production X w2\u2212\u2192 Y Z and nonterminal W \u0338= X , with w(W \u2217=\u21d2 X) = w1, add production W w1\u2297w2\u2212\u2212\u2212\u2212\u2192 Y Z. Finally, for all X , Y , remove all productions X \u2192 Y .\nNow we give a similar construction for WLD-CFGs. Let G be a WLD-CFG and F a controller WCFG or WPDA, both with weights from an \u03c9-continuous semiring. Then there exists a WLD-CFG in normal form G\u2032 and a controller F\u2032 such that F\u2032 \u25b7 G\u2032 defines the same weighted language as F \u25b7 G. We assume for simplicity that F is a controller WCFG; a similar construction can be given when it is a WPDA.\nConverting a CFG \u25b7 CFG to normal form requires an allsum algorithm that works on any binarized CFG \u25b7 CFG, not necessarily in normal form. We must use the rules shown in Fig. 5 in addition to those from Fig. 4b when computing allsums.\nRoot\u2013foot transform The nullary and unary removal steps below are analogous to nullary and unary removal in a WCFG. However, sometimes, when we remove nullary/unary rules, we need information from both the controller and controllee to compute their lost weight. To facilitate this, we define the following transformation, which copies information from the controllee to the controller.\nLet N 1 and N 2 be the controller and controllee nonterminal alphabet, respectively.\n1. For every controllee rule \u2113 : X \u2192 \u03b1 where \u03b1 has no distinguished symbol, relabel the rule as \u2113X\u22a5 .\n2. For every controllee rule \u2113 : X \u2192 \u03b1\n(\nY\u03b2, relabel the rule as \u2113XY .\n3. Perform the construction of Bar-Hillel et al. (1961) on the controller, using controllee nonterminals instead of states. That is, relabel every controller nonterminal A as AX\u22a5 or A X Y for all X ,Y \u2208 N 2,\nmaking as many copies of rules as needed, subject to the constraints that (i) if the lhs is AXY (where Y could be \u22a5) then the first rhs symbol must be AXY \u2032 and the last rhs symbol must be AX \u2032 Y ; (ii) if A X Y is an rhs nonterminal then its successor (if any) must be BYZ .\n4. Add a new controller start symbol S\u2032 with rules S\u2032 \u2192 SX\u22a5 for all X \u2208 N 2.\nControllee binarization In the controllee, replace every production \u2113 : X w\u2212\u2192 Y1 \u00b7 \u00b7 \u00b7\n(\nYd \u00b7 \u00b7 \u00b7Yk, where k > 2, with the productions\n\u21131 : X w\u2212\u2192 Y1\n(\nZ1\n\u21132 : Z1 1\u2212\u2192 Y2\n(\nZ2 ...\n\u2113d\u22121 : Zd\u22122 1\u2212\u2192 Yd\u22121\n(\nZd\n\u2113d : Zd 1\u2212\u2192\n(\nZd+1Yk\n\u2113d+1 : Zd+1 1\u2212\u2192\n(\nZd+2Yk\u22121 ...\n\u2113k\u22121 : Zk\u22121 1\u2212\u2192\n(\nYdYd+1\nwhere Z1, . . . ,Zk\u22122 are fresh controllee nonterminals. Accordingly, in the controller, replace every rhs occurrence of \u2113 with \u21131 \u00b7 \u00b7 \u00b7 \u2113k\u22121.\nControllee nullary removal Like the standard nullary removal algorithm (Hopcroft et al., 2006), nullary removal in an WLD-CFG has three steps: partitioning, precomputation, and removal. However, removing nullary rules from the controllee also sometimes requires modifications to the controller.\n1. Partition: Replace every controllee nonterminal X with two nonterminals X\u03b5 and X\u0338\u03b5. Every rule with k rhs nonterminals becomes 2k rules with all possible combination of rhs nonterminals, and the lhs annotated \u03b5 iff the rhs is empty or all the rhs symbols are annotated \u03b5. The start symbol is S\u0338\u03b5. 2. Precompute: Compute the allsum w ( X\u03b5[A] ) for all A \u2208 N 1,X\u03b5 \u2208 N 2.\n3. Remove (non-distinguished): For every non-distinguished occurrence of X\u03b5 in the rhs of a controllee rule \u03c0, delete the occurrence and multiply the weight of \u03c0 by w ( X\u03b5[S] ) .\n4. Remove (distinguished): The distinguished occurrences of X\u03b5 cannot be removed in the same way, because we don\u2019t know what weight to multiply in. Instead, perform the root\u2013foot transform. Then, for every occurrence of AX\u03b5\u22a5 on the rhs of a controller rule \u03c0, delete the occurrence and multiply the\nweight of \u03c0 by w ( X\u03b5[A] ) .\n5. Remove (start): Add controller rule S\u2032 1\u2212\u2192 \u2113 and controllee rule \u2113 : S\u0338 \u03b5 w\u2212\u2192 \u03b5, where w = w ( S\u03b5[S] ) .\n6. Remove every controller rule S\u2032 \u2192 \u03b5.\n7. Remove every controller rule with lhs AX\u03b5\u22a5 and every controllee rule with lhs X\u03b5."
        },
        {
            "heading": "Controllee unary removal",
            "text": "1. Partition: Replace every controller nonterminal A with two nonterminals AU and A \u0338U. Every rule with k rhs nonterminals becomes 2k rules. A rule\u2019s lhs is annotated U iff all of its rhs symbols are either labels of controllee unary rules or annotated U. The controller temporarily has two start symbols, SU and S \u0338U.\n2. Precompute: Compute the allsum w  X [AU \u00b7\u00b7]Y [\u00b7\u00b7]  for all AU \u2208 N 1, X, Y \u2208 N 2.\n3. Remove (controller): Perform the root\u2013foot transform. Then, for every occurrence of AUXY on the\nrhs of rule \u03c0, delete the occurrence and multiply the weight of \u03c0 by w  AU[X \u00b7\u00b7]Y [\u00b7\u00b7] . Remove all\nrules with lhs XAUY .\n4. Remove (controllee): Remove all unary rules, and for each rule \u2113 : Y w\u2212\u2192 \u03b1, and all X \u2208 N 2, make a copy \u2113 : X w\u2212\u2192 \u03b1.\nB.2.2 WPDA normal form We first define a WPDA normal form that is analogous to Chomsky normal form for WCFGs.\nDefinition 29. A WPDA is in normal form if all of its transitions are of one of the following types: (1) q\u03b9,S\n\u03b5/w\u2212\u2212\u2192 qf , \u03b5, (2) scanning and 0-push, or (3) non-scanning and 2-push. Moreover, S is not pushed by any transition.\nA WLD-PDA is in normal form if all of its transitions are of type (1) or (2) above, (3a) q,X \u03b5/w\u2212\u2212\u2192 r,\n(\nYZ ,\nor (3b) q,X \u03b5/w\u2212\u2212\u2192 r,Y ( Z .\nProposition 2. Let P be a WPDA with weights from an \u03c9-continuous semiring. Then there is a WPDA in normal form that defines the same weighted language as P.\nFor any WLD-PDA P2 with weights in an \u03c9-continuous semiring, there is a WLD-PDA in Chomsky normal form that is equivalent to P2.\nProof. In previous work (Butoi et al., 2022), we gave a conversion from arbitrary WPDAs to a normal form that is close to Def. 29, but allows transitions that are scanning but are 1-push or 2-push. We can modify the conversion using the following preparatory steps:\n1. If (q\u03b9,\u03b3\u03b9) is the old start configuration, add a new state q\u03b9\u2032, a new stack symbol S\u2032, and a transition q\u03b9 \u2032, S\u2032 1\u2212\u2192 q\u03b9,\u03b3\u03b9, and make (q\u03b9\u2032, S\u2032) the new start configuration.\n2. For every terminal a, add a fresh stack symbol Ta. Replace every scanning transition (q,X a/w\u2212\u2212\u2192 r, \u03b3)\nwith (q,X \u03f5/w\u2212\u2212\u2192 r, Ta\u03b3), and add transitions (q, Ta a/1\u2212\u2212\u2192 q, \u03b5) for every state q.\n3. Remove all nullary transitions (Butoi et al., 2022, \u00a73.2).\n4. Remove all unary transitions (Butoi et al., 2022, \u00a73.3).\nA WLD-PDA can always be converted into an equivalent WLD-CFG (Butoi et al., 2023), converted into the normal form, then converted back into into a WLD-PDA.\nTo convert a WLD-PDA to normal form, we use the construction above, modified by analogy with Prop. 1. In the root\u2013foot transform, each nonterminal includes two or four states (just as allsum items do). The nullary removal procedure for WPDAs is more complex than for WCFGs, but the required modification is analogous: we remove non-distinguished stack symbols X\u03b5 as usual, but when removing a distinguished stack symbol X\u03b5, we must multiply its weight in the controller rather than the controllee.\nB.2.3 Two-level normal forms Fig. 6 shows how the normal forms of PDA \u25b7 CFG, CFG \u25b7 PDA and PDA \u25b7 PDA are obtained from the normal forms of the controllees and the controllers. For the epsilon rules, as noted in \u00a73.2, in principle there could be rules with other left-hand sides, but such rules would never be used."
        },
        {
            "heading": "C Computing Stringsums",
            "text": ""
        },
        {
            "heading": "C.1 Pop Computations",
            "text": "Definition 30. Let P be a controller WPDA with states Q, and stack alphabet \u0393, and let G be a WLD-CFG with nonterminals N . Let s \u2208 \u03a3\u2217 be a string of length |s| = n. A pop computation of P \u25b7 G of type\nX [p, A \u00b7\u00b7]\ni l\nj k\nY [q, \u00b7\u00b7] , where 0 \u2264 i \u2264 j \u2264 k \u2264 l \u2264 n, p, q \u2208 Q, X ,Y \u2208 N , and A \u2208 \u0393, is a pair of partial\nderivations (d1, d2), where\nd1 \u2208 (X [p,A] \u2217 =\u21d2 s(i:j]Y [q, \u03b5]\u03a52)\nd2 \u2208 (\u03a52 \u2217 =\u21d2 s(k:l]).\nA pop computation of type X [p, A] i j is a partial derivation X [p,A] \u2217=\u21d2 s(i:j].\nDefinition 31. Let G be a controller WCFG with nonterminals N , and let P be a WLD-PDA with states Q and stack alphabet \u0393. Let s \u2208 \u03a3\u2217 be an input string of length |s| = n. A pop computation of G \u25b7 P of\ntype\nX [A \u00b7\u00b7]\ni, p l, s\nj, q k, r\nY [\u00b7\u00b7] , where 0 \u2264 i \u2264 j \u2264 k \u2264 l \u2264 n, p, q, r, s \u2208 Q, X ,Y \u2208 \u0393, and A \u2208 N , is a pair of\nruns (\u03c01,\u03c02), where\n\u03c01 \u2208 ((p,X [A]) \u2217 =\u21d2 (q,Y [\u03b5]\u03a52)) and scans s(i:j]\n\u03c02 \u2208 ((r,\u03a52) \u2217 =\u21d2 (s, \u03b5)) and scans s(k:l].\nA pop computation of type X [A] i, p j, q is a run (p,X [A]) \u2217=\u21d2 (q, \u03b5) scanning s(i:j].\nDefinition 32. Let P1 be a controller WPDA and P2 be a WLD-PDA, with states and stack alphabets Q1 and \u03931, and Q2 and \u03932, respectively. Let s \u2208 \u03a3\u2217 be an input string of length |s| = n. A pop computation\nof P1 \u25b7 P2 of type\nX [e, A \u00b7\u00b7]\ni, p l, s\nj, q k, r\nY [f, \u00b7\u00b7] , where 0 \u2264 i \u2264 j \u2264 k \u2264 l \u2264 n, p, q, r, s \u2208 Q2, e, f \u2208 Q1,\nX ,Y \u2208 \u03932, and A \u2208 \u03931, is a pair of runs (\u03c01,\u03c02), where\n\u03c01 \u2208 ((p,X [e,A]) \u2217 =\u21d2 (q,Y [f, \u03b5]\u03a52)) and scans s(i:j]\n\u03c02 \u2208 ((r,\u03a52) \u2217 =\u21d2 (s, \u03b5)) and scans s(k:l].\nA pop computation of type X [e, A] i, p j, q is a run (p,X [e,A]) \u2217=\u21d2 (q, \u03b5) scanning s(i:j]."
        },
        {
            "heading": "C.2 Deduction Systems",
            "text": "Figures 7 to 9, in the columns labeled \u201cstringsum,\u201d show deduction systems for computing stringsums of PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA. The controller and controllee PDAs are assumed to be single-state.\nThe goal items for PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA are, in order, S [q\u03b9, S] 0 n , S [S] 0, q\u03b9 n, qf , and\nS [q1\u03b9 , S]\n0, q2\u03b9 n, qf , where n is the length of the input string."
        },
        {
            "heading": "D Computing Allsums",
            "text": "Definition 33. Let P be a controller WPDA with states Q and stack alphabet \u0393, and let G be a WLD-CFG\nwith nonterminal alphabet N . A pop computation of P \u25b7 G of type\nX [p, A \u00b7\u00b7]\nY [q, \u00b7\u00b7] , where X ,Y \u2208 N ,\np, q \u2208 Q, and A \u2208 \u0393, is a pair of partial derivations (d1, d2), where\nd1 \u2208 (X [p,A] \u2217 =\u21d2 s1Y [q, \u03b5]\u03a52)\nd2 \u2208 (\u03a52 \u2217 =\u21d2 s2)\nand s1, s2 \u2208 \u03a3\u2217, \u03a52 \u2208 N [\u0393\u2217]\u2217. The weight of this pop computation is w(d1, d2) = w(d1)\u2297w(d2). A pop computation of type X [p, A] is a partial derivation X [p,A] \u2217=\u21d2 s, where s \u2208 \u03a3\u2217.\nDefinition 34. Let G be a controller CFG with nonterminal alphabet N , and let P be a WLD-PDA with\nstates Q and stack alphabet \u0393. A pop computation of G \u25b7 P of type\nX [A \u00b7\u00b7]\np s\nq r\nY [\u00b7\u00b7] , where X ,Y \u2208 \u0393,\np, q, r, s \u2208 Q, and A \u2208 N , is a pair of runs (\u03c01,\u03c02), where\n\u03c01 \u2208 ((p,X [A]) \u2217 =\u21d2 (q,Y [\u03b5]\u03a52)) and scans s1\n\u03c02 \u2208 ((r,\u03a52) \u2217 =\u21d2 (s, \u03b5)) and scans s2\nand s1, s2 \u2208 \u03a3\u2217, \u03a52 \u2208 \u0393[N \u2217]\u2217. The weight of this pop computation is w(\u03c01,\u03c02) = w(\u03c01)\u2297w(\u03c02). A pop computation of type X [A]\np q is a run (p,X [A]) \u2217=\u21d2 (q, \u03b5) scanning some s \u2208 \u03a3\u2217.\nDefinition 35. Let P1 be a controller WPDA and P2 a WLD-PDA. Additionally, let Q1 and \u03931, and Q2 and \u03932 be the states and stack alphabets of P1 and P2, respectively. A pop computation of P1 \u25b7 P2\nof type\nX [e, A \u00b7\u00b7]\np s\nq r\nY [f, \u00b7\u00b7] , where p, q, r, s \u2208 Q2, e, f \u2208 Q1, X ,Y \u2208 \u03932 and A \u2208 \u03931, is is a pair of runs\n(\u03c01,\u03c02), where\n\u03c01 \u2208 ((p,X [e,A]) \u2217 =\u21d2 (q,Y [f, \u03b5]\u03a52)) and scans s1\n\u03c02 \u2208 ((r,\u03a52) \u2217 =\u21d2 (s, \u03b5)) and scans s2\nand s1, s2 \u2208 \u03a3\u2217, \u03a52 \u2208 \u03932[\u0393\u22171]\u2217. The weight of this pop computation is w(\u03c01,\u03c02) = w(\u03c01)\u2297w(\u03c02). A pop computation of type X [e, A]\np q is a run (p,X [e,A]) \u2217=\u21d2 (q, \u03b5) scanning some s \u2208 \u03a3\u2217.\nFigures 7 to 9, in the columns labeled \u201callsum\u201d, show deductive systems for computing allsums of PDA \u25b7 CFG, CFG \u25b7 PDA, and PDA \u25b7 PDA. As in \u00a75, the value of the goal item can be computed by fixed-point iteration or the semiring generalization of Newton\u2019s method."
        },
        {
            "heading": "E Complexity Analysis of Conversions",
            "text": "Our stringsum and allsum algorithms, although designed for the two-level formalisms, can also be used for TAG, LIG, PAA, and EPDA. However, we must apply a series of conversions in order to do this. For instance, we must apply the following transformations to a WLIG with sets of nonterminals N and stack symbols \u0393 before feeding it into the stringsum algorithm:\n1. The controller WPDA and the controllee WCFG have to be extracted from the WLIG, resulting in a WCFG with O(|N |) nonterminals and a WPDA with O(|\u0393|) stack symbols.\n2. The controllee WCFG must be converted into Chomsky normal form. If the productions have at most k symbols on the right-hand side, then the output WCFG has O(k \u00d7 |R|) nonterminals. Similarly, the controller WPDA must be converted into the normal form. If the WPDA has transitions that push at most k symbols, the resulting WPDA has O(k \u00d7 |\u03b4|) states.\n3. The rules of the controller and of the controllee need to be merged back into a set of WLIG rules. This construction outputs a WLIG with O(|N |\u00d7|Q|) nonterminals and O(|\u0393|) stack symbols, where N is the set of nonterminals of the input controllee, and Q and \u0393 are the sets of states and stack symbols of the input controller."
        }
    ],
    "title": "Efficient Algorithms for Recognizing Weighted Tree-Adjoining Languages",
    "year": 2023
}