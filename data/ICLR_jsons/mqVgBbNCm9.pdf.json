{
    "abstractText": "This work aims at decreasing the end-to-end generation latency of large language models (LLMs). One of the major causes of the high generation latency is the sequential decoding approach adopted by almost all state-of-the-art LLMs. In this work, motivated by the thinking and writing process of humans, we propose Skeleton-of-Thought (SoT), which first guides LLMs to generate the skeleton of the answer, and then conducts parallel API calls or batched decoding to complete the contents of each skeleton point in parallel. Not only does SoT provide considerable speed-ups across 12 LLMs, but it can also potentially improve the answer quality on several question categories. SoT is an initial attempt at data-centric optimization for inference efficiency, and showcases the potential of eliciting highquality answers by explicitly planning the answer structure in language.",
    "authors": [
        {
            "affiliations": [],
            "name": "Xuefei Ning"
        },
        {
            "affiliations": [],
            "name": "Zinan Lin"
        },
        {
            "affiliations": [],
            "name": "Zixuan Zhou"
        },
        {
            "affiliations": [],
            "name": "Zifu Wang"
        },
        {
            "affiliations": [],
            "name": "Huazhong Yang"
        },
        {
            "affiliations": [],
            "name": "Yu Wang"
        }
    ],
    "id": "SP:ff5fe29fd73cc5f6558487065c5983dc2f7fb10e",
    "references": [
        {
            "authors": [
                "Maciej Besta",
                "Nils Blach",
                "Ales Kubicek",
                "Robert Gerstenberger",
                "Lukas Gianinazzi",
                "Joanna Gajda",
                "Tomasz Lehmann",
                "Michal Podstawski",
                "Hubert Niewiadomski",
                "Piotr Nyczyk"
            ],
            "title": "Graph of thoughts: Solving elaborate problems with large language models",
            "venue": "arXiv preprint arXiv:2308.09687,",
            "year": 2023
        },
        {
            "authors": [
                "Tom Brown",
                "Benjamin Mann",
                "Nick Ryder",
                "Melanie Subbiah",
                "Jared D Kaplan",
                "Prafulla Dhariwal",
                "Arvind Neelakantan",
                "Pranav Shyam",
                "Girish Sastry",
                "Amanda Askell"
            ],
            "title": "Language models are few-shot learners",
            "venue": "Advances in neural information processing systems,",
            "year": 2020
        },
        {
            "authors": [
                "Han Cai",
                "Chuang Gan",
                "Tianzhe Wang",
                "Zhekai Zhang",
                "Song Han"
            ],
            "title": "Once-for-all: Train one network and specialize it for efficient deployment",
            "year": 1908
        },
        {
            "authors": [
                "Harrison Chase"
            ],
            "title": "LangChain, October 2022. URL https://github.com/hwchase17/ langchain",
            "year": 2022
        },
        {
            "authors": [
                "Charlie Chen",
                "Sebastian Borgeaud",
                "Geoffrey Irving",
                "Jean-Baptiste Lespiau",
                "Laurent Sifre",
                "John Jumper"
            ],
            "title": "Accelerating large language model decoding with speculative sampling",
            "venue": "arXiv preprint arXiv:2302.01318,",
            "year": 2023
        },
        {
            "authors": [
                "Wenhu Chen",
                "Xueguang Ma",
                "Xinyi Wang",
                "William W Cohen"
            ],
            "title": "Program of thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks",
            "venue": "arXiv preprint arXiv:2211.12588,",
            "year": 2022
        },
        {
            "authors": [
                "Zhaodong Chen",
                "Zheng Qu",
                "Yuying Quan",
                "Liu Liu",
                "Yufei Ding",
                "Yuan Xie"
            ],
            "title": "Dynamic n: M fine-grained structured sparse attention mechanism",
            "venue": "In Proceedings of the 28th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming,",
            "year": 2023
        },
        {
            "authors": [
                "Zhihong Chen",
                "Junying Chen",
                "Hongbo Zhang",
                "Feng Jiang",
                "Guiming Chen",
                "Fei Yu",
                "Tiannan Wang",
                "Juhao Liang",
                "Chen Zhang",
                "Zhiyi Zhang",
                "Jianquan Li",
                "Xiang Wan",
                "Haizhou Li",
                "Benyou Wang"
            ],
            "title": "Llm zoo: democratizing chatgpt. https://github.com/FreedomIntelligence/ LLMZoo, 2023c",
            "year": 2023
        },
        {
            "authors": [
                "Wei-Lin Chiang",
                "Zhuohan Li",
                "Zi Lin",
                "Ying Sheng",
                "Zhanghao Wu",
                "Hao Zhang",
                "Lianmin Zheng",
                "Siyuan Zhuang",
                "Yonghao Zhuang",
                "Joseph E. Gonzalez",
                "Ion Stoica",
                "Eric P. Xing"
            ],
            "title": "Vicuna: An open-source chatbot impressing gpt-4 with 90%* chatgpt quality, March 2023",
            "venue": "URL https: //lmsys.org/blog/2023-03-30-vicuna/",
            "year": 2023
        },
        {
            "authors": [
                "Hyung Won Chung",
                "Le Hou",
                "Shayne Longpre",
                "Barret Zoph",
                "Yi Tay",
                "William Fedus",
                "Eric Li",
                "Xuezhi Wang",
                "Mostafa Dehghani",
                "Siddhartha Brahma"
            ],
            "title": "Scaling instruction-finetuned language models",
            "venue": "arXiv preprint arXiv:2210.11416,",
            "year": 2022
        },
        {
            "authors": [
                "Tri Dao",
                "Dan Fu",
                "Stefano Ermon",
                "Atri Rudra",
                "Christopher R\u00e9"
            ],
            "title": "Flashattention: Fast and memoryefficient exact attention with io-awareness",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Emily L Denton",
                "Wojciech Zaremba",
                "Joan Bruna",
                "Yann LeCun",
                "Rob Fergus"
            ],
            "title": "Exploiting linear structure within convolutional networks for efficient evaluation",
            "venue": "Advances in neural information processing systems,",
            "year": 2014
        },
        {
            "authors": [
                "Ning Ding",
                "Yulin Chen",
                "Bokai Xu",
                "Yujia Qin",
                "Zhi Zheng",
                "Shengding Hu",
                "Zhiyuan Liu",
                "Maosong Sun",
                "Bowen Zhou"
            ],
            "title": "Enhancing chat language models by scaling high-quality instructional conversations",
            "venue": "arXiv preprint arXiv:2305.14233,",
            "year": 2023
        },
        {
            "authors": [
                "Zhengxiao Du",
                "Yujie Qian",
                "Xiao Liu",
                "Ming Ding",
                "Jiezhong Qiu",
                "Zhilin Yang",
                "Jie Tang"
            ],
            "title": "Glm: General language model pretraining with autoregressive blank infilling",
            "venue": "In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),",
            "year": 2022
        },
        {
            "authors": [
                "Thomas Elsken",
                "Jan Hendrik Metzen",
                "Frank Hutter"
            ],
            "title": "Neural architecture search: A survey",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2019
        },
        {
            "authors": [
                "Angela Fan",
                "Mike Lewis",
                "Yann Dauphin"
            ],
            "title": "Hierarchical neural story generation",
            "venue": "arXiv preprint arXiv:1805.04833,",
            "year": 2018
        },
        {
            "authors": [
                "Jiarui Fang",
                "Yang Yu",
                "Chengduo Zhao",
                "Jie Zhou"
            ],
            "title": "Turbotransformers: an efficient gpu serving system for transformer models",
            "venue": "In Proceedings of the 26th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming,",
            "year": 2021
        },
        {
            "authors": [
                "William Fedus",
                "Barret Zoph",
                "Noam Shazeer"
            ],
            "title": "Switch transformers: Scaling to trillion parameter models with simple and efficient sparsity",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2022
        },
        {
            "authors": [
                "Elias Frantar",
                "Saleh Ashkboos",
                "Torsten Hoefler",
                "Dan Alistarh"
            ],
            "title": "Gptq: Accurate post-training quantization for generative pre-trained transformers",
            "venue": "arXiv preprint arXiv:2210.17323,",
            "year": 2022
        },
        {
            "authors": [
                "Prakhar Ganesh",
                "Yao Chen",
                "Xin Lou",
                "Mohammad Ali Khan",
                "Yin Yang",
                "Hassan Sajjad",
                "Preslav Nakov",
                "Deming Chen",
                "Marianne Winslett"
            ],
            "title": "Compressing large-scale transformer-based models: A case study on bert",
            "venue": "Transactions of the Association for Computational Linguistics,",
            "year": 2021
        },
        {
            "authors": [
                "Joao Gante"
            ],
            "title": "Assisted generation: a new direction toward low-latency text generation",
            "venue": "https: //huggingface.co/blog/assisted-generation,",
            "year": 2023
        },
        {
            "authors": [
                "Jiatao Gu",
                "James Bradbury",
                "Caiming Xiong",
                "Victor O.K. Li",
                "Richard Socher"
            ],
            "title": "Non-autoregressive neural machine translation",
            "venue": "In International Conference on Learning Representations,",
            "year": 2018
        },
        {
            "authors": [
                "Song Han",
                "Huizi Mao",
                "William J Dally"
            ],
            "title": "Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding",
            "venue": "arXiv preprint arXiv:1510.00149,",
            "year": 2015
        },
        {
            "authors": [
                "Jiaxin Huang",
                "Shixiang Shane Gu",
                "Le Hou",
                "Yuexin Wu",
                "Xuezhi Wang",
                "Hongkun Yu",
                "Jiawei Han"
            ],
            "title": "Large language models can self-improve",
            "venue": "arXiv preprint arXiv:2210.11610,",
            "year": 2022
        },
        {
            "authors": [
                "Yanping Huang",
                "Youlong Cheng",
                "Ankur Bapna",
                "Orhan Firat",
                "Dehao Chen",
                "Mia Chen",
                "HyoukJoong Lee",
                "Jiquan Ngiam",
                "Quoc V Le",
                "Yonghui Wu"
            ],
            "title": "Gpipe: Efficient training of giant neural networks using pipeline parallelism",
            "venue": "Advances in neural information processing systems,",
            "year": 2019
        },
        {
            "authors": [
                "Andrei Ivanov",
                "Nikoli Dryden",
                "Tal Ben-Nun",
                "Shigang Li",
                "Torsten Hoefler"
            ],
            "title": "Data movement is all you need: A case study on optimizing transformers",
            "venue": "Proceedings of Machine Learning and Systems,",
            "year": 2021
        },
        {
            "authors": [
                "Huiqiang Jiang",
                "Qianhui Wu",
                "Chin-Yew Lin",
                "Yuqing Yang",
                "Lili Qiu"
            ],
            "title": "Llmlingua: Compressing prompts for accelerated inference of large language models",
            "venue": "In Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics,",
            "year": 2023
        },
        {
            "authors": [
                "Nikita Kitaev",
                "\u0141ukasz Kaiser",
                "Anselm Levskaya"
            ],
            "title": "Reformer: The efficient transformer",
            "venue": "arXiv preprint arXiv:2001.04451,",
            "year": 2020
        },
        {
            "authors": [
                "Takeshi Kojima",
                "Shixiang Shane Gu",
                "Machel Reid",
                "Yutaka Matsuo",
                "Yusuke Iwasawa"
            ],
            "title": "Large language models are zero-shot reasoners",
            "venue": "Advances in neural information processing systems,",
            "year": 2022
        },
        {
            "authors": [
                "Raghuraman Krishnamoorthi"
            ],
            "title": "Quantizing deep convolutional networks for efficient inference: A whitepaper",
            "venue": "arXiv preprint arXiv:1806.08342,",
            "year": 2018
        },
        {
            "authors": [
                "Alex Krizhevsky"
            ],
            "title": "One weird trick for parallelizing convolutional neural networks",
            "venue": "arXiv preprint arXiv:1404.5997,",
            "year": 2014
        },
        {
            "authors": [
                "Woosuk Kwon",
                "Zhuohan Li",
                "Siyuan Zhuang",
                "Ying Sheng",
                "Lianmin Zheng",
                "Cody Hao Yu",
                "Joseph E Gonzalez",
                "Hao Zhang",
                "Ion Stoica"
            ],
            "title": "Efficient memory management for large language model serving with pagedattention",
            "venue": "arXiv preprint arXiv:2309.06180,",
            "year": 2023
        },
        {
            "authors": [
                "Dmitry Lepikhin",
                "HyoukJoong Lee",
                "Yuanzhong Xu",
                "Dehao Chen",
                "Orhan Firat",
                "Yanping Huang",
                "Maxim Krikun",
                "Noam Shazeer",
                "Zhifeng Chen"
            ],
            "title": "GS}hard: Scaling giant models with conditional computation and automatic sharding",
            "venue": "In International Conference on Learning Representations,",
            "year": 2021
        },
        {
            "authors": [
                "Brian Lester",
                "Rami Al-Rfou",
                "Noah Constant"
            ],
            "title": "The power of scale for parameter-efficient prompt tuning",
            "venue": "arXiv preprint arXiv:2104.08691,",
            "year": 2021
        },
        {
            "authors": [
                "Yaniv Leviathan",
                "Matan Kalman",
                "Yossi Matias"
            ],
            "title": "Fast inference from transformers via speculative decoding",
            "venue": "arXiv preprint arXiv:2211.17192,",
            "year": 2022
        },
        {
            "authors": [
                "Guohao Li",
                "Hasan Abed Al Kader Hammoud",
                "Hani Itani",
                "Dmitrii Khizbullin",
                "Bernard Ghanem"
            ],
            "title": "Camel: Communicative agents for \u201dmind\u201d exploration of large scale language model society, 2023a",
            "year": 2023
        },
        {
            "authors": [
                "Jiwei Li",
                "Minh-Thang Luong",
                "Dan Jurafsky"
            ],
            "title": "A hierarchical neural autoencoder for paragraphs and documents",
            "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),",
            "year": 2015
        },
        {
            "authors": [
                "Xiang Lisa Li",
                "Percy Liang"
            ],
            "title": "Prefix-tuning: Optimizing continuous prompts for generation",
            "venue": "arXiv preprint arXiv:2101.00190,",
            "year": 2021
        },
        {
            "authors": [
                "Xuechen Li",
                "Tianyi Zhang",
                "Yann Dubois",
                "Rohan Taori",
                "Ishaan Gulrajani",
                "Carlos Guestrin",
                "Percy Liang",
                "Tatsunori B. Hashimoto"
            ],
            "title": "Alpacaeval: An automatic evaluator of instruction-following models. https://github.com/tatsu-lab/alpaca_eval, 2023b",
            "year": 2023
        },
        {
            "authors": [
                "Yifei Li",
                "Zeqi Lin",
                "Shizhuo Zhang",
                "Qiang Fu",
                "Bei Chen",
                "Jian-Guang Lou",
                "Weizhu Chen"
            ],
            "title": "Making language models better reasoners with step-aware verifier",
            "venue": "In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),",
            "year": 2023
        },
        {
            "authors": [
                "Zhuohan Li",
                "Siyuan Zhuang",
                "Shiyuan Guo",
                "Danyang Zhuo",
                "Hao Zhang",
                "Dawn Song",
                "Ion Stoica"
            ],
            "title": "Terapipe: Token-level pipeline parallelism for training large-scale language models",
            "venue": "In International Conference on Machine Learning,",
            "year": 2021
        },
        {
            "authors": [
                "Ji Lin",
                "Jiaming Tang",
                "Haotian Tang",
                "Shang Yang",
                "Xingyu Dang",
                "Song Han"
            ],
            "title": "Awq: Activation-aware weight quantization for llm compression and acceleration",
            "venue": "arXiv preprint arXiv:2306.00978,",
            "year": 2023
        },
        {
            "authors": [
                "Pengfei Liu",
                "Weizhe Yuan",
                "Jinlan Fu",
                "Zhengbao Jiang",
                "Hiroaki Hayashi",
                "Graham Neubig"
            ],
            "title": "Pretrain, prompt, and predict: A systematic survey of prompting methods in natural language processing",
            "venue": "ACM Computing Surveys,",
            "year": 2023
        },
        {
            "authors": [
                "Yinhan Liu",
                "Myle Ott",
                "Naman Goyal",
                "Jingfei Du",
                "Mandar Joshi",
                "Danqi Chen",
                "Omer Levy",
                "Mike Lewis",
                "Luke Zettlemoyer",
                "Veselin Stoyanov"
            ],
            "title": "Roberta: A robustly optimized bert pretraining approach, 2019",
            "year": 2019
        },
        {
            "authors": [
                "Ilya Loshchilov",
                "Frank Hutter"
            ],
            "title": "Decoupled weight decay regularization",
            "venue": "In International Conference on Learning Representations,",
            "year": 2019
        },
        {
            "authors": [
                "Wenyan Lu",
                "Guihai Yan",
                "Jiajun Li",
                "Shijun Gong",
                "Yinhe Han",
                "Xiaowei Li"
            ],
            "title": "Flexflow: A flexible dataflow accelerator architecture for convolutional neural networks",
            "venue": "IEEE International Symposium on High Performance Computer Architecture (HPCA),",
            "year": 2017
        },
        {
            "authors": [
                "Xupeng Miao",
                "Gabriele Oliaro",
                "Zhihao Zhang",
                "Xinhao Cheng",
                "Zeyu Wang",
                "Rae Ying Yee Wong",
                "Zhuoming Chen",
                "Daiyaan Arfeen",
                "Reyna Abhyankar",
                "Zhihao Jia"
            ],
            "title": "Specinfer: Accelerating generative llm serving with speculative inference and token tree verification",
            "venue": "arXiv preprint arXiv:2305.09781,",
            "year": 2023
        },
        {
            "authors": [
                "Asit Mishra",
                "Jorge Albericio Latorre",
                "Jeff Pool",
                "Darko Stosic",
                "Dusan Stosic",
                "Ganesh Venkatesh",
                "Chong Yu",
                "Paulius Micikevicius"
            ],
            "title": "Accelerating sparse deep neural networks",
            "venue": "arXiv preprint arXiv:2104.08378,",
            "year": 2021
        },
        {
            "authors": [
                "Deepak Narayanan",
                "Aaron Harlap",
                "Amar Phanishayee",
                "Vivek Seshadri",
                "Nikhil R Devanur",
                "Gregory R Ganger",
                "Phillip B Gibbons",
                "Matei Zaharia"
            ],
            "title": "Pipedream: Generalized pipeline parallelism for dnn training",
            "venue": "In Proceedings of the 27th ACM Symposium on Operating Systems Principles,",
            "year": 2019
        },
        {
            "authors": [
                "Deepak Narayanan",
                "Amar Phanishayee",
                "Kaiyu Shi",
                "Xie Chen",
                "Matei Zaharia"
            ],
            "title": "Memory-efficient pipeline-parallel dnn training",
            "venue": "In International Conference on Machine Learning,",
            "year": 2021
        },
        {
            "authors": [
                "Long Ouyang",
                "Jeffrey Wu",
                "Xu Jiang",
                "Diogo Almeida",
                "Carroll Wainwright",
                "Pamela Mishkin",
                "Chong Zhang",
                "Sandhini Agarwal",
                "Katarina Slama",
                "Alex Ray"
            ],
            "title": "Training language models to follow instructions with human feedback",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Duy Phung"
            ],
            "title": "Stablevicuna-13b, May 2023",
            "venue": "URL https://huggingface.co/CarperAI/ stable-vicuna-13b-delta",
            "year": 2023
        },
        {
            "authors": [
                "Ofir Press",
                "Muru Zhang",
                "Sewon Min",
                "Ludwig Schmidt",
                "Noah A Smith",
                "Mike Lewis"
            ],
            "title": "Measuring and narrowing the compositionality gap in language models",
            "venue": "arXiv preprint arXiv:2210.03350,",
            "year": 2022
        },
        {
            "authors": [
                "Ratish Puduppully",
                "Li Dong",
                "Mirella Lapata"
            ],
            "title": "Data-to-text generation with content selection and planning",
            "venue": "In Proceedings of the AAAI conference on artificial intelligence,",
            "year": 2019
        },
        {
            "authors": [
                "Samyam Rajbhandari",
                "Jeff Rasley",
                "Olatunji Ruwase",
                "Yuxiong He"
            ],
            "title": "Zero: Memory optimizations toward training trillion parameter models",
            "venue": "In SC20: International Conference for High Performance Computing, Networking, Storage and Analysis,",
            "year": 2020
        },
        {
            "authors": [
                "Jie Ren",
                "Samyam Rajbhandari",
                "Reza Yazdani Aminabadi",
                "Olatunji Ruwase",
                "Shuangyan Yang",
                "Minjia Zhang",
                "Dong Li",
                "Yuxiong He"
            ],
            "title": "ZeRO-Offload}: Democratizing {Billion-Scale} model training",
            "venue": "USENIX Annual Technical Conference (USENIX ATC 21),",
            "year": 2021
        },
        {
            "authors": [
                "Andrea Santilli",
                "Silvio Severino",
                "Emilian Postolache",
                "Valentino Maiorca",
                "Michele Mancusi",
                "Riccardo Marin",
                "Emanuele Rodol\u00e0"
            ],
            "title": "Accelerating transformer inference for translation via parallel decoding",
            "venue": "acl,",
            "year": 2023
        },
        {
            "authors": [
                "Timo Schick",
                "Jane Dwivedi-Yu",
                "Roberto Dess\u0131",
                "Roberta Raileanu",
                "Maria Lomeli",
                "Luke Zettlemoyer",
                "Nicola Cancedda",
                "Thomas Scialom"
            ],
            "title": "Toolformer: Language models can teach themselves to use tools",
            "venue": "arXiv preprint arXiv:2302.04761,",
            "year": 2023
        },
        {
            "authors": [
                "Zhihong Shao",
                "Minlie Huang",
                "Jiangtao Wen",
                "Wenfei Xu",
                "Xiaoyan Zhu"
            ],
            "title": "Long and diverse text generation with planning-based hierarchical variational model",
            "year": 1908
        },
        {
            "authors": [
                "Noam Shazeer"
            ],
            "title": "Fast transformer decoding: One write-head is all you need",
            "venue": "arXiv preprint arXiv:1911.02150,",
            "year": 2019
        },
        {
            "authors": [
                "Yongliang Shen",
                "Kaitao Song",
                "Xu Tan",
                "Dongsheng Li",
                "Weiming Lu",
                "Yueting Zhuang"
            ],
            "title": "Hugginggpt: Solving ai tasks with chatgpt and its friends in huggingface",
            "venue": "arXiv preprint arXiv:2303.17580,",
            "year": 2023
        },
        {
            "authors": [
                "Ying Sheng",
                "Lianmin Zheng",
                "Binhang Yuan",
                "Zhuohan Li",
                "Max Ryabinin",
                "Daniel Y Fu",
                "Zhiqiang Xie",
                "Beidi Chen",
                "Clark Barrett",
                "Joseph E Gonzalez"
            ],
            "title": "High-throughput generative inference of large language models with a single gpu",
            "venue": "arXiv preprint arXiv:2303.06865,",
            "year": 2023
        },
        {
            "authors": [
                "Taylor Shin",
                "Yasaman Razeghi",
                "Robert L Logan IV",
                "Eric Wallace",
                "Sameer Singh"
            ],
            "title": "Autoprompt: Eliciting knowledge from language models with automatically generated prompts",
            "venue": "In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP),",
            "year": 2020
        },
        {
            "authors": [
                "Mitchell Stern",
                "Noam Shazeer",
                "Jakob Uszkoreit"
            ],
            "title": "Blockwise parallel decoding for deep autoregressive models",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2018
        },
        {
            "authors": [
                "Ziteng Sun",
                "Ananda Theertha Suresh",
                "Jae Hun Ro",
                "Ahmad Beirami",
                "Himanshu Jain",
                "Felix Yu",
                "Michael Riley",
                "Sanjiv Kumar"
            ],
            "title": "Spectr: Fast speculative decoding via optimal transport",
            "venue": "In Workshop on Efficient Systems for Foundation Models @ ICML2023,",
            "year": 2023
        },
        {
            "authors": [
                "Christian Szegedy",
                "Vincent Vanhoucke",
                "Sergey Ioffe",
                "Jon Shlens",
                "Zbigniew Wojna"
            ],
            "title": "Rethinking the inception architecture for computer vision",
            "venue": "In Proceedings of the IEEE conference on computer vision and pattern recognition,",
            "year": 2016
        },
        {
            "authors": [
                "Rohan Taori",
                "Ishaan Gulrajani",
                "Tianyi Zhang",
                "Yann Dubois",
                "Xuechen Li",
                "Carlos Guestrin",
                "Percy Liang",
                "Tatsunori Hashimoto"
            ],
            "title": "Alpaca: A strong, replicable instruction-following model",
            "venue": "https://crfm.stanford.edu/2023/03/13/alpaca.html,",
            "year": 2023
        },
        {
            "authors": [
                "Hugo Touvron",
                "Thibaut Lavril",
                "Gautier Izacard",
                "Xavier Martinet",
                "Marie-Anne Lachaux",
                "Timoth\u00e9e Lacroix",
                "Baptiste Rozi\u00e8re",
                "Naman Goyal",
                "Eric Hambro",
                "Faisal Azhar"
            ],
            "title": "Llama: Open and efficient foundation language models",
            "venue": "arXiv preprint arXiv:2302.13971,",
            "year": 2023
        },
        {
            "authors": [
                "Alan Schelten",
                "Ruan Silva",
                "Eric Michael Smith",
                "Ranjan Subramanian",
                "Xiaoqing Ellen Tan",
                "Binh Tang",
                "Ross Taylor",
                "Adina Williams",
                "Jian Xiang Kuan",
                "Puxin Xu",
                "Zheng Yan",
                "Iliyan Zarov",
                "Yuchen Zhang",
                "Angela Fan",
                "Melanie Kambadur",
                "Sharan Narang",
                "Aurelien Rodriguez",
                "Robert Stojnic",
                "Sergey Edunov",
                "Thomas Scialom"
            ],
            "title": "Llama 2: Open foundation and fine-tuned chat models, 2023b",
            "year": 2023
        },
        {
            "authors": [
                "Guan Wang",
                "Sijie Cheng",
                "Qiying Yu",
                "Changling Liu"
            ],
            "title": "Openllms: Less is more for open-source models, July 2023a. URL https://github.com/imoneoi/openchat",
            "year": 2023
        },
        {
            "authors": [
                "Hanrui Wang",
                "Zhekai Zhang",
                "Song Han"
            ],
            "title": "Spatten: Efficient sparse attention architecture with cascade token and head pruning",
            "venue": "IEEE International Symposium on High-Performance Computer Architecture (HPCA),",
            "year": 2021
        },
        {
            "authors": [
                "Sinong Wang",
                "Belinda Z Li",
                "Madian Khabsa",
                "Han Fang",
                "Hao Ma"
            ],
            "title": "Linformer: Self-attention with linear complexity",
            "venue": "arXiv preprint arXiv:2006.04768,",
            "year": 2020
        },
        {
            "authors": [
                "Xuezhi Wang",
                "Jason Wei",
                "Dale Schuurmans",
                "Quoc Le",
                "Ed Chi",
                "Sharan Narang",
                "Aakanksha Chowdhery",
                "Denny Zhou"
            ],
            "title": "Self-consistency improves chain of thought reasoning in language models",
            "venue": "arXiv preprint arXiv:2203.11171,",
            "year": 2022
        },
        {
            "authors": [
                "Zifu Wang",
                "Teodora Popordanoska",
                "Jeroen Bertels",
                "Robin Lemmens",
                "Matthew B Blaschko"
            ],
            "title": "Dice semimetric losses: Optimizing the dice score with soft labels",
            "venue": "In Medical Image Computing and Computer Assisted Intervention,",
            "year": 2023
        },
        {
            "authors": [
                "Jason Wei",
                "Maarten Bosma",
                "Vincent Y Zhao",
                "Kelvin Guu",
                "Adams Wei Yu",
                "Brian Lester",
                "Nan Du",
                "Andrew M Dai",
                "Quoc V Le"
            ],
            "title": "Finetuned language models are zero-shot learners",
            "venue": "arXiv preprint arXiv:2109.01652,",
            "year": 2021
        },
        {
            "authors": [
                "Jason Wei",
                "Xuezhi Wang",
                "Dale Schuurmans",
                "Maarten Bosma",
                "Fei Xia",
                "Ed Chi",
                "Quoc V Le",
                "Denny Zhou"
            ],
            "title": "Chain-of-thought prompting elicits reasoning in large language models",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Wei Wen",
                "Chunpeng Wu",
                "Yandan Wang",
                "Yiran Chen",
                "Hai Li"
            ],
            "title": "Learning structured sparsity in deep neural networks",
            "venue": "Advances in neural information processing systems,",
            "year": 2016
        },
        {
            "authors": [
                "Guangxuan Xiao",
                "Ji Lin",
                "Mickael Seznec",
                "Julien Demouth",
                "Song Han"
            ],
            "title": "Smoothquant: Accurate and efficient post-training quantization for large language models",
            "venue": "arXiv preprint arXiv:2211.10438,",
            "year": 2022
        },
        {
            "authors": [
                "Yisheng Xiao",
                "Lijun Wu",
                "Junliang Guo",
                "Juntao Li",
                "Min Zhang",
                "Tao Qin",
                "Tie-yan Liu"
            ],
            "title": "A survey on non-autoregressive generation for neural machine translation and beyond",
            "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,",
            "year": 2023
        },
        {
            "authors": [
                "Can Xu",
                "Qingfeng Sun",
                "Kai Zheng",
                "Xiubo Geng",
                "Pu Zhao",
                "Jiazhan Feng",
                "Chongyang Tao",
                "Daxin Jiang"
            ],
            "title": "Wizardlm: Empowering large language models to follow complex instructions",
            "venue": "arXiv preprint arXiv:2304.12244,",
            "year": 2023
        },
        {
            "authors": [
                "Yuanzhong Xu",
                "HyoukJoong Lee",
                "Dehao Chen",
                "Blake Hechtman",
                "Yanping Huang",
                "Rahul Joshi",
                "Maxim Krikun",
                "Dmitry Lepikhin",
                "Andy Ly",
                "Marcello Maggioni"
            ],
            "title": "Gspmd: general and scalable parallelization for ml computation graphs",
            "venue": "arXiv preprint arXiv:2105.04663,",
            "year": 2021
        },
        {
            "authors": [
                "Shunyu Yao",
                "Jeffrey Zhao",
                "Dian Yu",
                "Nan Du",
                "Izhak Shafran",
                "Karthik Narasimhan",
                "Yuan Cao"
            ],
            "title": "React: Synergizing reasoning and acting in language models",
            "venue": "arXiv preprint arXiv:2210.03629,",
            "year": 2022
        },
        {
            "authors": [
                "Shunyu Yao",
                "Dian Yu",
                "Jeffrey Zhao",
                "Izhak Shafran",
                "Thomas L Griffiths",
                "Yuan Cao",
                "Karthik Narasimhan"
            ],
            "title": "Tree of thoughts: Deliberate problem solving with large language models",
            "venue": "arXiv preprint arXiv:2305.10601,",
            "year": 2023
        },
        {
            "authors": [
                "Gyeong-In Yu",
                "Joo Seong Jeong",
                "Geon-Woo Kim",
                "Soojeong Kim",
                "Byung-Gon Chun"
            ],
            "title": "Orca: A distributed serving system for {Transformer-Based} generative models",
            "venue": "In 16th USENIX Symposium on Operating Systems Design and Implementation",
            "year": 2022
        },
        {
            "authors": [
                "Manzil Zaheer",
                "Guru Guruganesh",
                "Kumar Avinava Dubey",
                "Joshua Ainslie",
                "Chris Alberti",
                "Santiago Ontanon",
                "Philip Pham",
                "Anirudh Ravula",
                "Qifan Wang",
                "Li Yang"
            ],
            "title": "Big bird: Transformers for longer sequences",
            "venue": "Advances in neural information processing systems,",
            "year": 2020
        },
        {
            "authors": [
                "Eric Zelikman",
                "Yuhuai Wu",
                "Jesse Mu",
                "Noah Goodman"
            ],
            "title": "Star: Bootstrapping reasoning with reasoning",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Daochen Zha",
                "Zaid Pervaiz Bhat",
                "Kwei-Herng Lai",
                "Fan Yang",
                "Zhimeng Jiang",
                "Shaochen Zhong",
                "Xia Hu"
            ],
            "title": "Data-centric artificial intelligence: A survey",
            "venue": "arXiv preprint arXiv:2303.10158,",
            "year": 2023
        },
        {
            "authors": [
                "Yujia Zhai",
                "Chengquan Jiang",
                "Leyuan Wang",
                "Xiaoying Jia",
                "Shang Zhang",
                "Zizhong Chen",
                "Xin Liu",
                "Yibo Zhu"
            ],
            "title": "Bytetransformer: A high-performance transformer boosted for variable-length inputs",
            "venue": "arXiv preprint arXiv:2210.03052,",
            "year": 2022
        },
        {
            "authors": [
                "Yifan Zhang",
                "Jingqin Yang",
                "Yang Yuan",
                "Andrew Chi-Chih Yao"
            ],
            "title": "Cumulative reasoning with large language models",
            "venue": "arXiv preprint arXiv:2308.04371,",
            "year": 2023
        },
        {
            "authors": [
                "Lianmin Zheng",
                "Zhuohan Li",
                "Hao Zhang",
                "Yonghao Zhuang",
                "Zhifeng Chen",
                "Yanping Huang",
                "Yida Wang",
                "Yuanzhong Xu",
                "Danyang Zhuo",
                "Eric P Xing"
            ],
            "title": "Alpa: Automating inter-and {IntraOperator} parallelism for distributed deep learning",
            "venue": "In 16th USENIX Symposium on Operating Systems Design and Implementation",
            "year": 2022
        },
        {
            "authors": [
                "Lianmin Zheng",
                "Wei-Lin Chiang",
                "Ying Sheng",
                "Siyuan Zhuang",
                "Zhanghao Wu",
                "Yonghao Zhuang",
                "Zi Lin",
                "Zhuohan Li",
                "Dacheng Li",
                "Eric. P Xing",
                "Hao Zhang",
                "Joseph E. Gonzalez",
                "Ion Stoica"
            ],
            "title": "Judging llm-as-a-judge with mt-bench and chatbot arena, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Chunting Zhou",
                "Pengfei Liu",
                "Puxin Xu",
                "Srini Iyer",
                "Jiao Sun",
                "Yuning Mao",
                "Xuezhe Ma",
                "Avia Efrat",
                "Ping Yu",
                "Lili Yu"
            ],
            "title": "Lima: Less is more for alignment",
            "venue": "USENIX Annual Technical Conference (USENIX ATC 22),",
            "year": 2022
        },
        {
            "authors": [
                "Xizhou Zhu",
                "Yuntao Chen",
                "Hao Tian",
                "Chenxin Tao",
                "Weijie Su",
                "Chenyu Yang",
                "Gao Huang",
                "Bin Li",
                "Lewei Lu",
                "Xiaogang Wang"
            ],
            "title": "Ghost in the minecraft: Generally capable agents for open-world enviroments via large language models with text-based knowledge and memory",
            "venue": "arXiv preprint arXiv:2305.17144,",
            "year": 2023
        },
        {
            "authors": [
                "Barret Zoph",
                "Quoc V. Le"
            ],
            "title": "Neural architecture search with reinforcement learning",
            "venue": "In International Conference on Learning Representations (ICLR),",
            "year": 2017
        },
        {
            "authors": [
                "example",
                "Vicuna (Chiang"
            ],
            "title": "2023) uses the string \u201cUSER:",
            "year": 2023
        },
        {
            "authors": [
                "Fedus"
            ],
            "title": "2022), (2) address the quadratic complexity w.r.t. input size of attention by designing new attention mechanisms (Kitaev et al., 2020; Wang et al., 2020), (3) reduce the memory access and footprint of attention by using multi-query attention (Shazeer, 2019), and so on. However, these methods usually require a substantial re-training cost. The model compression techniques require a smaller amount of fine-tuning by reducing the model complexity of a pre-trained LLM",
            "year": 2019
        },
        {
            "authors": [
                "Han et al",
                "Wen"
            ],
            "title": "2016), quantization (Krishnamoorthi, 2018), factorization (Denton et al., 2014), and neural architecture search (Zoph & Le, 2017",
            "venue": "Elsken et al.,",
            "year": 2019
        },
        {
            "authors": [
                "Miao"
            ],
            "title": "2023) propose to use cheaper approaches to generate short candidate token sequences, for example, by sequentially decoding with an assisting model much smaller than the given LLM. Then, they use the LLM to parallelly verify the candidates and keep the prefix sequence that matches the LLM\u2019s verification results. Another line of work that shares the motivation of addressing the autoregressive efficiency issue",
            "year": 2023
        },
        {
            "authors": [
                "Liang",
                "Lester"
            ],
            "title": "2021) the prompts for uncovering the capabilities of LLMs on downstream tasks. There are a bunch of prompting methods that improves the reasoning performance of LLMs by designing thinking flows mimicking human reasoning: (1) mimicking the step-by-step or compositional thinking structure (Wei et al., 2022",
            "venue": "Kojima et al.,",
            "year": 2022
        },
        {
            "authors": [
                "Yao et al",
                "Li"
            ],
            "title": "2023c), and (3) using tools for calculation and information retrieval (Chen et al., 2022",
            "venue": "Schick et al.,",
            "year": 2023
        },
        {
            "authors": [
                "2020 Shin et al",
                "Li",
                "2021 Liang",
                "2021 Lester et al",
                "Jiang"
            ],
            "title": "2023), the possibility of using much shorter prompts to activate the SoT mode in the future holds promise, which would significantly mitigate the token or computational overhead. Table 7: SoT\u2019s computational overhead (in terms of the number of prefilling tokens) for open-source models",
            "year": 2023
        },
        {
            "authors": [
                "Chain-of-Thoughts (Kojima et al",
                "Wei"
            ],
            "title": "2022) emphasize the importance of expanding the sequential thinking steps to solve these problems successfully. In contrast, SoT requires the models to (a) come up with the skeleton of the solution first and (b) deduce each individual step independently without referring to previous results",
            "year": 2022
        },
        {
            "authors": [
                "Cool jazz"
            ],
            "title": "Emerging in the late 1940s and early 1950s, cool jazz was a more subdued, mellow style that broke",
            "year": 1950
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "Large language models (LLMs) (Brown et al., 2020; Touvron et al., 2023a; Du et al., 2022; OpenAI, 2023; Zheng et al., 2023) have shown exceptional performance in natural language processing and chatbot systems. However, the inference process of the state-of-the-art LLMs is slow, hindering their interactive use. For example, it takes 22 seconds for Claude (Anthropic, 2023) (accessed through Slack API) and 43 seconds for Vicuna-33B V1.3 (a 33B LLaMA-based model, running locally on one NVIDIA A100 GPU) to answer the question in Fig. 1.\nWe conclude three major causes of LLMs\u2019 slow inference: (1) A large model size requires a large amount of memory, memory access, and computation. For example, the FP16 weights of 175B GPT3 take 350GB memory, which means at least 5\u00d780GB A100 GPUs are needed to keep the model in GPU memory. Even with enough GPUs, the heavy memory access and computation slow down the inference. (2) The attention operation in the prevailing transformer architecture is I/O bounded and has a quadratic memory and computation complexity in sequence length. (3) The sequential decoding approach in inference generates tokens one by one. This approach introduces a significant inference latency since the generation of tokens cannot be parallelized. There is a bunch of literature addressing the first two axes: large model size (Xiao et al., 2022; Frantar et al., 2022; Lin et al., 2023; Sheng et al., 2023; Wang et al., 2021) and attention operation (Kitaev et al., 2020; Wang et al., 2020;\n\u2217Equal contribution.\nDao et al., 2022; Zaheer et al., 2020; Chen et al., 2023b). These works either compress/redesign the model (Xiao et al., 2022; Frantar et al., 2022; Lin et al., 2023; Kitaev et al., 2020; Wang et al., 2020; Dao et al., 2022; Zaheer et al., 2020) or redesign the serving system (Sheng et al., 2023; Chen et al., 2023b) and hardware (Wang et al., 2021).\nIn contrast to prior work, we tackle the third axis and question the common assumption that LLMs have to do fully sequential decoding. We show the feasibility of parallel decoding of off-the-shelf LLMs without any changes to their model, system, or hardware. For instance, for the question in Fig. 1, we can reduce the latency from 22 seconds to 12 seconds (1.83\u00d7 speed-up) with Claude, and from 43 seconds to 16 seconds (2.69\u00d7 speed-up) with Vicuna-33B V1.3 on an NVIDIA A100. The idea stems from reflecting on how humans ourselves answer questions. Humans do not always think about questions and write answers in a sequential fashion. In contrast, for many question types, we first derive the skeleton according to some protocols and strategies, and then add evidence and details to explain each point. This is especially the case on occasions like offering consultancy, taking tests, writing papers, and so on. This intuition has our back to question the necessity of fully sequential decoding. In this paper, we propose Skeleton-of-Thought (SoT). Specifically, as shown in Fig. 1, we guide the LLM to derive a skeleton first by itself. Based on the skeleton, the LLMs can complete each point in parallel so that we get a speed-up. SoT can be utilized to accelerate both open-source models with batched decoding and API-based models with parallel API calls.\nThe current SoT is suitable for questions that require a long answer whose structure can be planned ahead, while not suitable for questions that require step-by-step reasoning or only need a short answer. Therefore, to make the overall solution more practical, we design an extension, SoT with router (SoT-R), which employs a router to only trigger SoT for suitable questions.\nWe test SoT on 12 recently released LLMs. Not only does SoT provide considerable speed-ups (up to 2.39\u00d7), but it can also improve the answer quality in many cases (Fig. 1). Note that in contrast to existing model- and system-level efforts for inference efficiency, SoT takes a novel \u201cdata-level\u201d pathway by letting the LLM organize its output content. This novel perspective is becoming feasible and is expected to grow in importance, owing to the evolving capabilities of state-of-the-art LLMs. We hope this work can stimulate more research in the realm of data-centric optimization (Zha et al., 2023; HazyResearch, 2023) for efficiency.\nPrompt 1. Skeleton Prompt Template T s\n[User:] You\u2019re an organizer responsible for only giving the skeleton (not the full content) for answering the question. Provide the skeleton in a list of points (numbered 1., 2., 3., etc.) to answer the question. Instead of writing a full sentence, each skeleton point should be very short with only 3\u223c5 words. Generally, the skeleton should have 3\u223c10 points. Now, please provide the skeleton for the following question. {question} Skeleton: [Assistant:] 1.\nPrompt 2. Point-Expanding Prompt Template T pe\n[User:] You\u2019re responsible for continuing the writing of one and only one point in the overall answer to the following question.\n{question}\nThe skeleton of the answer is\n{skeleton}\nContinue and only continue the writing of point {point index}. Write it **very shortly** in 1\u223c2 sentence and do not continue with other points! [Assistant:] {point index}. {point skeleton}\nThe rest of the paper is organized as follows. We first introduce SoT in \u00a7 2 and show its results in \u00a7 3. Then, we expand on the SoT-R extension in \u00a7 4. \u00a7 5 positions SoT in the research ecosystem (expanded in App. D). Finally, we analyze the limitations and share outlooks of SoT in \u00a7 6."
        },
        {
            "heading": "2 SKELETON-OF-THOUGHT (SOT)",
            "text": ""
        },
        {
            "heading": "2.1 METHOD",
            "text": "Overview. Based on the intuition that humans usually think about and answer a question in an organized way, the core idea of this work is to guide the LLM itself to give a skeleton first and then write the overall answer parallelly instead of sequentially. Fig. 1 illustrates how SoT produces the final answer to a user question q.\n(1) Skeleton stage. SoT first assembles a skeleton request, T s(question = q), using the skeleton prompt template T s (Prompt 1, and Prompt 3 in App. B.1) with the question q as the parameter. The skeleton prompt template is written to guide the LLM to output a concise skeleton of the answer. Then, we extract the B points from the skeleton response Rs of the LLM.\n(2) Point-expanding stage. Based on the skeleton, we let the LLM expand on each point in parallel. Specifically, for the point with index b and skeleton Rsb , SoT uses T\npe(question = q, skeleton = Rs, point index = b, point skeleton = Rsb) as the point-expanding request for the LLM, where T pe is the point-expanding prompt template (Prompt 2). Finally, after completing all points, we concatenate the point-expanding responses {Rpeb }b=1,\u00b7\u00b7\u00b7 ,B to get the final answer. Parallel point expanding. We conduct parallel point-expanding so that SoT is able to achieve a speed-up than normal decoding.\n(1) For proprietary models with only API access, we can issue multiple parallel API calls to get an end-to-end latency gain at the cost of an increased number of API requests and tokens.\n(2) For open-source models that we can run locally, we let them process the point-expanding requests as a batch (paddings are added to the left of the point-expanding requests). We explain below why this could achieve speed-ups. A typical LLM generative process consists of two phases: (a) the prefilling phase in which the prompt is parsed to generate the key-value cache for further use, and (b) the decoding phase in which tokens are generated one by one in a sequential manner. The decoding phase accounts for the majority of the end-to-end latency, especially when generating a long response. Note that the decoding phase is bottlenecked by weight loading instead of activation\nloading or computation.1 Consequently, running LLM inference with increased batch sizes does not increase the per-token latency much. Therefore, SoT allows us to decode roughly B\u00d7 more tokens within the same amount of time if we parallelly decode B points. See App. E for the expanded discussions and the supporting experiments. Please refer to App. B for more implementation details."
        },
        {
            "heading": "3 SOT EVALUATION",
            "text": "Datasets. We evaluate SoT on two recent assistant-style datasets: (1) Vicuna-80 (Chiang et al., 2023), which contains 80 questions spanning nine categories, such as coding, math, writing, roleplay, and so on, and (2) WizardLM (Xu et al., 2023), which contains 218 questions spanning more categories and diverse difficulties. Due to space constraints, we only report Vicuna-80 results in the main paper, and defer WizardLM results to the Apps. G and I.\nModels. We test SoT on 12 models, including 9 open-source models and 3 API-based models. We obtain the weights of all the open-source models from Hugging Face. See App. A for more details."
        },
        {
            "heading": "3.1 EVALUATION OF EFFICIENCY",
            "text": "API-based models. We record the latency of every API call with start = time.time(); ...; elapsed_time = time.time() - start, and add the latency of the skeleton API call and the slowest point-expanding API call as the SoT latency.\nOpen-source models. All open-source models we currently evaluate are based on the LLaMA 7B, 13B, or 33B architectures. Thus, to enable fast analysis, we first make a latency profiling table for each LLaMA architecture on NVIDIA A100. The table contains the architecture\u2019s (1) latency for prefilling sequences of length 1 to 700 with different batch sizes (from 1 to 16), and (2) decoding one token with a context of length 1 to 1024 with different batch sizes (from 1 to 16). With these three latency profiling tables, given the number of points B, the token lengths of the requests and responses in the skeleton and point-expanding stages, we can quickly estimate the SoT latency by simply looking up entries in the tables and adding them up. See App. F for a more detailed description of how we conduct the profiling and estimate the latency.\nIn addition to the above approach, we also compare the actual latency of SoT and normal sequential generation (abbreviated as \u201cnormal\u201d in the following discussion) in App. G.1.4.\nThe rest of this section shows the speed-ups of SoT on different models (\u00a7 3.1.1) and question categories (\u00a7 3.1.2). In addition, we also report the latency breakdown of SoT stages in App. G.1.2 and the SoT speed-ups on an RTX 3090 GPU in App. G.1.3."
        },
        {
            "heading": "3.1.1 SPEED-UP BREAKDOWN: MODELS",
            "text": "We investigate how SoT reduces the end-to-end latency on different models. Fig. 2a shows the average speed-up for each model across all question categories. We can see that SoT obtains a >2\u00d7 speed-up (up to 2.39\u00d7) on 8 out of 12 models. We report the detailed statistics about token lengths and numbers of points in Fig. 11. (1) In terms of the point number B (Fig. 11a), LLaMA2, Vicuna-7B V1.1, Vicuna-7B V1.3, and ChatGPT-3.5 yield relatively fewer points (<6), while GPT-4 and StableVicuna-13B generates the largest number of points on average (\u22489). (2) Regarding the point-expanding response length, Figs. 11b to 11d show that the API-based models, ChatGPT-3.5, Claude, and GPT-4, follow the point-expanding request better and generate shorter point-expanding responses than the open-source models. One can also notice that StableVicuna-13B\u2019s longest point-expanding responses for many question categories can be as lengthy as the overall normal answer, since it fails to adhere to the \u201cWrite it **very shortly**\u201d instruction in the point-expanding request. Consequently, SoT cannot accelerate StableVicuna-13B well. (3) Regarding the length balance degree between point responses, Fig. 11e shows that LLaMA2 and the API-based models generate more balanced point-expanding responses. (4) As for the overall length of the final aggregated answer (Fig. 11f), employing SoT on most models results in answers that are, on average, 1\u223c2\u00d7 longer than the normal answer.\n1This is true when the number of concurrent queries is small; see \u00a7 6 for discussion on other scenarios."
        },
        {
            "heading": "3.1.2 SPEED-UP BREAKDOWN: QUESTION CATEGORIES",
            "text": "Here we investigate how SoT reduces the end-to-end latency for different question categories. Fig. 2b shows the average speed-up for each question category across all models. The question categories for which SoT can provide high-quality answers are marked in green, and other categories are marked in red (see \u00a7 3.2.3 for the answer quality evaluation). We can see that SoT can obtain speed-ups for all question categories. For the five question categories that SoT can provide high-quality answers (i.e., knowledge, generic, common-sense, roleplay, counterfactual), SoT can speed up the overall answer generation process by 1.89\u00d7 to 2.33\u00d7 in the meantime."
        },
        {
            "heading": "3.2 EVALUATION OF ANSWER QUALITY",
            "text": "In order to compare the answer quality of the normal sequential generation (abbreviated as \u201cnormal\u201d in the following discussion) and SoT generation, we adopt two LLM-based evaluation frameworks: FastChat (Zheng et al., 2023) and LLMZoo (Chen et al., 2023c). The evaluation process is to present a question and a pair of answers (from normal or SoT generation) to an LLM judge (GPT-4 in the main paper; see App. I.4 for the results evaluated using ChatGPT-3.5) and ask for its preference.\nHere are more details about the evaluation of the answer quality:\n(1) Detailed metrics. FastChat provides one metric for the general answer quality. In addition to a general metric, LLMZoo provides five detailed metrics on the answers\u2019 coherence, diversity, immersion, integrity, and relevance.\n(2) Question categories. FastChat provides two special evaluation prompts for coding and math questions for more accurate evaluation, whereas LLMZoo does not. Following the implementation in LLMZoo, we exclude math and coding questions in all LLMZoo evaluation results.\n(3) Extentions to avoid evaluation bias. To avoid the potential bias from the order of the two answers presented to the LLM judge, we extend FastChat and LLMZoo evaluation frameworks by running the evaluation twice with either ordering of the two answers. In either evaluation, a score of 1, 0, and -1 is assigned when SoT wins, ties, or loses, respectively. The final evaluation is that SoT wins/ties/loses when the sum of the two scores is positive/zero/negative. For example, if SoT wins in one evaluation and loses in the other evaluation, the result is \u201ctie\u201d. If SoT wins (loses) in one evaluation and ties in the other, the result is \u201cwin\u201d (\u201close\u201d).\n(4) Net win rates. We further define net win rates to give a summarized view of the answer quality. Given the number of questions that SoT wins (#win) and loses (#lose), we define net win rates as #win\u2212#lose/total number of questions. 0% means that SoT performs competitively to the normal baseline (wins and loses in the same number of questions). Higher values mean that SoT performs better.\nIn the following sections, we first present the overall quality of SoT answers (\u00a7 3.2.1), and then go into the details across different question categories (\u00a7 3.2.3), models (\u00a7 3.2.2), and metrics (\u00a7 3.2.4)."
        },
        {
            "heading": "3.2.1 OVERALL QUALITY",
            "text": "In Fig. 3, we show the win/tie/lose rates (the percentage of the cases when SoT wins/ties/loses compared to normal generation) across all models and questions using the two metrics from FastChat and LLMZoo that capture the general quality of the answers. We notice a discrepancy between the two metrics on when SoT is strictly better than the baseline (45.8% v.s. 29.5%). Despite that, the two metrics agree that SoT is not worse than the baseline in around 60% of the cases, and the win\nrates are close to the lose rates. This result suggests that the answers of SoT maintain good quality of that of the normal generation."
        },
        {
            "heading": "3.2.2 QUALITY BREAKDOWN: MODELS",
            "text": "We compute net win rates on all models in Fig. 4. Again, we see that the two general metrics from FastChat and LLMZoo have different absolute values but similar rankings. In particular, both metrics agree that OpenChat-13B, Vicuna-7B V1.1, Claude, LLaMA2-Chat-13B have low net win rates, whereas Vicuna-13B V1.3, StableVicuna-13B, and UltraLM-13B have high net win rates.\nWe investigate the answers in App. I.1.1, and summarize the key takeaways as follows. Some models have low SoT net win rates as they cannot understand the skeleton and point-expanding prompts well. Some other models have low SoT net win rates as their normal answers already have good quality, making it hard for SoT to beat them (e.g., Claude). For models that are able to understand the SoT prompts and the normal answers are not good enough, SoT can improve the answer quality. We expect that further improving SoT prompts or fine-tuning the models can make it easier for LLMs to understand the skeleton and point-expanding prompts and ultimately result in better answer quality."
        },
        {
            "heading": "3.2.3 QUALITY BREAKDOWN: QUESTION CATEGORIES",
            "text": "We compute net win rates on all question categories in Fig. 5. Similar to Fig. 3, we see that LLMZoo tends to be more optimistic about the quality of SoT than FastChat. Nevertheless, the conclusions are consistent: SoT performs relatively well on generic, common-sense, knowledge, roleplay, and counterfactual, and relatively poorly on writing, fermi, math, and coding.\nWe investigate the answers in App. I.1.2, and summarize the key takeaways as follows. SoT performs well when the question can be answered in several points whose details can be expanded independently. This includes a wide range of real-world questions. On the other hand, it is fundamentally challenging to apply SoT on questions that require step-by-step thinking, in which the latter steps require the details from the earlier steps, such as math questions. To make SoT general\nacross broader question categories, one promising pathway is to enable SoT to adaptively fall back to normal generation, which we explore in \u00a7 4. Interestingly, our results suggest that some LLMs are already able to do that occasionally without special prompting or tuning (see App. I.1.2)."
        },
        {
            "heading": "3.2.4 QUALITY BREAKDOWN: METRICS",
            "text": "In Fig. 6, we show more detailed metrics from LLMZoo to reveal in which aspects SoT can improve or hurt the answer quality. On average, we can see that SoT improves the diversity and relevance while hurting the immersion and coherence.\nThrough answer investigation (App. I.1.3), we summarize the key takeaways as follows. The skeleton stage of SoT explicitly require LLMs to discuss the answers from multiple aspects without filler words. This improves the diversity and relevance of the answers. As for coherence and immersion, SoT is not worse than the normal generation around 60% of the time. One future direction is to improve the SoT prompts or pipeline so that the answers can be better in more metrics."
        },
        {
            "heading": "4 SOT WITH ROUTER (SOT-R): ADAPATIVELY TRIGGERING SOT",
            "text": "In \u00a7 3, we see that SoT provides considerable speed-ups while maintaining (or even improving) answer quality for many question types. However, the biggest limitation is that SoT is not suitable for questions that require step-by-step reasoning (\u00a7 3.2.3). Towards pushing the practical adoption of SoT, we explore the possibility of adaptively triggering SoT only when it is suitable. To achieve that, we propose a router module that decides if SoT should be applied for the user request, and then call either SoT or normal decoding accordingly. This paradigm aligns with the recent trends of composing multiple models to solve complicated tasks (Chase, 2022; Shen et al., 2023). To implement the router, we explore two options: LLM prompting as the router (no model training is needed) (\u00a7 4.1), and trained RoBERTa as the router (\u00a7 4.2). The evaluation is provided in \u00a7 4.3."
        },
        {
            "heading": "4.1 PROMPTING ROUTER",
            "text": "We directly ask an LLM if the question is suitable for SoT. More specifically, we ask the LLM if the desired answer is in a list of independent points (see App. C.1 for the prompt). If the answer is yes, we will use SoT; otherwise, we will use normal generation (i.e., directly feeding the question to the LLM). We employ GPT-4 as the LLM router given its strong capability."
        },
        {
            "heading": "4.2 TRAINED ROUTER",
            "text": "While leveraging GPT-4 as the router obviates the need for model training, its performance remains sensitive to prompt design. Therefore, we approach the problem as a sequence classification task by fine-tuning a small language model as the router. Specifically, we annotate the LIMA dataset (Zhou et al., 2023) as the training set to train a RoBERTa model (Liu et al., 2019), which has only 120M parameters. Details about the annotation and training can be found in Apps. C.2.1 and C.2.2."
        },
        {
            "heading": "4.3 SOT-R EVALUATION",
            "text": "We compare SoT and SoT-R under the same evaluation setup in \u00a7 3. Besides the prompting and trained routers, we also consider a \u201chuman router\u201d where we manually judge whether SoT should be applied for each question. This serves as a benchmark for comparison."
        },
        {
            "heading": "4.3.1 EVALUATION OF EFFICIENCY",
            "text": "Fig. 7 shows the speed-ups of SoT and SoT-R for different models on Vicuna-80 (see App. G.2 for results on the WizardLM dataset). We can see that: (1) As expected, SoT-R obtains lower speedups than SoT, since SoT is not triggered for some questions and the router induces a small latency overhead. Nevertheless, SoT-R can still benefit most models with >1\u00d7 speed-ups. (2) SoT-R with the trained router obtains slightly higher speed-ups for 7 out of 12 models on Vicuna-80, while SoT-R with the prompting router obtains higher speed-ups for all models on WizardLM (Fig. 17).\n1.0 1.5 2.0 2.5 3.0 3.5 4.0 StableVicuna-13B\nClaude Vicuna-13B V1.3\nChatGPT-3.5 GPT-4\nVicuna-7B V1.3 UltraLM-13B\nVicuna-33B V1.3 OpenChat-13B Vicuna-7B V1.1\nLLaMA2-Chat-13B LLaMA2-Chat-7B\nSoT (w/o router) SoT-R w/ prompting router SoT-R w/ trained router\nFigure 7: Speed-ups of SoT and SoT-R on different models across all question categories of the Vicuna-80 dataset. -80% -60% -40% -20% 0% 20% 40%\ncounterfactual\ngeneric common-sense\nknowledge roleplay\nfermi writing\nmath coding\nSoT (w/o router) SoT-R w/ prompting router SoT-R w/ trained router SoT-R w/ human router\nFigure 8: Net win rates of SoT and SoT-R on different question categories of the Vicuna-80 dataset (evaluated with the FastChat metrics)."
        },
        {
            "heading": "4.3.2 EVALUATION OF ANSWER QUALITY",
            "text": "Fig. 8 shows the net win rates (averaged across all models) of SoT and SoT-R on Vicuna-80 with the FastChat metrics (see App. I.2 for results of the WizardLM dataset and LLMZoo metrics). We can see that: (1) SoT-R significantly improves the answer quality on questions where SoT is not suitable (e.g., coding, math, writing, fermi) by falling back to normal decoding. At the same time, SoT-R maintains answer quality improvements on questions where SoT is good at. (2) The trained router performs similar to (on Vicuna-80) or better than (on WizardLM; see App. I.2) the prompting router. This accords with our intuition in \u00a7 4.2. (3) The prompting and trained routers could even surpass human router (e.g., on roleplay questions; see more examples on WizardLM in App. I.2).\nWe discuss the consistency across three routers in App. C.3. The primary takeaways include: (1) on Vicuna-80, there is a notable consistency among all three routers, and (2) on WizardLM, greater discrepancies emerge, with the trained router showing higher alignment with human annotations."
        },
        {
            "heading": "5 SOT IN THE CONTEXT OF LITERATURE",
            "text": "This section positions SoT in related work to reveal how SoT (1) is connected to, (2) is different from, and (3) can harness the power of other methods. See App. D for the expanded discussion.\nEfficient LLM methods at model and system levels. At the model level, prior work proposes efficient architectures, including dynamic mixture-of-experts (Lepikhin et al., 2021), low-complexity attention (Kitaev et al., 2020), and multi-query attention (Shazeer, 2019). However, they usually require a significant re-training cost. In contrast, compression methods require a smaller amount of fine-tuning cost by reducing the complexity of pre-trained LLMs, such as quantization (Frantar et al., 2022) and weight or activation sparsification (Mishra et al., 2021; Zaheer et al., 2020).\nAt the system level, prior work (1) optimizes the computational graph (Dao et al., 2022), (2) optimizes the assignment and scheduling of computational graph on devices (Sheng et al., 2023), or (3) designs batching or caching mechanisms for serving multiple users (Fang et al., 2021). These techniques address the large memory access and footprint posed by the vast model scale and attention mechanism, and mainly aim at enhancing the throughput rather than the end-to-end latency. As SoT trades off throughput for end-to-end latency, SoT can make these throughput-oriented techniques help with end-to-end latency. This interesting synergy offers opportunities for achieving better trade-offs between latency and throughput in future serving systems."
        },
        {
            "heading": "In contrast to model- and system-level techniques, SoT is a data-level technique in a new \u201ccontent",
            "text": "co-organization for efficiency\u201d paradigm. See \u00a7 6 for more discussions.\nEfficient LLM methods through parallel generation. Some prior work also addresses the sequential decoding issues. Speculative decoding (SD) methods (Stern et al., 2018) employ smaller models to generate some consecutive tokens sequentially and apply the target LLMs to verify them parallelly. Non-autoregressive generation (NAG) methods (Gu et al., 2018; Xiao et al., 2023) sample and refine consecutive tokens parallelly, often with the support of a modified and tuned model.\nRelying on either assisting models or special models and sampling schemes, SD and NAG methods conduct parallel verification or sampling and refinement of consecutive tokens. In contrast, SoT prompts the LLM itself to plan the contents in a way that permits the parallel generation of tokens in different segments, by exploiting the emerging instruction-following and planning ability of LLMs.\nPrompting methods for LLMs. Recent years have witnessed the emergence of the \u201cpre-train, prompt, and predict\u201d paradigm, which has shown promise in enhancing LLMs\u2019 quality in math and commonsense reasoning (Wei et al., 2022; Kojima et al., 2022; Wang et al., 2022; Chen et al., 2022) and planning for multi-modality tasks (Shen et al., 2023; Zhu et al., 2023). Instead of focusing on answer quality, SoT is a first attempt at exploiting the power of prompting to improve efficiency."
        },
        {
            "heading": "6 LIMITATIONS, FUTURE WORK, AND OPEN QUESTIONS",
            "text": "Answer quality evaluation. Our answer quality evaluation is far from perfect due to the limited prompt set, the potential bias of GPT-4 judges, and the inherent difficulty of evaluating LLM generations. Currently, we did not conduct human evaluation since it is easy for a human to tell whether an answer is generated with SoT due to its distinctive pattern, which might cause evaluation bias.\nEliciting or improving LLMs\u2019 ability. \u00a7 3.2.4 demonstrates SoT\u2019s potential of enhancing answer quality. It is part of a broader trend in recent research, exemplified by work including CoT (Kojima et al., 2022; Wei et al., 2022), ToT (Yao et al., 2023), and ReAct (Yao et al., 2022), which collectively affirm the notion that explicitly articulating the thought process in language can elicit high-quality answers from LLMs. These findings resemble human thinking: rather than relying solely on the first intuition or purely sequential thinking, we often document step-by-step reasoning or thought organization to attain high-quality answers. This intriguing parallel prompts us to explore further how we can draw from the human thinking process to facilitate more effective and efficient AI.\nFor instance, SoT currently ignores the dependencies between points. A conceptually better way is to organize the points as Graph-of-Thoughts, where the edges represent the dependencies, and each point is decoded conditioned on the contents of its ancestor points. In addition, instead of complying with a static graph, we expect the need of having dynamic Graph-of-Thoughts, where the high-level thought structure is adjusted dynamically by LLMs themselves. This could potentially combine the efficiency and global thinking advantages of SoT with the logical reasoning and impromptu thinking strengths of methods like CoT (Kojima et al., 2022; Wei et al., 2022). Notably, a contemporary work (Besta et al., 2023) has attempted to design Graph-of-Thoughts to elicit reasoning. Furthermore, it is interesting to explore how the SoT answers can be used to fine-tune LLMs to generate more structured answers in a self-improving way (Zelikman et al., 2022; Huang et al., 2022).\nEfficiency and overhead of SoT in different scenarios. Serving systems commonly adopt batch processing to handle concurrent queries. This raises a concern of whether SoT may hurt serving throughput due to parallel requests. (1) When there is an unsaturated number of concurrent queries, SoT can effectively reduce latency and enhance GPU utilization. Example scenarios include (a) Edge-side applications with a single user; (b) Centralized services during periods with unsaturated user requests and underutilized computing capacity. It is interesting to study the appropriate SoT triggering conditions based on system workloads. (2) When there is a saturated number of concurrent queries, SoT is still useful for improving answer quality. However, in this case, it is important to consider the computation overhead from SoT. We delve into this concern in App. H.\nFor API-based models, a notable concern arises regarding the increased number of prefilling tokens (App. H). Given that many APIs charge token usage, SoT may lead to higher costs. To address this, one can use prompt tuning to design shorter SoT prompts (Jiang et al., 2023).\nData-centric efficiency optimization. While data-centric engineering for improving answer quality (Zha et al., 2023; HazyResearch, 2023) is gaining popularity, its potential for inference efficiency is not explored yet. SoT is the first attempt. As LLM capabilities and the amount of LLM-generated data are growing rapidly, data-centric techniques could become more useful in the future. To pave the way towards that, there are a lot to explore. For example, the acceleration ratio of SoT depends on the SoT prompt, the model, and the question, and thus not as predictable and controllable as model- or system-level techniques, which might hinder the practical adoption. We look forward to future work to unlock the full potential of data-centric efficiency optimization."
        },
        {
            "heading": "ACKNOWLEDGEMENTS",
            "text": "We thank Sergey Yekhanin (Microsoft Research), and Tianji Wu (Infinigence AI) for their support and suggestions on the work. This work is also supported by National Natural Science Foundation of China (No. 62325405, 62104128, U19B2019, U21B2031, 61832007, 62204164), Tsinghua EE Xilinx AI Research Fund, and Beijing National Research Center for Information Science and Technology (BNRist). We thank Tianyu Fu for many initial discussions on the idea. We thank Ke Hong and Genghan Zhang for their discussions about profiling. We thank Yue Wu for the help on the Claude scripts. We thank Da Yu, Chulin Xie, and Saiqian Zhang for their suggestions on revising the first version of the paper. We thank Rui Hu, Cheng Cheng, Jack Jin, Zhoutong Ye, Mingze Sun, Jun Yan, Zhi Zhang, Yuxuan Tong, Nianhui Guo, and Andrea Santilli for their suggestions on revising the second version of the paper. We thank Chris Stetkiewicz, Amanda Melfi, and Amber Tingle from Microsoft for their suggestions and help on writing. We thank the anonymous reviewers for their insightful questions and suggestions."
        },
        {
            "heading": "Appendix",
            "text": ""
        },
        {
            "heading": "Table of Contents",
            "text": ""
        },
        {
            "heading": "A Model Details 18",
            "text": "B Implementation Details of Skeleton-of-Thought 18 B.1 Prompt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 B.2 Supporting Multi-Round Conversation . . . . . . . . . . . . . . . . . . . . . . 20\nC Implementation Details of Skeleton-of-Thought with Router 20 C.1 Prompting Router . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 C.2 Trained Router . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 C.3 Router Consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 C.4 Concurrent execution for SoT-R . . . . . . . . . . . . . . . . . . . . . . . . . . 21"
        },
        {
            "heading": "D SoT In the Context of Literature (Expanded) 22",
            "text": "D.1 Efficient LLMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 D.2 Prompting Methods for LLMs . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 D.3 Hierarchical Text Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . 24"
        },
        {
            "heading": "E Efficiency Analysis 24",
            "text": ""
        },
        {
            "heading": "F Efficiency Profiling 26",
            "text": ""
        },
        {
            "heading": "G Efficiency Evaluation 27",
            "text": "G.1 Skeleton-of-Thought . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 G.2 Skeleton-of-Thought with Router . . . . . . . . . . . . . . . . . . . . . . . . . 29"
        },
        {
            "heading": "H Overhead of SoT in Different Scenarios 31",
            "text": ""
        },
        {
            "heading": "I Answer Quality Evaluation 32",
            "text": "I.1 Skeleton-of-Thought . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 I.2 Skeleton-of-Thought with Router . . . . . . . . . . . . . . . . . . . . . . . . . 44 I.3 Quality Comparison with Longer Normal Answer . . . . . . . . . . . . . . . . 46 I.4 ChatGPT-3.5 as the Judge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46"
        },
        {
            "heading": "J Combining SoT-R with Model Quantization 48",
            "text": "J.1 Speed-ups of SoT + Quantization on Quantized Models . . . . . . . . . . . . . 49 J.2 Speed-ups of SoT + Quantization on Unquantized Models . . . . . . . . . . . . 49"
        },
        {
            "heading": "K Additional SoT-R statistics 50",
            "text": "K.1 Number of Suitable Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 K.2 Peak Memory Overhead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 K.3 Speed-ups with Different Number of Points . . . . . . . . . . . . . . . . . . . . 51\nL Notes on Application Scenarios 51"
        },
        {
            "heading": "A MODEL DETAILS",
            "text": "Table 1 summarizes the models on which we evaluate SoT. We use GPT-4 in the main paper and ChatGPT-3.5 in App. I.4 as the judge in FastChat and LLMZoo evaluation.\nTable 2 shows sources of the models we use in the paper.\nB IMPLEMENTATION DETAILS OF SKELETON-OF-THOUGHT"
        },
        {
            "heading": "B.1 PROMPT",
            "text": "The skeleton prompt is shown in Prompts 1 and 3 and the point-expanding prompt is shown in Prompt 2.\nSkeleton prompt template. In order to make the output skeleton short and in a consistent format for the good of efficiency and ease of point extraction, the skeleton prompt template (1) describes the\n2For convenience, we use the non-official endpoint TheBloke/stable-vicuna-13B-HF and TheBloke/UltraLM-13B-fp16 to get merged weights.\n3https://www.anthropic.com/claude-in-slack 4https://azure.microsoft.com/en-us/products/ai-services/openai-service\nPrompt 3. Skeleton Prompt Template T s (with Two-Shot Demonstrations)\n[User:] You\u2019re an organizer responsible for only giving the skeleton (not the full content) for answering the question. Provide the skeleton in a list of points (numbered 1., 2., 3., etc.) to answer the question. Instead of writing a full sentence, each skeleton point should be very short with only 3\u223c5 words. Generally, the skeleton should have 3\u223c10 points.\nQuestion: What are the typical types of Chinese dishes? Skeleton: 1. Dumplings. 2. Noodles. 3. Dim Sum. 4. Hot Pot. 5. Wonton. 6. Ma Po Tofu. 7. Char Siu. 8. Fried Rice.\nQuestion: What are some practical tips for individuals to reduce their carbon emissions? Skeleton: 1. Energy conservation. 2. Efficient transportation. 3. Home energy efficiency. 4. Reduce water consumption. 5. Sustainable diet. 6. Sustainable travel.\nNow, please provide the skeleton for the following question. {question} Skeleton: [Assistant:] 1.\ntask precisely, and (2) provides a partial answer \u201c1.\u201d for the LLM to continue writing. The skeleton responses are in the desired format in most cases. Therefore, we can use a simple regular expression (\\d+)\\.\\s?([\\s\\S]+?)(?=\\n|\\n*$) to extract point indexes and point skeletons from the skeleton response.\nWe find that GPT-4 can work well without the two demonstrations in the skeleton prompt. Therefore, we do not include the two demonstrations for GPT-4 (Prompt 1). For all other models, the two demonstrations are included, as shown in Prompt 3.\nPoint-expanding prompt template. It describes the point-expanding task and provides a partial answer. We also provide instructions \u201cWrite it **very shortly** in 1\u223c2 sentence\u201d so that the LLMs keep the answers concise. Unlike the skeleton prompt template, we find that demonstrations are not necessary to get reasonable results.\nWe find that Claude and GPT-4 follows the instruction \u201cWrite it **very shortly** in 1\u223c2 sentence and do not continue with other points!\u201d in Prompt 2 very well, so that the answers are very short. Therefore, we delete \u201c**very shortly**\u201d from the prompt template in Claude and GPT-4.\nPartial answer. In the Prompts 1 and 2, we provide partial answers so that LLMs can follow the desired response format better.\nWe can put the partial answer at the end of the prompt for the open-source models to continue writing. An implementation detail is that different open-source models have different conversation templates (i.e., different ways to combine user and assistant messages into one string). For example, Vicuna (Chiang et al., 2023) uses the string \u201cUSER:\u201d and \u201c ASSISTANT:\u201d for the placeholder \u201c[User:]\u201d and \u201c[Role]\u201d in the Prompts 1 and 2, respectively, while UltraLM (Ding et al., 2023) uses \u201cUser:\u201d and \u201c\u2329/s\u232aAssistant:\u201d. We build our open-source model experiments with the help of the FastChat codebase (Zheng et al., 2023), in which the conversation templates of many models are already handled correctly. We implement the conversation templates of OpenChat-13B, StableVicuna-13B, and UltraLM-13B according to their official guides and codes.\nFor ChatGPT-3.5, we provide partial answers as a last message in the chat history from the assistant. Note that it is not a documented approach. We find it works well in most cases, in that ChatGPT-3.5\nPrompt 4. LLM Prompting as the Router\n[User:] Question: {question}\nHow would you like to answer the question? A. Organize the answer as a list of points or perspectives (in the format of 1., 2., 3., etc.), and the points or perspectives can be answered independently without referring to the contents of the previous points. B. Organize the answer as a list of points or perspectives (in the format of 1., 2., 3., etc.), and the contents of later points or perspectives cannot be answered independently without referring to the contents of the previous ones. C. Do not organize the answer as a list of points or perspectives.\nJust say A, B, or C. Do not explain. Do not provide an answer to the question. [Assistant:]\ncontinues the texts from the provided partial answer. However, in some rare cases, ChatGPT-3.5 repeats the provided partial answers.\nFor Claude over Slack, there is no obvious way to give the API a partial answer. We resort to modifying the prompt template slightly by adding\nPlease start your answer from \u201c{partial answer}\u201d and do not output other things before that\nat the end. We find that Claude understands and obeys it well. For GPT-4, we also take this approach.\nSystem Message. We do not include the system message in the prompts for open-source models except LLaMA2.\nThe partial answer, \u201c**very shortly**\u201d, and the 2-shot demonstrations discussed above are the only differences between the prompts we used across all models and all evaluations."
        },
        {
            "heading": "B.2 SUPPORTING MULTI-ROUND CONVERSATION",
            "text": "To use SoT in a multi-round conversation, we can just put the question and the final aggregated answer in the history, removing all the SoT prompts. In this way, using SoT in one conversation round will not introduce additional prefill cost in future rounds.\nC IMPLEMENTATION DETAILS OF SKELETON-OF-THOUGHT WITH ROUTER"
        },
        {
            "heading": "C.1 PROMPTING ROUTER",
            "text": "We use Prompt 4 for querying GPT-4 as the router. If the answer is \u201cA\u201d (i.e., the question can be answered in a list of independent points), we will use SoT. Otherwise, if the answer is \u201cB\u201d (i.e., the answer is in a list of points but they depend on each other) or \u201cC\u201d (i.e., the answer should not be in a list of points), SoT is not suitable and we will fall back to normal decoding."
        },
        {
            "heading": "C.2 TRAINED ROUTER",
            "text": "We tackle the routing problem as a sequence classification task. We first annotate the LIMA training set (Zhou et al., 2023), and then fine-tune a RoBERTa model (Liu et al., 2019) using the labeled data. Finally, we apply the tuned RoBERTa as the router on Vicuna-80 and WizardLM. We detail the steps in the following."
        },
        {
            "heading": "C.2.1 ANNOTATION PROCESS",
            "text": "In the classification task, a label of 1 (positive) indicates that this question can be answered with SoT, while a label of 0 (negative) suggests that using the normal generation mode is more suitable. We annotate the LIMA training set, which consists of 1,030 Q&As sourced from three community webpages: Stack Exchange, wikiHow, and the Pushshift Reddit. We also annotate the Vicuna-80 and WizardLM datasets for evaluation.\nWe use GPT-4 to assist the annotation process. Specifically, we present each question to GPT-4 and analyze its answer to determine whether SoT can be triggered for this question. We assign a positive label to a question if GPT-4\u2019s response meets two criteria: (1) it contains a list of points that can be expanded in parallel, (2) each point provides sufficient details (i.e., the point-expanding response is not too short), which will enable SoT to achieve a speed-up. Two of the paper\u2019s authors conduct the annotation process independently, and discuss the inconsistent annotations to decide the final label."
        },
        {
            "heading": "C.2.2 TRAINING DETAILS",
            "text": "We use roberta-base with 120M parameters as the router model. The finetuning is conducted using the AdamW optimizer (Loshchilov & Hutter, 2019) with a weight decay of 0.01. The learning rate undergoes a warm-up phase during the first 1% of iterations to 5e-5 and then decays linearly. We train the model for 2 epochs using a batch size of 32. Input sequences are either padded or truncated to achieve a consistent length of 512 tokens.\nIn the application of SoT, false positives (SoT is incorrectly triggered when it should not be, resulting in degraded answer quality) are of more significant concern than false negatives (the router misses a potential SoT trigger, resulting in a reduced speed-up). Thus, to mitigate false positives, we employ the Tversky loss (Wang et al., 2023b) with parameters \u03b1 = 0.7 and \u03b2 = 0.3, which penalizes false positives more heavily than false negatives. We also incorporate label smoothing (Szegedy et al., 2016) with a factor of = 0.2. Overall, the entire fine-tuning process is efficient, completing in 2 minutes on an NVIDIA A100 GPU."
        },
        {
            "heading": "C.3 ROUTER CONSISTENCY",
            "text": "We present the confusion matrices for the three routers to illustrate their consistency. The results on Vicuna-80 and WizardLM are shown in Tables 3 and 4, respectively.\nOn Vicuna-80, we can observe a notable level of agreement among the three routers. Compared with the GPT-4-prompting router, the trained router exhibits a slightly higher number of false negatives w.r.t. the human annotations. Conversely, on WizardLM, given the intricate answer structure and the presence of many ambiguous cases, the routers show significant discrepancies. Specifically, the GPT-4 router produces many false positives, which pose adverse affects on the answer quality (see App. I.2). The RoBERTa router aligns more closely with the human annotations."
        },
        {
            "heading": "C.4 CONCURRENT EXECUTION FOR SOT-R",
            "text": "In SoT-R, the router serves as an additional stage that extends the two-stage SoT pipeline, as illustrated in Fig. 9. To push the limit of latency optimization, we can run the router, normal generation, and SoT generation concurrently. Once the router makes a decision, one of the normal and SoT generation processes can be aborted. However, this approach will increase the token overhead. Therefore, we did not employ this approach in this work and leave it to future work.\nRouter\nSkeleton Expand positive\nnegative Decode\nQuestion\nAnswer\nAnswer\nRouter\nSkeleton Expand\nDecode\nQuestion\nAnswer\nAnswer\npositive\nnegative\nFigure 9: Left: The SoT-R pipeline. Right: A possible approach to further reduce latency at the cost of token overhead."
        },
        {
            "heading": "D SOT IN THE CONTEXT OF LITERATURE (EXPANDED)",
            "text": ""
        },
        {
            "heading": "D.1 EFFICIENT LLMS",
            "text": "Extensive research has been dedicated to enhancing the throughput and latency of LLM inference. We first discuss model-level architecture design or compression techniques. These techniques change the model and can benefit both the latency and throughput but require finetuning to retain the model quality. Then, we discuss system-level efforts that optimize the computational graph or the assignment and scheduling of the computational graph on computation and storage devices. Most system-level efforts accelerate the prefilling phase or focus on improving the throughput. Finally, we discuss some research efforts that share a similar motivation to ours, namely, addressing the efficiency issue of sequential decoding.\nModel-level optimization. Considerable architectural design efforts have emerged to (1) improve the scalability w.r.t. model size by introducing mixture-of-expert inference (Lepikhin et al., 2021; Fedus et al., 2022), (2) address the quadratic complexity w.r.t. input size of attention by designing new attention mechanisms (Kitaev et al., 2020; Wang et al., 2020), (3) reduce the memory access and footprint of attention by using multi-query attention (Shazeer, 2019), and so on. However, these methods usually require a substantial re-training cost. The model compression techniques require a smaller amount of fine-tuning by reducing the model complexity of a pre-trained LLM from certain aspects (Ganesh et al., 2021). Representative techniques include quantization (Xiao et al., 2022; Frantar et al., 2022; Lin et al., 2023), the static or dynamic pruning of weights, activation, and attention (Mishra et al., 2021; Zaheer et al., 2020; Wang et al., 2021; Chen et al., 2023b), and so on.\nZooming out from LLM compression to the whole field of model compression, we can see that model co-design or compression for efficiency has received tremendous attention in the past few years and has grown into large research fields, such as pruning (Han et al., 2015; Wen et al., 2016), quantization (Krishnamoorthi, 2018), factorization (Denton et al., 2014), and neural architecture search (Zoph & Le, 2017; Elsken et al., 2019; Cai et al., 2019). Different from the model co-design paradigm, SoT is in a \u201ccontent co-organization for efficiency\u201d paradigm for improving the LLM efficiency. Along with the growth in the LLM capabilities and amount of LLM-generated data, data-level techniques could become important tools in the efficient LLM toolbox.\nSystem-level optimization. In the realm of lossless acceleration, considerable efforts have been devoted to addressing the I/O-bound nature of LLMs on modern hardware platforms (Dao et al., 2022). Numerous studies (Dao et al., 2022; Zhai et al., 2022; Ivanov et al., 2021; NVIDIA, 2019) have focused on adjusting the computational graph by fusing and implementing operations in an I/O-friendly way. As a representative method, FlashAttention (Dao et al., 2022) fuses all operations of one attention into one GPU kernel with spatially tiled computation to reduce the off-chip I/O of the attention map. While FlashAttention can effectively accelerate training and the prefilling phase of inference, it cannot accelerate the decoding phase much (when the batch size is small), as it is the I/O of weights rather than activation or attention map that bottlenecks the decoding phase. For example, when the context length is 64, decoding one token using LLaMA-7B needs to load each of the 7B parameters from the off-chip HBM onto the GPU chip at least once, but only transferring about 20M (0.02B) activation values between the off-chip HBM and GPU chip.\nIn order to satisfy Service Level Objectives, serving systems focus on improving the serving throughput under latency constraints. To this end, serving systems (Fang et al., 2021; NVIDIA,\n2021; Google, 2021) pack multiple queries together into a batch to improve the hardware utilization. The batching technique has proven highly effective in enhancing throughput, leading to the development of various variants. For example, some work designs methods to decide which queries to batch together (Fang et al., 2021; Zhou et al., 2022), while others selectively batch parts of the model to enable fine-grained iteration-level batching (Yu et al., 2022) or multi-task batching (Zhou et al., 2022). Various model parallelism (Lu et al., 2017; Huang et al., 2019; Narayanan et al., 2019; Rajbhandari et al., 2020; Narayanan et al., 2021; Li et al., 2021; Zheng et al., 2022) and offloading (Ren et al., 2021; Sheng et al., 2023) techniques have been proposed to maximize the throughput of LLM training or inference. In a nutshell, given the computational graph and device configurations, these techniques optimize the split, assignment, and scheduling of computations, storage, and communications on devices. In addition to the model parallelism and batching techniques, an efficient memory management mechanism for LLM workloads is also an essential feature in the serving systems (Kwon et al., 2023; SenseTime, 2023a;b).\nTo sum up, these system-level techniques mainly help with the throughput in training and batched inference. They can be used by SoT to improve the throughput of the batched decoding of multiple segments. This means that SoT can harness the power of these throughput-oriented techniques and make them help with the end-to-end latency, offering a new dimension for better trading off latency and throughput in future serving systems.\nAnother parallelism perspective to position SoT is that SoT guides the LLM to adjust the sequential workload to become \u201cinter-content\u201d parallelizable, which differs from the parallelism levels in existing serving systems, including inter-instance (Krizhevsky, 2014; Rajbhandari et al., 2020), inter-operation (Huang et al., 2019; Narayanan et al., 2019; 2021), intra-operation (Xu et al., 2021), and inter-token (Li et al., 2021). It may be worthwhile to explore the integration of SoT into serving systems to maximize the hardware utilization.\nDecoding optimization. One bottleneck for the end-to-end latency lies in the autoregressive decoding phase, where tokens must be generated one by one. Due to the dependency between tokens, the computation of different tokens cannot be parallelized, causing severe under-utilization of GPU. In order to improve the end-to-end decoding latency of a given LLM, speculative decoding methods (Stern et al., 2018; Leviathan et al., 2022; Chen et al., 2023a; Gante, 2023; Sun et al., 2023; Miao et al., 2023) propose to use cheaper approaches to generate short candidate token sequences, for example, by sequentially decoding with an assisting model much smaller than the given LLM. Then, they use the LLM to parallelly verify the candidates and keep the prefix sequence that matches the LLM\u2019s verification results.\nAnother line of work that shares the motivation of addressing the autoregressive efficiency issue is non-autoregressive generation (NAG) methods (Gu et al., 2018; Xiao et al., 2023). NAG methods sample consecutive tokens parallelly, often with the aid of a modified and tuned model. To maintain the answer quality, instead of sampling for one iteration, many NAG methods refine the output parallelly for multiple iterations (Xiao et al., 2023; Santilli et al., 2023).\nTo summarize, the speculative decoding methods use assisting models for letting the LLM conduct parallel verification of consecutive tokens, and the NAG methods rely on specially designed models, training schemes, or sampling schemes for the parallel sampling and refinement of consecutive tokens. In contrast, SoT prompts the LLM itself to plan the contents in a way that permits the parallel generation of multiple tokens in different segments. SoT exploits the emerging instruction-following and planning ability of SoTA LLMs rather than relying on specially designed modeling, sampling, and training schemes. This is different from all existing work that targets the autoregressive efficiency issue."
        },
        {
            "heading": "D.2 PROMPTING METHODS FOR LLMS",
            "text": "In recent years, the \u201cpre-train, prompt, and predict\u201d paradigm has emerged (Liu et al., 2023), which designs prompts comprising task descriptions and (optionally) a few demonstrations to guide pretrained LLMs in generating answers for a wide range of downstream tasks. Researchers found that instruction-tuned LLMs (Brown et al., 2020; Wei et al., 2021; Ouyang et al., 2022; Chung et al., 2022; Taori et al., 2023) possess a strong ability to (1) generalize to new tasks thanks to the diverse\nnatural language descriptions encountered during instruction tuning, and (2) learn in-context using a few demonstrations without weight tuning.\nIn virtue of these abilities, the field has been manually engineering (Brown et al., 2020; Kojima et al., 2022; Shen et al., 2023; Li et al., 2023a), automatic searching (Shin et al., 2020), or continuously tuning (Li & Liang, 2021; Lester et al., 2021) the prompts for uncovering the capabilities of LLMs on downstream tasks. There are a bunch of prompting methods that improves the reasoning performance of LLMs by designing thinking flows mimicking human reasoning: (1) mimicking the step-by-step or compositional thinking structure (Wei et al., 2022; Kojima et al., 2022; Press et al., 2022; Yao et al., 2023; Besta et al., 2023; Zhang et al., 2023), (2) designing multiple reasoning paths and their aggregation (Wang et al., 2022; Yao et al., 2023; Li et al., 2023c), and (3) using tools for calculation and information retrieval (Chen et al., 2022; Yao et al., 2022; Schick et al., 2023). As a representative example, the Chain-of-Thought prompts largely improve the performance on tasks that require logical reasoning by simply providing a \u201cLet\u2019s think step by step\u201d (Kojima et al., 2022) instruction or a few demonstrations (Wei et al., 2022). Another topic that arises quite a surge of interests is to prompt LLMs to help finish complex multi-modality task (Shen et al., 2023; Zhu et al., 2023). For example, HuggingGPT (Shen et al., 2023) design prompts to guide the LLM to generate structural JSON for the orchestration of multi-model execution to finish complex tasks.\nTo summarize, the large literature on prompting methods has been aiming at uncovering different capabilities of LLM and improving the answer quality on different downstream tasks. In contrast, SoT is a first attempt at exploiting the power of prompting to improve efficiency."
        },
        {
            "heading": "D.3 HIERARCHICAL TEXT GENERATION",
            "text": "SoT can be regarded as being \u201chierarchical\u201d since it has high-level answer structure planning. Prior studies in hierarchical text generation (Li et al., 2015; Shao et al., 2019; Puduppully et al., 2019; Fan et al., 2018) all focus on enhancing the answer quality, including improving the long-range coherence, relevance to the topic, or reducing redundancy. These methods craft hierarchical neural architectures that contain different modules to model high-level (sentence-level or document-level) and low-level (word-level) dependencies (Li et al., 2015; Shao et al., 2019; Fan et al., 2018). They still employ sequential word-by-word generation without parallelization between sentences.\nNote that the sentence-level representations in previous work (Li et al., 2015; Shao et al., 2019) are \u201cimplicit\u201d latent variables instead of \u201cexplicit\u201d language descriptions. Some previous studies (Shao et al., 2019; Puduppully et al., 2019) train a dedicated planning module to execute explicit content planning in advance. Nevertheless, these methods all conduct \u201cclosed-form\u201d planning that only reorders and groups the input keywords, rather than producing \u201cfree-form\u201d plans on \u201cwhat to say\u201d and \u201chow to say\u201d. All the hierarchical architectures and planning modules require training or even special data processing (Puduppully et al., 2019).\nTo summarize, in terms of the objective, the primary focus of SoT \u2013 efficient generation \u2013 is different from previous hierarchical text generation literature. In terms of the methodology, instead of designing new hierarchical architectures or planning modules, SoT exploits the emerging planning and instruction-following abilities of LLMs to do explicit (which means the plan is described by interpretable language) and free-form planning. This allows SoT to be applied to off-the-shelf LLMs for producing structured answers.\nAs the hierarchical text generation literature focuses on enhancing answer quality, they could provide inspiration for future expansions of SoT to generate high-quality answers for broader types of questions."
        },
        {
            "heading": "E EFFICIENCY ANALYSIS",
            "text": "This section gives a detailed explanation on why SoT can reduce the overall decoding latency with the same computational resource for local models.\nThe vanilla approach processes only one question and decodes the answers sequentially, whereas SoT processes multiple point-expanding requests and the answers in a batch. We focus on the following question: \u201cCompared to processing only one sequence, how much peak memory overhead and latency increase will be brought by processing a batch of sequences?\u201d\nA typical LLM generative process consists of two phases: (1) the prefilling phase in which the prompt is parsed to generate the key-value cache for further use, and (2) the decoding phase in which tokens are generated one by one in a sequential manner. The decoding phase accounts for the majority of the end-to-end latency, especially when generating a long response. As shown in Table 5, when running Vicuna-7B on NVIDIA A100-80G, the actual computing performance is only 0.31 TFLOPS (0.1% utilization) in the decoding phase, compared to 43 TFLOPS (13.8% utilization) during prefilling. The utilization is calculated with respect to the FP165 tensor core peak performance \u2013 312 TFLOPS for NVIDIA-A100. As a result, the latency of decoding only one token is comparable to that of prefilling 128 tokens (40ms). This huge gap in actual computing performance and thereby the latency arises from the fact that all LLM weights need to be loaded onto the GPU chip at least once only for decoding one token, so the decoding is heavily bottlenecked by the I/O of weights and the GPU computation units cannot be well utilized.\nWhen conducting batched decoding, as the sequence batch sizeB increases, the latency of decoding one token for each sequence stays roughly the same (Fig. 10a), as the amount of LLM weights that needs to be loaded onto the chip does not change. As a result, the GPU computation utilization ( Actual GPU PerformancePeak GPU Performance ) increases almost linearly as B increases (Fig. 10b). In other words, for generating a final answer of length N , if we cut the answer into B segments of length N/B and decode them as a batch, we can get a B\u00d7 decoding speed-up compared to sequential decoding. Nevertheless, in practice, as prefilling longer requests brings some overhead, and the lengths of the B segments could be imbalanced, the actual speed-up of the batched point-expanding stage compared with the original prefilling and sequential decoding process is smaller than B.\nAs for the peak memory overhead, the amount of LLM weights can be one to two orders of magnitude larger than that of all the intermediate activations as long as the prefilling token length is not too large, not to mention that most activations do not need to be saved for back-propagation during inference. Therefore, the LLM weights account for the majority of the memory footprint in our test cases. Consequently, as shown in Fig. 10c, the peak memory overhead due to the increasing size of the KV cache and activation grows at a slow pace as the batch size B increases. Thanks to the small peak memory overhead, in all of our experiments, we managed to use one GPU to run SoT without seeking help from other peak memory optimization techniques (e.g., quantization (Frantar et al., 2022; Lin et al., 2023), offloading (Sheng et al., 2023)).\n5All of our experiments are run with FP16 inference."
        },
        {
            "heading": "F EFFICIENCY PROFILING",
            "text": "We run the profiling on the target GPU (NVIDIA A100-80G and NVIDIA RTX 3090) with CUDA 11.7, using the Hugging Face transformer library 4.28.1 and PyTorch 2.0.1. The host of A100-80G has an Intel Xeon Platinum 8358P CPU and 1T memory. The host of RTX 3090 has an Intel Xeon Gold 6246R CPU and 512G memory.\nLatency profiling and estimation. For the decoding phase, we denote tDB (k) as the latency of batched decoding the k + 1-th token with batch size B, where the superscript D stands for \u201cdecode\u201d. For each batch size B = 1, \u00b7 \u00b7 \u00b7 , 16 and each context length k = 1, \u00b7 \u00b7 \u00b7 , 1024, we use torch.cuda.Event to record the latency of decoding one token. We run each decoding three times continuously and take their geometric mean as {tDB (k)}k=1,\u00b7\u00b7\u00b7 ,1024;B=1,\u00b7\u00b7\u00b7 ,16. For the prefilling phase, we profile the latency of batched prefilling the inputs with token length k in range(1, 700, 10) and batch size B = 1, \u00b7 \u00b7 \u00b7 , 16, and denote it as tPB(k), where the superscript P stands for \u201cprefill\u201d. We run each test seven times continuously, regard the first two times as the warmup tests, and take the geometric mean of the last five times as {tPB(k)}k=1,11,\u00b7\u00b7\u00b7 ,691;B=1,\u00b7\u00b7\u00b7 ,16. Once we get the latency profiling table, given a request with li tokens and the decoding batch size B, the latency of generating lo tokens can be estimated as:\nT (li, lo, B) = t\u0303 P B(li) + li+lo\u22121\u2211 k=li tDB (k), (1)\nwhere the subscripts i and o stand for \u201cinput\u201d and \u201coutput\u201d. Note that we only test the prefilling latency every ten token lengths (i.e., 1, 11, 21, \u00b7 \u00b7 \u00b7 ) for fast profiling and estimate t\u0303PB(li) by tPB(b li 10c \u00d7 10 + 1).\nThe SoT decoding process consists of two stages: the skeleton stage and the point-expanding stage. Denoting the token length of the skeleton request and skeleton response as lsi and l s o, the token length of the longest point-expanding request and the longest point-expanding response as lpei and l pe o , the number of the points as B, we can compute the latency of the skeleton and point-expanding stages as:\nLs(lsi , l s o) = T (l s i , l s o, 1), (2)\nLpe(lpei , l pe o , B) = T (l pe i , l pe o , B). (3)\nUsing the latency profiling table, we can further estimate the average GPU computing performance in FLOPS (i.e., FLOPs per second) of decoding lo tokens with prefilling length li as\nPD(li, lo, B) =\n\u2211li+lo\u22121 k=li\nfDB (k)\u2211li+lo\u22121 k=li tDB (k) , (4)\nwhere fDB (k) denotes the FLOPs of decoding one token with context length k, which is calculated by DeepSpeed\u2019s FLOPs profiler 6. Fig. 10b reports the average GPU computing performance during the process of decoding 64 tokens (prefilling length=128), i.e., PD(128, 64, B).\nMemory profiling and evaluation. To evaluate the peak memory, we use torch.cuda.max_memory_allocated to record the memory consumption of prefilling sequences of different lengths and decoding with different context lengths and a batch size ranging from 1 to 16. Then, we calculate the peak memory of each stage as the maximum value of the prefilling and decoding phases, and calculate the overall peak memory of SoT as the maximum value of the skeleton and point-expanding stages.\n6https://deepspeed.readthedocs.io/en/latest/flops-profiler.html"
        },
        {
            "heading": "G EFFICIENCY EVALUATION",
            "text": ""
        },
        {
            "heading": "G.1 SKELETON-OF-THOUGHT",
            "text": ""
        },
        {
            "heading": "G.1.1 DETAILED STATISTICS OF TOKEN LENGTHS AND POINT NUMBERS",
            "text": ""
        },
        {
            "heading": "G.1.2 LATENCY BREAKDOWN: SOT STAGES AND PHASES",
            "text": "Fig. 12 presents the absolute latencies of normal and SoT generations on Vicuna-80. Again, the speed-ups of SoT compared with normal generation is evident. We can see that the decoding phases predominantly account for the end-to-end latency. Consequently, although SoT has higher prefilling latency in the skeleton stage than the normal generation and introduces additional point-expanding\nprefilling latency \u2013 which is expected \u2013 this has negligible impact on the overall latency and thereby the overall speed-up."
        },
        {
            "heading": "G.1.3 EFFICIENCY EVALUATION ON NVIDIA RTX 3090",
            "text": "We present the SoT speed-ups and latency breakdown on RTX 3090 in Fig. 13. We test the three 7B models, as their FP16-precision version can be run on an RTX 3090 GPU without further peak memory optimization techniques such as weight quantization (Frantar et al., 2022; Lin et al., 2023) or offloading (Sheng et al., 2023). On these three models, SoT can obtain 1.94\u00d7 to 2.40\u00d7 speed-up on average on Vicuna-80.\nFor the five question categories that SoT can provide high-quality answers (i.e., knowledge, commonsense, generic, roleplay, counterfactual), SoT can speed-up the overall answer generation process by 1.96\u00d7 to 2.52\u00d7 in the meantime. Note that for the math category, despite the average speed-up being 1.20\u00d7 by calculating the speed-up across the three math questions, SoT does not reduce the absolute latency of processing the three questions."
        },
        {
            "heading": "G.1.4 ACTUAL LATENCY TESTING",
            "text": "This section reports the actual SoT speed-up on the Vicuna-80 with batch testing (instead of analyzing with pre-made profiling tables), using a single NVIDIA A100 GPU. We test the actual end-to-end latency of the SoT and normal decoding with the 9 open-source models. For each model, we run the speed-up test for five times and plot the box in Fig. 14.\nAs shown in Fig. 14a, the current SoT solution obtains a > 2\u00d7 speed-up on 6 out of the 9 opensource models (i.e., Vicuna-7B V1.1, Vicuna-7B V1.3, UltraLM-13B, LLaMA2-Chat-7B, Vicuna13B V1.3, and LLaMA2-Chat-13B), and a> 1.7 speed-up on OpenChat-13B and Vicuna-33B V1.3. SoT achieves no speed-up on StableVicuna-13B. As shown in Fig. 14b, for the five question categories that SoT can provide high-quality answers (i.e., knowledge, common-sense, generic, roleplay, counterfactual), SoT can speed-up the overall answer generation process by 2.15\u00d7 to 2.50\u00d7 in the meantime."
        },
        {
            "heading": "G.2 SKELETON-OF-THOUGHT WITH ROUTER",
            "text": "The overhead brought by the router inference is relatively small: On the Vicuna-80 dataset, the prompting and trained router have an average latency of 0.65s (0.39s\u223c1.37s) and 0.04s (0.008s\u223c1.55s), respectively. On the WizardLM dataset, the average latency of the prompting and trained router is 0.80s (0.36s\u223c2.22s) and 0.03s (0.009s\u223c2.52s), respectively."
        },
        {
            "heading": "G.2.1 SPEED-UP BREAKDOWN: MODELS",
            "text": "Fig. 15 shows the speed-ups of SoT-R on different models on the Vicuna-80 dataset. Fig. 16 and Fig. 17 show the speed-ups of SoT-R on different models on the WizardLM dataset. We can observe that on Vicuna-80, the two methods yield similar speed-ups, whereas on WizardLM, GPT-4 prompting router usually obtains higher speed-ups than the trained router, especially on GPT-4 itself."
        },
        {
            "heading": "G.2.2 SPEED-UP BREAKDOWN: CATEGORIES",
            "text": "Fig. 18 and Fig. 19 show the speed-ups of SoT-R on different question categories of Vicuna-80 dataset. The trained router achieves slightly higher speed-up on most of the categories (except for knowledge, writing, and fermi). Fig. 20 and Fig. 21 show the speed-ups of SoT-R on different question categories of WizardLM dataset. We can observe that on 19 out of 29 categories, using the prompting router achieves higher speed-ups than using the trained router.\n1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 math\ncoding fermi\nwriting roleplay\ncounterfactual knowledge\ncommon-sense generic\n0.90\u00d7 0.96\u00d7 1.01\u00d7\n1.10\u00d7 1.17\u00d7\n1.75\u00d7 1.95\u00d7\n2.05\u00d7 2.11\u00d7\n(a) Speed-ups of SoT-R with prompting router on different question categories.\n1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 math\nwriting coding fermi\nroleplay counterfactual\nknowledge common-sense\ngeneric\n1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7\n1.23\u00d7 1.79\u00d7\n1.87\u00d7 2.10\u00d7\n2.26\u00d7\n(b) Speed-ups of SoT-R with trained router on different question categories.\nFigure 18: Speed-ups of SoT-R on different question categories of Vicuna-80 dataset\n1.0 1.5 2.0 2.5 3.0 3.5 4.0 math fermi\ncounterfactual roleplay\ncoding common-sense\nwriting generic\nknowledge\nSoT (w/o router) SoT-R w/ prompting router SoT-R w/ trained router\nFigure 19: Speed-ups of SoT and SoT-R on different question categories of the Vicuna-80 dataset.\n1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00\nMath Physics\nReasoning Code Generation\nEntertainment Toxicity\nComplex Format Multilingual\nCommon-Sense Code Debug\nBiology Art\nMusic Computer Science\nRoleplay Chemistry\nEthics Academic Writing\nTruthfulQA Writting\nLiterature Philosophy\nLaw Sport\nMedicine History\nTechnology Economy\nCounterfactual\n0.85\u00d7 0.94\u00d7\n1.02\u00d7 1.02\u00d7 1.03\u00d7\n1.12\u00d7 1.14\u00d7\n1.22\u00d7 1.24\u00d7 1.25\u00d7\n1.34\u00d7 1.47\u00d7\n1.54\u00d7 1.54\u00d7 1.58\u00d7 1.62\u00d7\n1.67\u00d7 1.69\u00d7\n1.74\u00d7 1.77\u00d7\n1.85\u00d7 1.90\u00d7 1.90\u00d7 1.93\u00d7\n2.08\u00d7 2.10\u00d7 2.14\u00d7 2.18\u00d7\n2.23\u00d7\n(a) Speed-ups of SoT-R with prompting router on different question categories.\n1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00\nCode Generation Entertainment\nArt Complex Format\nMath Literature\nCode Debug Law\nAcademic Writing Philosophy\nBiology Reasoning\nPhysics History\nComputer Science Multilingual\nMusic Toxicity\nRoleplay Common-Sense\nTruthfulQA Writting\nEconomy Chemistry\nEthics Sport\nTechnology Medicine\nCounterfactual\n0.99\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7\n1.07\u00d7 1.09\u00d7\n1.14\u00d7 1.16\u00d7 1.17\u00d7 1.17\u00d7 1.20\u00d7 1.22\u00d7\n1.36\u00d7 1.37\u00d7 1.41\u00d7\n1.49\u00d7 1.65\u00d7\n1.73\u00d7 1.82\u00d7\n2.01\u00d7 2.17\u00d7\n2.26\u00d7 2.41\u00d7\n(b) Speed-ups of SoT-R with trained router on different question categories.\nFigure 20: Speed-ups of SoT-R on different question categories of WizardLM dataset\n1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00\nEntertainment Physics\nReasoning Multilingual\nMath Common-Sense\nBiology Art\nMusic Toxicity\nEthics Computer Science\nCode Debug Chemistry Literature\nAcademic Writing Philosophy\nLaw TruthfulQA\nRoleplay Code Generation Complex Format\nSport Writting\nMedicine History\nTechnology Economy\nCounterfactual\nSoT (w/o router) SoT-R w/ prompting router SoT-R w/ trained router\nFigure 21: Speed-ups of SoT and SoT-R on different question categories of the WizardLM dataset."
        },
        {
            "heading": "H OVERHEAD OF SOT IN DIFFERENT SCENARIOS",
            "text": "Despite the optimizations made to the decoding phase, SoT brings overhead to the prefilling phase as the model needs to handle additional SoT prompts. Table 6 reports SoT\u2019s prefilling overhead for the API-based models. These statistics are averaged across the Vicuna-80 questions that are suitable for SoT (according to our manual annotation). We can see that SoT significantly increases the number of prefilling tokens. This is because that SoT issues an independent point-expanding request for each point, with the average number of points being 6.8 on Vicuna-80 dataset across all evaluated models. Consequently, the APIs need to prefill the point-expanding request multiple times.\nWhen using SoT to serve the open-source models, a simple and small trick is to prefill the common prefix of point-expanding requests with a batch size of 1 during Stage 2 (i.e., the point-expanding stage). Table 7 shows the prefilling overhead after applying the trick. Although the ratio is considerably smaller compared to that of the API-based models, this computational overhead remains a concern, especially during periods of high system workload.\nThere are some possibilities to further reduce the token and computational overhead that are worth exploring in future work. To name a few: (1) When using SoT in serving systems, we can simply reuse the key-value cache containing the question and skeleton from Stage 1 during Stage 2, rather than re-prefilling them as in a multi-round conversation. (2) Generally, as LLM capabilities continue to evolve and prompt tuning techniques advance (Shin et al., 2020; Li & Liang, 2021; Lester et al., 2021; Jiang et al., 2023), the possibility of using much shorter prompts to activate the SoT mode in the future holds promise, which would significantly mitigate the token or computational overhead."
        },
        {
            "heading": "I ANSWER QUALITY EVALUATION",
            "text": ""
        },
        {
            "heading": "I.1 SKELETON-OF-THOUGHT",
            "text": ""
        },
        {
            "heading": "I.1.1 ANSWER ANALYSIS: DIFFERENT MODELS",
            "text": "Models on which SoT has low net win rates. We observe two types of reasons for the low net win rates.\n(1) OpenChat-13B, Vicuna-7B V1.1, and LLaMA2-Chat-13B. For the weak models such as OpenChat-13B and Vicuna-7B V1.1, they are not able to follow the SoT prompts precisely. For OpenChat-13B and LLaMA2-Chat-13B, sometimes the skeleton contains undesired contents (e.g., completing the skeleton points as shown below).\nQuestion: How many lightning strikes occur on Earth each day? Try to explain your answer. Your explanation should take the reader through your reasoning step-by-step.\nSoT\u2019s answer (OpenChat-13B) (Orange texts are the skeleton.) (Only showing the skeleton) 1.Introduction. 2. The Earth\u2019s atmosphere. 3. Lightning formation. 4. Electrical discharge. 5. Lightning strikes per second. 6. Calculating the total. Skeleton: 1. Introduction. Lightning is a beautiful and awe-inspiring natural phenomenon, but it can also be dangerous. It occurs when positively charged particles in a thundercloud discharge to the negatively charged Earth. The process is still not fully understood, but scientists have been able to estimate how many lightning strikes occur on Earth each day. Skeleton: 1. The Earth\u2019s atmosphere. The Earth\u2019s atmosphere plays a crucial role in the formation of lightning. It consists of different layers, with the troposphere being the lowest and most active. The troposphere is where most of the weather occurs, and it is where lightning primarily forms. The atmosphere\u2019s temperature, humidity, and wind patterns all contribute to the likelihood of a lightning strike. Skeleton: 2. Lightning formation.\nWhen warm, moist air rises, it cools and forms water <more texts are omitted...>\nFor both OpenChat-13B and Vicuna-7B V1.1, sometimes they do not write anything in the pointexpanding stage when details are needed.\nQuestion: As a superhero, how would you explain your origin story to a curious child?\nSoT\u2019s answer (Vicuna-7B V1.1) (Orange texts are the skeleton.) 1. Born with extraordinary abilities. 2. Trained to use powers for the greater good. 3. Protecting the innocent and fighting villains.I use my powers to defend the defenseless and bring justice to those who have been wronged.\n4. Inspired by courage, justice, and selflessness.\nThese two issues result in bad net win rates.\n(2) Claude. For strong models such as Claude, we do not see major issues with SoT\u2019s answers except the common issues across all models discussed in \u00a7 3.2.3. We hypothesize that the low net win rates are majorly due to the fact that their normal sequential generation is already very good.\nModels on which SoT has high net win rates. The models with high net win rates (Vicuna-13B V1.3, StableVicuna-13B, and UltraLM-13B) are between the above two extremes. On one hand, they are good enough to understand SoT prompts. While we observe that they sometimes have the same issues as OpenChat-13B and Vicuna-7B V1.1 discussed before, these issues happen much less frequently. On the other hand, their normal sequential generation performance has a larger room for improvement than Claude and ChatGPT-3.5 so that the benefits from SoT are more visible on these models."
        },
        {
            "heading": "I.1.2 ANSWER ANALYSIS: DIFFERENT QUESTION CATEGORIES",
            "text": ""
        },
        {
            "heading": "Categories on which SoT has low net win rates.",
            "text": "(1) Math. Math questions require step-by-step thinking. Without knowing the previous steps, it is hard to derive the following steps. Chain-of-Thoughts (Kojima et al., 2022; Wei et al., 2022) emphasize the importance of expanding the sequential thinking steps to solve these problems successfully. In contrast, SoT requires the models to (a) come up with the skeleton of the solution first and (b) deduce each individual step independently without referring to previous results. Both of these are challenging tasks. Strong models are able to get (a) correct but fail at (b). In the following example, ChatGPT-3.5 gets the skeleton steps correct. However, without knowing the results from the first step, the model starts making mistakes in the second step.7\n7One additional (minor) issue of the API-based ChatGPT-3.5 is that the skeleton point \u201c1.\u201d is repeated in the answer.\nQuestion: (Math) Solve for x in the equation 3x + 10 = 5(x - 2).\n7 SoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Move all x terms to one side. 1. Move all x terms to one side by subtracting 5x from both sides, giving -2x + 10 = -10. 2. Move all constant terms to the other side. This can be done by subtracting 5x - 10 from both sides, leaving 3x - 5x = -10 - 10. 3. Simplify the equation. Combine like terms on both sides of the equation to get 3x + 10 = 5x - 10. 4. Divide both sides by the coefficient of x. Divide both sides by 2 to get x = -5.\n5. Check the solution by plugging it back into the original equation.Substitute the value of x obtained in step 4 back into\nthe original equation and verify that both sides are equal.\n3 Normal answer (ChatGPT-3.5) 3x + 10 = 5(x - 2) can be simplified as follows: 3x + 10 = 5x - 10 (distribute the 5 on the right side) 10 + 10 = 5x - 3x (subtract 3x from both sides) 20 = 2x (combine like terms on the right side) x = 10 (divide both sides by 2)\nTherefore, the solution for x in the equation 3x + 10 = 5(x - 2) is x = 10.\nFor weaker models, it is hard to even get step (a) correct. For example, as shown below, the third step \u201cApply FOIL\u201d in Vicuna-13B V1.3\u2019s SoT solution comes out of nowhere. This makes SoT\u2019s solution incorrect (though the solution from the normal generation is also incorrect).\nQuestion: (Math) Solve for x in the equation 3x + 10 = 5(x - 2).\n7 SoT\u2019s answer (Vicuna-13B V1.3) (Orange texts are the skeleton.) 1. Simplify equation. We can simplify the equation by combining like terms: 3x + 10 = 5(x - 2) =\u00bf 3x + 10 = 5x - 10 =\u00bf x + 5 = 2 =\u00bf x = 2 - 5 =\u00bf x = -3 2. Factor 5(x - 2). 5(x - 2) = 5x - 10. 3. Apply FOIL. * Multiply the binomials in the equation, using the first term of each binomial for the first term of the product, the outside term for the second term of the product, the second term of each binomial for the third term of the product, and the remaining terms for the fourth term of the product. * 3(x - 2) + 10 = 5x + 5(-2) * 3x - 6 = 5x - 10 * 3x = 5x - 10 * x = 5x - 10 / 3 * x = 5/3x - 10/3 * x = 2/3x - 5/3 4. Solve for x.\nAfter applying the FOIL method and simplifying the equation, we get 3x = 17. Therefore, x = 17/3.\n7 Normal answer (Vicuna-13B V1.3) To solve for x in the equation 3x + 10 = 5(x - 2), we need to first distribute the 5 to multiply both sides by 5. 3x + 10 = 5(x - 2) 5(3x + 10) = 5(x - 2) 15x + 50 = 5x - 10 Add 5x to both sides: 20x + 50 = 5x Subtract 5x from both sides: 15x = 0 Divide both sides by 15: x = 0\nTherefore, the solution to the equation is x = 0.\n(2) Fermi. Similar to math questions, questions in the fermi category require solvers to make assumptions and calculate the answer step-by-step. For example, to answer the question in the figure below, the solver is required to make an assumption about when life began on Earth. In step 4, ChatGPT-3.5 does not know that it has already assumed 3.5 billion years in step 3 and uses the wrong number 4.54 billion in the calculation. In step 5, ChatGPT-3.5 does not know that it has already made the above assumptions and refuses to answer \u201cdue to the uncertainties in estimating the age of the Earth\u201d. In contrast, normal generation is able to create a consistent solution.\nQuestion: (Fermi) How many times has the Earth orbited the Sun since the beginning of life? Try to explain your answer. Your explanation should take the reader through your reasoning step-by-step.\n7 SoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Estimate the age of the Earth. The age of the Earth is estimated to be around 4.54 billion years, based on radiometric dating of rocks and meteorites. 2. Determine when life began on Earth. Life on Earth is estimated to have begun around 3.5 billion years ago, based on the discovery of ancient microfossils. 3. Calculate the number of years since life began. The oldest known fossils suggest that life on Earth began around 3.5 billion years ago. Therefore, the number of years since life began on Earth is approximately 3.5 billion years. 4. Divide the number of years by the length of one orbit. Assuming an orbital period of 365.25 days, the Earth has orbited the Sun approximately 4.54 billion / 365.25 = 12,425,000 times since the beginning of life.\n5. The Earth has orbited the Sun approximately X times since the beginning of life. Unfortunately, it is impossible to give\na specific number for the amount of times the Earth has orbited the Sun since the beginning of life due to the uncertainties\nin estimating the age of the Earth and when life first emerged.\nNormal answer (ChatGPT-3.5) The beginning of life on Earth is estimated to have occurred around 3.5 to 4 billion years ago. Since that time, the Earth has been orbiting the Sun continuously. The length of one orbit, or one year, is approximately 365.25 days. This means that the Earth completes one full orbit around the Sun every 365.25 days. To calculate the number of times the Earth has orbited the Sun since the beginning of life, we can divide the total number of days by the length of one orbit: Total number of days since the beginning of life = (3.5 billion years) x (365 days per year) = 1.2775 trillion days Number of orbits = (1.2775 trillion days) / (365.25 days per orbit) = 3.5 billion orbits\nTherefore, the Earth has orbited the Sun approximately 3.5 billion times since the beginning of life.\nAs the following example shows, there are also cases when SoT solves the question (with minor computation errors) by embedding the computation steps in the skeleton directly in the skeleton stage. The point-expanding stage will then add little content (except some undesired repetition of the following skeletons occasionally). This happens both on small/weak models and large/powerful models. Although this behavior is not what we originally expect, it sheds light on a promising direction for making SoT a general framework: in the problem where step-by-step thinking is needed, the SoT model automatically falls back to the sequential generation mode by outputting the complete answer in the skeleton stage and skipping the point-expanding stage. Future work needs to be done to control and encourage this behavior better.\nQuestion: (Fermi) How many times does the average human blink in a lifetime? Try to explain your answer. Your explanation should take the reader through your reasoning step-by-step.\nSoT\u2019s answer (Vicuna-7B V1.1) (Orange texts are the skeleton.) 1. The average human blinks 12-15 times per minute. 2. There are 60 minutes in an hour. 3. Therefore, the average human blinks 60 x 12-15 = 720-900 times per hour. 4. There are 24 hours in a day.Therefore, the average human blinks 720-900 x 24 = 17,520-22,400 times per day. 5. Therefore, the average human blinks 720-900 x 24 = 17,520-22,400 times per day.This translates to blinking approximately 50-65 times per hour, which is a significant portion of the day. 6. There are 365 days in a year.Therefore, the average human blinks 17,520-22,400 x 365 = 5,857,600-8,124,000 times per year. 7. Therefore, the average human blinks 17,520-22,400 x 365 = 5,857,600-8,124,000 times per year. 8. The human lifespan is typically 70-80 years.Therefore, the average human blinks 80,000-112,000 times in their lifetime.\n9. Therefore, the average human blinks 5,857,600-8,124,000 / 70-80 = 80,000-112,000 times in their lifetime.\nNormal answer (Vicuna-7B V1.1) The average human blinks about 12-15 times per minute, which translates to about 18,200 to 20,400 blinks per day. Over the course of a lifetime, the number of blinks is estimated to be around 7,500,000 to 8,000,000. Blinking is a reflexive action that helps to keep the eyes moist and comfortable, as well as to protect the eyes from dust and other foreign particles. The frequency of blinking can vary depending on a variety of factors, including age, health, and environmental conditions. For example, people who work in dusty or dry environments may blink more frequently than those who work in a clean, moist environment. Over the course of a lifetime, the average person will spend approximately 27,375 days or 700,000 hours awake. This means that the majority of the time spent blinking will occur in the first few decades of life, with the frequency of blinking gradually decreasing as people age.\nIt is important to note that there is a significant amount of individual variation in the frequency of blinking. Some people\nmay blink more or less than the average, depending on a variety of factors such as age, health, and environmental condi-\ntions. Additionally, blinking patterns can be affected by factors such as stress, fatigue, and certain medical conditions.\n(3) Coding. While in most cases, the models are able to decompose the coding problem into smaller tasks in the skeleton stage, the generation quality during the point-expanding stage is bad, potentially due to the fact that we did not carefully craft a special point-expanding prompt for coding. The failure cases can be grouped into two cases. (a) In some cases, the model only generates a description of how implementation can be done without giving the code.\nQuestion: (Coding) Develop a C++ program that reads a text file line by line and counts the number of occurrences of a specific word in the file.\nSoT\u2019s answer (Claude) (Orange texts are the skeleton.) 1. Open file stream by declaring an ifstream object and using the open() method to open the file in read mode. 2. Read line by line from the file stream into a string using getline(). 3. Find word by searching each line for the target word using string::find and keeping track of matches. 4. Increment counter by one each time the specified word is encountered in the current line. 5. Close file\nThe file stream should be closed after finishing reading the file to free up resources. This can be done by calling the\nclose() method on the file stream object.\nThis might be due to the fact that the powerful models (e.g., Claude) follow the point-expanding prompt \u201cWrite it **very shortly** in 1\u223c2 sentence\u201d precisely. Better prompts tailed to coding could help. (b) In some other cases, the model tends to generate the complete code repeatedly in several points.\nQuestion: (Coding) Develop a C++ program that reads a text file line by line and counts the number of occurrences of a specific word in the file.\nSoT\u2019s answer (OpenChat-13B) (Orange texts are the skeleton.) 1. Read file line by line. 2. Store lines in a container. 3. Count occurrences of specific word. \u201c\u2018cpp <more texts are omitted...> \u201c\u2018 This code uses the C++ standard library to read a text file line by line, store each line in a container, and count the occurrences of a specific word. The results are printed. 4. Print results. Here\u2019s the C++ program that reads a text file line by line and counts the number of occurrences of a specific word in the file: \u201c\u2018cpp <more texts are omitted...> \u201c\u2018\nPlease note that this is a very basic implementation. You may need to adjust it depending on your specific requirements.\nThis problem might also be alleviated by prompts that explicitly tell the model to only generate a \u201ccode snippet\u201d in each skeleton point.\nAlthough better prompt engineering could lead to better results, we expect that SoT is not suitable for the coding questions in Vicuna-80. The reason is that the solutions to the problems in Vicuna80 are usually in a few lines with strong dependencies between each other. Without knowing the previously defined variable names or imported libraries, it is hard (or even impossible) to implement the subsequent code correctly. As a consequence, generating different parts of the answers in parallel is not suitable here. Similar to the math questions, automatically falling back to outputting all the code in the skeleton stage and not triggering the point-expanding stage might be more suitable for answering this question type.\nHowever, we expect that SoT could be helpful for larger coding tasks that involve multiple modules (e.g., functions, classes). The skeleton stage could be in charge of defining the interfaces between different modules (e.g., functionalities, names, parameters, return types). The point-expanding stage could be in charge of implementing these modules or using these modules to complete the final task, which can be done in parallel. This mimics the common practice in software engineering.\n(4) Writing. The writing questions usually ask for an email, a blog post, or a review in a given scenario. In the detailed evaluation output from FastChat and LLMZoo metrics, the major and common complaint is that SoT\u2019s answers are (slightly) less detailed. This could potentially be improved by point-expanding prompts that request more details.\nWhile inspecting SoT\u2019s answers manually, we observe one additional issue. Writing problems usually require a coherent passage without embedded skeleton points, whereas our current SoT pipeline (\u00a7 2) concatenates skeleton points as part of the answer. One example is shown below.\nQuestion: (Writing) Can you help me write a formal email to a potential business partner proposing a joint venture?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Introduce yourself and your company. Dear [Recipient], I hope this email finds you well. My name is [Your Name] and I am the [Your Position] at [Your Company Name]. 2. State the purpose of the email. The purpose of this email is to propose a joint venture between our companies. 3. Explain the potential benefits of the joint venture. By combining our resources and expertise, we can increase market share and profitability for both companies. 4. Provide details on the proposed collaboration. Our proposed collaboration would involve combining our expertise in marketing with your strong manufacturing capabilities to create a new line of products. 5. Suggest a follow-up meeting or call. Please let me know your availability for a follow-up call next week to discuss this opportunity further.\n6. Thank the recipient for their time and consideration.Thank you for considering this proposal and we look forward to\nhearing back from you soon.\nNormal answer (ChatGPT-3.5) Of course, I can help you with that. Here\u2019s a sample email you can use as a guide: Subject: Proposal for Joint Venture Dear [Business Partner\u2019s Name], I hope this email finds you well. I am writing to propose a joint venture between our companies, [Your Company Name] and [Potential Partner Company Name]. We believe that our respective expertise can create a successful partnership that will benefit both of our businesses. We have conducted thorough research on your company and admire your innovative approach to [insert industry or niche]. We think our [insert expertise or specialty] could complement your [insert potential partner\u2019s specialty or expertise]. By collaborating on this joint venture, we believe we can create a new and innovative product that will appeal to our respective markets. We are confident that our companies would work well together and that our joint venture would be successful. We would like to set up a meeting to discuss the specifics of our proposal and explore how we can move forward with the joint venture. Thank you for considering this proposal. We look forward to hearing from you soon. Best regards,\n[Your Name]\nIn such cases, simply removing the skeleton points would greatly improve the answer quality. To make SoT more general, one future direction is to let the LLM itself decide whether the point index and point skeleton should be included to make the final answer more natural and fluent.\nCategories on which SoT has high net win rates.\n(1) Counterfactual, knowledge, common sense, generic. All these four categories have the same characteristic: the ideal answer should cover several relatively independent points. Having the LLM generate a skeleton before expanding the details can result in more comprehensive discussions for the question. Besides, organizing the answers as a list of points makes the answers easier to read, whereas the answers from normal generation are sometimes less structured and less readable. Below, we give one example for each question category to illustrate these points.\nQuestion: (Counterfactual) What if the Internet had been invented during the Renaissance period?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Advancements in communication.The invention of the Internet during the Renaissance period would have revolutionized communication, allowing for faster and more efficient exchange of ideas and information across vast distances. 2. Increased access to knowledge.The invention of the printing press during the Renaissance period already allowed for greater access to knowledge, but the internet would have revolutionized this even further by providing instantaneous access to information from all over the world. 3. Improved dissemination of ideas.If the internet had been invented during the Renaissance period, the spread of ideas and knowledge would have been much faster and widespread than it was at the time. This could have led to a faster progression of scientific and artistic innovations. 4. Impact on art and literature.The invention of the internet during the Renaissance period would have revolutionized the way art and literature are created, shared, and consumed, leading to a more diverse and globally-influenced artistic and literary scene. 5. Potential for global trade.The invention of the internet during the Renaissance period would have greatly expanded global trade opportunities, allowing for easier communication and collaboration between merchants and traders across continents.\n6. Influence on political and social structures.The invention of the internet during the Renaissance period could have led\nto significant changes in political and social structures, allowing for greater democratization and communication among\npeople from different regions and classes.\nNormal answer (ChatGPT-3.5) If the Internet had been invented during the Renaissance period, it would have had a significant impact on the way people communicated, shared ideas, and gained knowledge. The Renaissance was a time of great intellectual and artistic growth, and the Internet would have facilitated the spread of these ideas and innovations. Scholars and artists would have been able to share their work more easily, and people from different parts of the world would have been able to connect and collaborate more easily. The Internet would have also made it easier to access information, which could have accelerated the pace of scientific and technological advancements.\nHowever, it\u2019s important to note that the infrastructure required for the Internet to exist did not exist during the Renaissance\nperiod. There were no telecommunications networks or electricity grids, so the idea of the Internet would have been\nimpossible to realize. Nonetheless, it\u2019s interesting to think about how the Renaissance might have been different if the\nInternet had existed at that time.\nQuestion: (Knowledge) What are some potential implications of using a single-use plastic bottle versus a reusable bottle on both the environment and human health?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Single-use plastic waste.Single-use plastic bottles contribute to the massive amount of plastic waste that ends up in landfills and oceans, harming wildlife and ecosystems. 2. Pollution of waterways.Single-use plastic bottles contribute to the pollution of waterways, as they often end up in rivers, lakes, and oceans, causing harm to aquatic life and the overall ecosystem. 3. Harmful chemicals leaching.Single-use plastic bottles may release harmful chemicals such as bisphenol A (BPA) and phthalates into the water or liquid they contain, posing a risk to human health. 4. Greenhouse gas emissions.The production and disposal of single-use plastic bottles contribute to greenhouse gas emissions, which contribute to climate change. Using a reusable bottle reduces the need for constant production and disposal, therefore reducing greenhouse gas emissions. 5. Microplastic ingestion.Single-use plastic bottles contribute to the accumulation of microplastics in the environment, which can be ingested by humans through food and water, leading to potential health risks.\n6. Increased risk of disease.Single-use plastic bottles can harbor harmful bacteria, leading to an increased risk of disease\nif not disposed of properly. Reusable bottles, when cleaned regularly, pose a lower risk.\nNormal answer (ChatGPT-3.5) Using a single-use plastic bottle has significant implications on the environment and human health. Environmental implications: 1. Plastic pollution: Single-use plastic bottles are one of the major contributors to plastic pollution in oceans and landfills. They take hundreds of years to decompose, and during that time, they release toxic chemicals and microplastics into the environment. 2. Carbon emissions: Manufacturing and transporting single-use plastic bottles require a significant amount of energy and resources, which contribute to greenhouse gas emissions and climate change. 3. Natural resource depletion: The production of single-use plastic bottles requires large amounts of water and oil, which are finite resources. Health implications: 1. Chemical exposure: Single-use plastic bottles contain chemicals such as Bisphenol A (BPA) and phthalates, which can leach into the water and pose a risk to human health. 2. Microplastics ingestion: When plastic bottles break down, they release microplastics, which can enter the food chain and be ingested by humans. Using a reusable bottle, on the other hand, has a positive impact on the environment and human health. Environmental benefits: 1. Reduced plastic waste: Reusable bottles significantly reduce the amount of plastic waste generated. 2. Lower carbon emissions: Reusable bottles have a lower carbon footprint as they can be used multiple times. 3. Reduced resource depletion: The production of reusable bottles requires fewer resources than single-use plastic bottles. Health benefits: 1. Chemical-free: Reusable bottles are typically made from materials that are free from harmful chemicals, reducing the risk of chemical exposure. 2. Reduced microplastics: Reusable bottles do not break down easily, reducing the release of microplastics into the environment.\nOverall, using a reusable bottle is a more sustainable and healthier option than using a single-use plastic bottle.\nQuestion: (Common sense) How can you determine if a person is genuinely interested in a conversation or simply being polite?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Pay attention to body language.Notice if their posture is open or closed, if they are facing towards you or away, and if they are fidgeting or relaxed. These can all indicate their level of interest in the conversation. 2. Listen for engaged responses.If the person is genuinely interested in the conversation, they will respond with thoughtful and relevant comments or questions rather than short, generic responses. 3. Observe eye contact.If the person maintains steady eye contact and their gaze is focused on you, they are likely genuinely interested in the conversation. On the other hand, if they frequently look away or seem distracted, they may just be being polite. 4. Look for follow-up questions.If the person asks follow-up questions and seems genuinely interested in what you\u2019re saying, then they are likely interested in the conversation and not just being polite.\n5. Notice tone of voice.A person who is genuinely interested in a conversation will often have a more enthusiastic and\nanimated tone of voice, compared to someone who is simply being polite and giving short, monotone responses.\nNormal answer (ChatGPT-3.5) As an AI assistant, I cannot determine a person\u2019s true intentions or feelings. However, there are some social cues that\ncan indicate whether a person is genuinely interested in a conversation or not. For example, if they maintain eye contact,\nlean in, nod their head and ask follow-up questions, it can be a sign that they are engaged in the conversation. On the\nother hand, if they avoid eye contact, give short or vague responses, or seem distracted, it may indicate that they are\nnot as interested. Ultimately, it\u2019s important to remember that everyone has different communication styles, and it can be\ndifficult to accurately interpret someone\u2019s intentions without directly asking them.\nQuestion: (Generic) How can I improve my time management skills?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Set clear goals. Setting clear goals is important in improving time management skills as it helps you to focus on what needs to be done and what can be accomplished within a certain timeframe. 2. Prioritize tasks. Make a list of tasks and prioritize them based on their importance and deadline. This will help you focus on the most critical tasks and avoid wasting time on less important ones. 3. Create a schedule. Creating a schedule helps you allocate time for each task and ensures that you complete them within the allotted time. 4. Minimize distractions. Distractions such as social media, emails, and phone notifications can waste a lot of time. Try to limit them by turning off notifications or setting specific times to check them. 5. Take breaks. Taking breaks can actually improve productivity and help prevent burnout. It\u2019s important to schedule short breaks throughout the day to recharge and refocus. 6. Learn to say no. It\u2019s important to prioritize your own tasks and not take on too much at once. Saying no to requests that don\u2019t align with your goals or schedule can help you manage your time more effectively. 7. Delegate tasks. If you have too many tasks to handle, consider delegating some of them to others who can help you. This will allow you to focus on more important tasks and manage your time more effectively.\n8. Use time management tools.There are a variety of time management tools available, such as calendars, to-do lists, and\nproductivity apps, that can help you stay organized and on track with your tasks.\nNormal answer (ChatGPT-3.5) Improving time management skills can be a challenge, but there are several strategies that can help. Here are a few: 1. Set clear goals and priorities: Identify your most important tasks and make sure to complete them first. 2. Make a schedule: Create a schedule that includes your most important tasks and set aside time for them. 3. Use a timer: Set a timer for a specific amount of time to help you stay focused and avoid distractions. 4. Take breaks: Take short breaks throughout the day to help you recharge and avoid burnout. 5. Eliminate distractions: Try to limit distractions as much as possible, such as by turning off your phone or closing your email. 6. Delegate tasks: If possible, delegate tasks to others to free up time for more important activities.\nRemember, improving time management skills takes practice and perseverance. Be patient with yourself and keep trying\nuntil you find strategies that work well for you.\n(2) Roleplay. Roleplay questions require LLMs to assume a character and present an introduction or speech to other people. LLMZoo and FastChat metrics usually favor the level of details of SoT when assigning it a better score. Similar to the writing category discussed before, SoT\u2019s answers could be even better if the skeleton points are removed from the answer.\nQuestion: (Roleplay) How would you introduce yourself as a medieval knight at a royal banquet?\nSoT\u2019s answer (Claude) (Orange texts are the skeleton.) 1. Name and house. My name is Sir Percival of Camelot, knight of the Round Table and protector of King Arthur\u2019s realm. 2. Lands and titles. I hold fiefdom over the lands of Westmarch and Ravenshire, and bear the titles of Baron of the Western Marches and Knight of the Raven. 3. Military feats. I have led my men to great victories against the kingdom\u2019s enemies, winning many battles through strength of arms and tactical cunning. 4. Allegiance to king. I pledge my sword, my loyalty, and my life to serve and protect my noble king and this great kingdom.\n5. Request to join table. Your Highness, it would be the greatest honor to join your exalted table and share in this\nmagnificent feast with my fellow knights and loyal subjects.\nNormal answer (Claude) Greetings, your majesty and honored guests. I am Sir Claude, a knight in service of the king. I hail from the province\nof Assistantia, where I was trained in the knightly virtues of chivalry, courage and courtesy. Though I am but a humble\nknight, I shall endeavor to serve you and this kingdom with all the strength and valor I possess. I thank you for allowing\nme to join you at this royal feast, and hope only that my conduct brings further honor to my liege and this noble court.\nPlease let me know if I can be of any service during the celebrations, as it would be my honor to assist you in any way."
        },
        {
            "heading": "I.1.3 ANSWER ANALYSIS: DIFFERENT METRICS",
            "text": ""
        },
        {
            "heading": "Metrics on which SoT has low net win rates.",
            "text": "(1) Coherence. In the prompt of LLMZoo evaluation, coherence is defined as \u201cThe response should be coherent and flow logically from one point to the next that is easy to read and understand without major gaps or inconsistencies. The more coherent they are, the better.\u201d SoT\u2019s answer is structured in a list of points. It is suitable for some questions but not all. For example, in the questions that require\nLLMs to write a passage, email, or script, the introduction and conclusion paragraphs are usually missing, and the answers usually lack transition sentences between consecutive points. These make the answers less coherent. Below is one example from Claude.\nQuestion: Write a script for a YouTube video exploring the history and cultural significance of jazz.\nSoT\u2019s answer (Claude) (Orange texts are the skeleton.) 1. Origins. Jazz originated in the late 19th and early 20th centuries among African Americans in New Orleans, emerging from a combination of African rhythmic traditions, blues, ragtime, and other influences. 2. Early jazz styles. The early styles of jazz that emerged in the late 19th and early 20th centuries included ragtime, Dixieland, and the blues. 3. Jazz age. The Jazz Age was the period during the 1920s when jazz music and dance styles like the Charleston became popular cultural phenomena in American and European society. 4. Bebop era. Bebop emerged in the early 1940s with artists like Dizzy Gillespie and Charlie Parker experimenting with faster tempos, complex chord changes, and unpredictable melodic phrasing. 5. Cool jazz. Emerging in the late 1940s and early 1950s, cool jazz was a more subdued, mellow style that broke from the high-energy virtuosic improvisation of bebop. 6. Free jazz emerged in the late 1950s and 1960s as musicians explored free improvisation and atonality, moving away from traditional jazz structures. 7. Fusion jazz. Major jazz artists such as Miles Davis and Herbie Hancock began experimenting with combining elements of rock, funk, and electronic music in the 1970s, resulting in the emergence of the subgenre known as fusion jazz. 8. Jazz festivals. Jazz festivals emerged in the 1950s and 1960s as a way to celebrate jazz music, with famous early festivals like the Newport Jazz Festival bringing thousands of fans together to hear top performers. 9. Jazz instruments. The trumpet, saxophone, piano, double bass, and drum set are some of the key instruments commonly used in jazz. 10. Influential musicians include Louis Armstrong, Duke Ellington, Charlie Parker, Miles Davis, John Coltrane, and many others who pioneered new styles and techniques.\n11. Legacy and impact. Jazz has left an indelible mark on music and culture over the past century, influencing countless\nartists and genres while spreading the spirit of improvisation and freedom across the globe.\nNormal answer (Claude) Here is a draft script for a YouTube video exploring the history and cultural significance of jazz: Introduction Hey everyone! Welcome to my channel. In today\u2019s video, we\u2019re going to be exploring the history and cultural impact of one of America\u2019s original art forms - jazz music. Jazz Origins Jazz grew out of the African American communities in the southern United States in the late 19th and early 20th centuries. It was influenced by a combination of African and European musical traditions. Some key elements that fed into early jazz included blues, ragtime, spirituals, work songs, field hollers, and brass band music. New Orleans is considered the birthplace of jazz, emerging around the turn of the 20th century. The city was a melting pot of cultures and musical styles. Musicians mixed improvisation, syncopated rhythms, bent notes and a loose ensemble playing style to create a new genre that became known as jazz. Early jazz greats like Buddy Bolden, Jelly Roll Morton and Sidney Bechet began fusing these various influences into the distinct jazz sound. As the music spread via travel and recordings in the 1910s, jazz captivated listeners and began to evolve into different styles. Jazz Styles Emerge In the 1920s, jazz expanded out from New Orleans and Chicago emerged as a hotspot. Louis Armstrong\u2019s innovative solos and expressive phrasing became influential. The swing style also developed during the 1930s and 40s, propelled by star big bands and dancers. Bebop arose in the 1940s with soloists like Charlie Parker and Dizzy Gillespie exploring new levels of harmonic and rhythmic complexity. In the 50s and 60s, jazz expanded into new fusions like cool jazz, hard bop, free jazz, modal jazz and soul jazz. Artists used jazz to express their unique regional, social and political identities. Cultural Significance Over the decades, jazz has become woven into the fabric of American society. It is equated with many values and ideals like individualism, freedom, spontaneity, innovation and social harmony. Jazz was associated with breaking down barriers between races, classes and genres. It represented modernism and urban culture. Musicians like Louis Armstrong and Duke Ellington became some of the first widely popular African American artists. Jazz also spread American culture and values abroad through performances, radio and film. It influenced music around the world and became a truly global art form. Today jazz continues to thrive and evolve both in the U.S. and internationally. Its history and sounds reflect the diversity of both American and global cultures. From its folk roots, jazz has become a sophisticated art music that retains its spirit of freedom and improvisation. Conclusion\nThat covers some of the key points in the history and cultural impact of jazz music. Let me know in the comments about\nyour favorite jazz styles and musicians! Be sure to like and subscribe. See you next time.\nWhile the content of SoT\u2019s answer is good, it reads less fluent for the purpose of a YouTube script.\n(2) Immersion. In the prompt of LLMZoo evaluation, immersion is defined as \u201cthe response should act like the assigned role using the tone, manner, and vocabulary the role would use. The more assistant-like tones, the worse. The more in-character, the better.\u201d The way that SoT breaks the\nanswers into a list makes its answer less in-character. Therefore, SoT receives a lower immersion score. Here is one example.\nQuestion: Pretend to be a world-famous chef. How would you describe your signature dish to a panel of judges?\nSoT\u2019s answer (Claude) (Orange texts are the skeleton.) 1. Main ingredient: The incredibly fresh and tender salmon caught just this morning from the crystal clear waters of the Pacific Northwest. 2. Cooking method I slowly braise the main ingredient in a rich broth to bring out its natural flavors before searing it to a perfect golden crust. 3. Special seasoning The dish is seasoned with a blend of fresh herbs like thyme, rosemary, and oregano which provides an aromatic backbone that pairs nicely with the natural flavors of the main ingredients. I add just a touch of smoked paprika to provide a subtle smokiness without overpowering the other flavors. 4. Texture: The dish has a perfect balance of crispy on the outside and tender on the inside, with each bite yielding a delightful mix of crunchy and smooth textures that dance across your tongue. 5. Plating presentation I purposefully create height and dimension on the plate with the carefully arranged components of the dish, so that the dish appears vibrant and alive. The interplay of colors, textures and shapes is intended to delight the eye before the first bite.\n6. Inspiration: This dish was inspired by my dear grandmother, who taught me the secret family recipe when I was just\na child.\nNormal answer (Claude) *clears throat and speaks in a fancy French accent* Bonjour honored judges. Today I present to you my signature dish - la cre\u0300me de la cre\u0300me of French haute cuisine. Behold, le poulet a\u0300 la Claude! This succulent chicken is firstly marinated overnight in a bath of fine herbes - thyme, rosemary, and sage cultivated from my private garden. The young spring chicken is then roasted to perfection, its skin crisping to a beautiful caramel brown. Nestled beside the chicken is a tower of pommes dauphine - light and airy potato puffs - alongside a decadent mound of cre\u0300me fra\u0131\u0302che infused with truffle essence. But the pie\u0300ce de re\u0301sistance is the sauce. A luxurious pool of veloute\u0301 enriched with cream and butter, brightened with a dash of lemon, and studded with morsels of morel mushrooms foraged at dawn. One bite of this ensemble will transport you to food heaven. The tender chicken, the creaminess of the potato puffs, and the rich decadence of the sauce meld together in blissful harmony.\nSo tell me honored judges, will my poulet a\u0300 la Claude earn your coveted approval? I await your discerning verdict as I\nswirl more vintage Bordeaux into your glasses. Sante\u0301!\nAgain, while the answer from SoT covers sufficient aspects and details, it reads rather stiffly. The normal answer, in contrast, has the opening sentence \u201dBonjour honored judges. Today I present to you my signature dish...\u201d and the conclusion statement \u201dSo tell me honored judges, will my poulet a\u0300 la Claude earn your coveted approval? ...\u201d which reads more like a casual talk from a chef.\nMetrics on which SoT has high net win rates.\n(1) Diversity. In the prompt of LLMZoo evaluation, diversity is defined as \u201cThe response should be comprehensive and provide a range of information that is not limited to a single perspective. More perspectives are better.\u201d The skeleton stage in SoT encourages LLMs to think from multiple perspectives. Therefore, SoT\u2019s answers tend to have better diversity. Below is one example showing that SoT\u2019s answer has better diversity.\nQuestion: How can you determine if a person is genuinely interested in a conversation or simply being polite?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Pay attention to body language.Notice if their posture is open or closed, if they are facing towards you or away, and if they are fidgeting or relaxed. These can all indicate their level of interest in the conversation. 2. Listen for engaged responses.If the person is genuinely interested in the conversation, they will respond with thoughtful and relevant comments or questions rather than short, generic responses. 3. Observe eye contact.If the person maintains steady eye contact and their gaze is focused on you, they are likely genuinely interested in the conversation. On the other hand, if they frequently look away or seem distracted, they may just be being polite. 4. Look for follow-up questions.If the person asks follow-up questions and seems genuinely interested in what you\u2019re saying, then they are likely interested in the conversation and not just being polite.\n5. Notice tone of voice.A person who is genuinely interested in a conversation will often have a more enthusiastic and\nanimated tone of voice, compared to someone who is simply being polite and giving short, monotone responses.\nNormal answer (ChatGPT-3.5) As an AI assistant, I cannot determine a person\u2019s true intentions or feelings. However, there are some social cues that\ncan indicate whether a person is genuinely interested in a conversation or not. For example, if they maintain eye contact,\nlean in, nod their head and ask follow-up questions, it can be a sign that they are engaged in the conversation. On the\nother hand, if they avoid eye contact, give short or vague responses, or seem distracted, it may indicate that they are\nnot as interested. Ultimately, it\u2019s important to remember that everyone has different communication styles, and it can be\ndifficult to accurately interpret someone\u2019s intentions without directly asking them.\nSoT answers the question from five aspects, whereas the normal answer only mentions one aspect.\n(2) Relevance. In the prompt of LLMZoo evaluation, relevance is defined as \u201cThe response should be closely related to the question and answer the question accurately with sufficient details without repetition or redundancy. The more relevant they are, the better.\u201d In the skeleton stage, LLMs are forced to propose several points around the question; and in the point-expanding stage, LLMs are required to only discuss these points. Therefore, answers from SoT tend to have better relevance. One typical example is shown below.\nQuestion: Why do some people enjoy the sensation of being scared, such as by watching horror movies or going on roller coasters, while others avoid these experiences?\nSoT\u2019s answer (ChatGPT-3.5) (Orange texts are the skeleton.) 1. Neurological differences.Some people enjoy the sensation of being scared due to the release of adrenaline and dopamine in the brain, while others may have a lower threshold for fear due to differences in their amygdala and prefrontal cortex. 2. Psychological factors.Some people may enjoy the sensation of being scared because it can provide a sense of excitement, thrill, and a temporary escape from the mundane aspects of everyday life. On the other hand, others may avoid these experiences due to past trauma or anxiety. 3. Developmental experiences.Individuals who had negative experiences with fear during childhood, such as trauma or abuse, may avoid scary situations as adults, while those who had positive experiences with fear may seek out these experiences. 4. Cultural influences.Some cultures place a greater emphasis on seeking excitement and thrill, while others may prioritize safety and security, which can impact whether individuals enjoy scary experiences or avoid them.\n5. Genetics.Research has suggested that some individuals may have a genetic predisposition towards seeking out thrilling\nor risky experiences, which may include enjoying the sensation of being scared.\nNormal answer (ChatGPT-3.5) The enjoyment of being scared is a complex psychological phenomenon. Some people may enjoy the adrenaline rush\nthat comes with being scared, while others may enjoy the feeling of being able to conquer their fears. Additionally,\nsome people may be more naturally inclined to seek out new experiences and sensations, including those that are scary\nor thrilling. On the other hand, some people may be more risk-averse or may have had negative experiences with fear or\nanxiety in the past, which could make them more likely to avoid scary experiences. Ultimately, the reasons why some\npeople enjoy being scared while others do not are likely to be influenced by a range of factors, including personality, past\nexperiences, and individual preferences.\nIn the answer from the normal generation, the first two sentences provide little information in answering the question, and the last sentence only gives keywords such as \u201cpersonality, past experiences, and individual preferences\u201d without providing concrete explanations to each. In contrast,\nSoT\u2019s answer is well-structured into five reasons with sufficient explanations and it does not waste space in irrelevant contents."
        },
        {
            "heading": "I.1.4 QUALITY BREAKDOWN: QUESTION CATEGORIES AND MODELS",
            "text": "In the main text, we analyze how question categories and models affect SoT\u2019s answer quality. Here, Fig. 22 show the per-model and per-category results."
        },
        {
            "heading": "I.2 SKELETON-OF-THOUGHT WITH ROUTER",
            "text": "Fig. 23 shows net win rates of SoT on Vicuna-80 dataset with LLMZoo metrics, and Fig. 24 shows net win rates of SoT on WizardLM dataset with FastChat metrics. The key takeaways are: (1) In both cases, SoT-R achieves similar or better quality than SoT, and the net win rates of SoT-R are usually non-negative. This indicates that SoT-R falls back to normal decoding on the right question categories. (2) On the WizardLM dataset, we see that the trained router has better performance than the prompting router in most cases. This is reasonable, as the prompting router is limited by the capability of GPT-4, whereas the trained router is dedicated to this task. (3) Sometimes, our routers can even achieve better performance than humans.\nFig. 1(b) in the main text has showed SoT\u2019s quality and speed-up plot evaluated with the FastChat quality metric, here, Fig. 25 shows the results evaluated with the LLMZoo quality metric."
        },
        {
            "heading": "I.3 QUALITY COMPARISON WITH LONGER NORMAL ANSWER",
            "text": "When assessing the answer quality, the GPT-4 judge might exhibit bias towards longer responses. To take this factor into consideration, we add a comparison between a longer sequentially generated answer and the SoT generated answer. Specifically, we add a instruction prefix to the prompt for normal generation. The prefix is \u201cPlease give a slightly long answer for the following question.\u201d and \u201cPlease give a long answer for the following question.\u201d for ChatGPT-3.5 and LLaMA2-Chat7B, respectively. Fig. 27 shows the ratios of the length of SoT answers to normal answers, and Fig. 26 shows the quality comparison. We can see that for both models, when the overall answer lengths are similar, the quality of the SoT answer is comparable to that of the long normal answer."
        },
        {
            "heading": "I.4 CHATGPT-3.5 AS THE JUDGE",
            "text": "In this section, we provide quality evaluation results with ChatGPT-3.5 as the judge in FastChat and LLMZoo metrics. Note that as prior work (e.g., (Li et al., 2023b)) shows, GPT-4-based evaluation usually aligns with human better than ChatGPT-3.5. Therefore, readers should refer to the results in the main paper (with GPT-4 as the judge) for a more accurate view of the performance of SoT. However, the takeaway messages from ChatGPT-3.5 are similar to the ones from GPT-4."
        },
        {
            "heading": "I.4.1 OVERALL QUALITY",
            "text": "In Fig. 28, we show the win/tie/lose rates (the percentage of the cases when SoT wins/ties/loses compared to normal generation) across all models and questions using the two metrics from FastChat and LLMZoo that capture the general quality of the answers. We notice a discrepancy between the two metrics on when SoT is strictly better than the baseline (50.2% v.s. 12.4%). Despite that, the two metrics agree that SoT is not worse than the baseline in more than 76% of the cases. For FastChat metric, we also show the rates excluding math and coding questions that SoT is not suitable for (see \u00a7 3.2.3); SoT is not worse than the baseline in more than 89% of the cases. This result suggests that the answers of SoT maintain good quality."
        },
        {
            "heading": "I.4.2 QUALITY BREAKDOWN: QUESTION CATEGORIES",
            "text": "Next, we investigate how SoT performs on different question categories. We compute net win rates (win rates minus lose rates) across all question categories in Fig. 29. Similar to Fig. 28, we see that LLMZoo tends to be more optimistic about the quality of SoT than FastChat. Nevertheless, the conclusions are consistent: SoT performs relatively well on generic, common-sense, knowledge, roleplay, and counterfactual. SoT performs relatively badly on writing, fermi, math, and coding."
        },
        {
            "heading": "I.4.3 QUALITY BREAKDOWN: MODELS",
            "text": "Next, we investigate how SoT performs on different models. We compute net win rates across all models in Fig. 30. Again, we see that the two general metrics from FastChat and LLMZoo have different absolute values but similar rankings. In particular, both metrics agree that OpenChat13B, Vicuna-7B V1.1, Claude, ChatGPT-3.5 have low net win rates, whereas Vicuna-13B V1.3, StableVicuna-13B, and UltraLM-13B have high net win rates."
        },
        {
            "heading": "I.4.4 QUALITY BREAKDOWN: QUESTION CATEGORIES AND MODELS",
            "text": "In the main text, we analyze how question categories and models affect SoT\u2019s answer quality. Here, we show the per-model and per-category results. For each model and question category, we compute the net win rates. The results are in Fig. 31."
        },
        {
            "heading": "I.4.5 QUALITY BREAKDOWN: METRICS",
            "text": "All previous evaluations use metrics about the general quality of the answer. In Fig. 32, we show more detailed metrics from LLMZoo to reveal in which aspects SoT can improve or hurt the answer quality. On average, we can see that SoT improves the diversity and relevance while hurting the immersion and coherence."
        },
        {
            "heading": "J COMBINING SOT-R WITH MODEL QUANTIZATION",
            "text": "Model quantization is a widely-used model-level optimization to accelerate LLM inference, which is orthogonal to SoT. In this section, we evaluate the speed-ups of open-source models with both\nquantization and SoT on the Vicuna-80 dataset. Specifically, we adopt GPTQ (Frantar et al., 2022)8 to apply 4-bit weight-only quantization and use SoT-R instead of plain SoT."
        },
        {
            "heading": "J.1 SPEED-UPS OF SOT + QUANTIZATION ON QUANTIZED MODELS",
            "text": "We first compare the latency of the quantized models in the normal and SoT modes to evaluate how much SoT can speed up quantized models. Fig. 33 shows the speed-ups of SoT-R on different quantized models. SoT-R obtain 1.08\u00d7 to 1.99\u00d7 speed-ups on all the models. Fig. 34 shows the speed-ups of SoT-R on different categories. We can see that on the five question categories for which SoT can provide high-quality answers (i.e., knowledge, generic, common-sense, roleplay, counterfactual), SoT-R can speed up the overall answer generation process by 1.07\u00d7 to 2.38\u00d7."
        },
        {
            "heading": "J.2 SPEED-UPS OF SOT + QUANTIZATION ON UNQUANTIZED MODELS",
            "text": "Here, we report the overall speed-ups of the quantization model with SoT-R generation w.r.t. the unquantized model with normal generation. Fig. 35 shows the speed-ups of SoT-R on different models. SoT-R can obtain 1.54\u00d7 to 2.07\u00d7 speed-ups. Fig. 36 shows the speed-ups of SoT-R on different categories. On the five question categories for which SoT can provide high-quality answers (i.e., knowledge, generic, common-sense, roleplay, counterfactual), SoT-R can speed up the generation by 1.33\u00d7 to 3.41\u00d7 with the prompting and trained routers.\n8https://github.com/qwopqwop200/GPTQ-for-LLaMa\nmath coding fermi\nwriting roleplay\ncounterfactual knowledge\ncommon-sense generic\n0.92\u00d7 0.96\u00d7 1.05\u00d7 1.18\u00d7\n1.33\u00d7 2.36\u00d7\n2.53\u00d7 2.76\u00d7\n3.07\u00d7\nmath writing fermi\ncoding roleplay\ncounterfactual knowledge\ncommon-sense generic\n1.00\u00d7 1.00\u00d7 1.00\u00d7 1.00\u00d7\n1.49\u00d7 2.42\u00d7 2.45\u00d7\n2.82\u00d7 3.41\u00d7"
        },
        {
            "heading": "K ADDITIONAL SOT-R STATISTICS",
            "text": ""
        },
        {
            "heading": "K.1 NUMBER OF SUITABLE QUESTIONS",
            "text": "Overall, there are 37/80, 58/218, 371/1030 questions that are suitable for SoT in the Vicuna-80, WizardLM, and LIMA datasets (according to human assessment), respectively.\nFig. 37 shows the number of questions that are suitable for SoT on Vicuna-80. On counterfactual, commen-sense, knowledge, generic categories, most questions are suitable for SoT based on the human assessment. The trained router and prompting router give out similar judgments."
        },
        {
            "heading": "K.2 PEAK MEMORY OVERHEAD",
            "text": "Fig. 38 and Fig. 39 show the peak memory overhead of SoT-R (with prompting router) on different models and different categories, respectively, on the Vicuna-80 dataset. We can see that, on all models and categories, the overhead of peak memory is quite small (<1.11\u00d7).\n0 10 20 30 40 50 60 70 80 Peak memory (GiB)\ngeneric knowledge\nroleplay common-sense\nfermi counterfactual\ncoding math\nwriting\n1.05\u00d7 1.04\u00d7 1.01\u00d7 1.05\u00d7\n1.01\u00d7 1.04\u00d7\n1.00\u00d7 1.00\u00d7 1.01\u00d7 Normal (prefill) SoT (prefill)\n(a) Peak memory in the prefilling phase.\n0 10 20 30 40 50 60 70 80 Peak memory (GiB)\ngeneric knowledge\nroleplay common-sense\nfermi counterfactual\ncoding math\nwriting\n1.11\u00d7 1.09\u00d7\n1.03\u00d7 1.10\u00d7\n1.02\u00d7 1.10\u00d7\n1.00\u00d7 1.00\u00d7 1.01\u00d7 Normal (decode) SoT (decode)\n(b) Peak memory in the decoding phase.\nFigure 39: Peak memory overhead of SoT-R on different question categories of Vicuna-80."
        },
        {
            "heading": "K.3 SPEED-UPS WITH DIFFERENT NUMBER OF POINTS",
            "text": "Fig. 40 shows the speed-ups with different numbers of points on Vicuna-80. To maintain clarity in the figure, we\u2019ve chosen to display statistics for only three models. Note that as SoT cannot control the overall length to be the same as that of normal generation, it is not the case that a higher number of points leads to higher speed-ups."
        },
        {
            "heading": "L NOTES ON APPLICATION SCENARIOS",
            "text": "In a chatbot application, one might wonder why a reduced end-to-end latency can enhance the user experience. While human reading speeds are limited, there are many situations where we do not read responses sequentially. Rather than reading the entire answer, one might prefer to (1) swiftly check the response\u2019s structure to confirm if the chatbot comprehended the question or (2) extract specific information rapidly without waiting for the generation of prologue or preceding points. Besides, from the quality aspect, even if we would like to check the entire answer, a well-defined structure in responses assists us in quickly parsing all the information.\nMoreover, beyond enhancing user experience, reduced end-to-end latency can significantly benefit emerging application scenarios like agent-agent interaction."
        }
    ],
    "title": "SKELETON-OF-THOUGHT: PROMPTING LLMS FOR EFFICIENT PARALLEL GENERATION",
    "year": 2024
}