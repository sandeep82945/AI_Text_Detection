{
    "abstractText": "Language models have outpaced our ability to evaluate them effectively, but for their future development it is essential to study the frontier of their capabilities. We find real-world software engineering to be a rich, sustainable, and challenging testbed for evaluating the next generation of language models. To this end, we introduce SWE-bench, an evaluation framework consisting of 2,294 software engineering problems drawn from real GitHub issues and corresponding pull requests across 12 popular Python repositories. Given a codebase along with a description of an issue to be resolved, a language model is tasked with editing the codebase to address the issue. Resolving issues in SWE-bench frequently requires understanding and coordinating changes across multiple functions, classes, and even files simultaneously, calling for models to interact with execution environments, process extremely long contexts and perform complex reasoning that goes far beyond traditional code generation tasks. Our evaluations show that both state-ofthe-art proprietary models and our fine-tuned model SWE-Llama can resolve only the simplest issues. The best-performing model, Claude 2, is able to solve a mere 1.96% of the issues. Advances on SWE-bench represent steps towards LMs that are more practical, intelligent, and autonomous.",
    "authors": [
        {
            "affiliations": [],
            "name": "Carlos E. Jimenez"
        },
        {
            "affiliations": [],
            "name": "John Yang"
        },
        {
            "affiliations": [],
            "name": "Alexander Wettig"
        },
        {
            "affiliations": [],
            "name": "Shunyu Yao"
        },
        {
            "affiliations": [],
            "name": "Kexin Pei"
        },
        {
            "affiliations": [],
            "name": "Ofir Press"
        },
        {
            "affiliations": [],
            "name": "Karthik Narasimhan"
        }
    ],
    "id": "SP:2343948fd0d595eeee317a6d91f362b630202fff",
    "references": [
        {
            "authors": [
                "Miltiadis Allamanis",
                "Marc Brockschmidt",
                "Mahmoud Khademi"
            ],
            "title": "Learning to represent programs with graphs",
            "venue": "arXiv preprint arXiv:1711.00740,",
            "year": 2017
        },
        {
            "authors": [
                "Ben Athiwaratkun",
                "Sanjay Krishna Gouda",
                "Zijian Wang",
                "Xiaopeng Li",
                "Yuchen Tian et. al"
            ],
            "title": "Multilingual evaluation of code generation models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Jacob Austin",
                "Augustus Odena",
                "Maxwell Nye",
                "Maarten Bosma",
                "Henryk Michalewski",
                "David Dohan",
                "Ellen Jiang",
                "Carrie Cai",
                "Michael Terry",
                "Quoc Le",
                "Charles Sutton"
            ],
            "title": "Program synthesis with large language models, 2021",
            "year": 2021
        },
        {
            "authors": [
                "Samuel R. Bowman",
                "George E. Dahl"
            ],
            "title": "What will it take to fix benchmarking in natural language understanding",
            "year": 2021
        },
        {
            "authors": [
                "Federico Cassano",
                "John Gouwar",
                "Daniel Nguyen",
                "Sydney Nguyen",
                "Luna Phipps-Costin",
                "Donald Pinckney",
                "Ming-Ho Yee",
                "Yangtian Zi",
                "Carolyn Jane Anderson",
                "Molly Q Feldman",
                "Arjun Guha",
                "Michael Greenberg",
                "Abhinav"
            ],
            "title": "Jangda. Multipl-e: A scalable and extensible approach to benchmarking neural code generation, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Saikat Chakraborty",
                "Baishakhi Ray"
            ],
            "title": "On multi-modal learning of editing source code, 2021",
            "year": 2021
        },
        {
            "authors": [
                "Saikat Chakraborty",
                "Yujian Li",
                "Matt Irvine",
                "Ripon Saha",
                "Baishakhi Ray"
            ],
            "title": "Entropy guided spectrum based bug localization using statistical language model",
            "venue": "arXiv preprint arXiv:1802.06947,",
            "year": 2018
        },
        {
            "authors": [
                "Mark Chen",
                "Jerry Tworek",
                "Heewoo Jun",
                "Qiming Yuan",
                "Henrique Ponde de Oliveira Pinto",
                "Jared Kaplan et. al"
            ],
            "title": "Evaluating large language models trained on code, 2021",
            "year": 2021
        },
        {
            "authors": [
                "Tri Dao",
                "Dan Fu",
                "Stefano Ermon",
                "Atri Rudra",
                "Christopher R\u00e9"
            ],
            "title": "Flashattention: Fast and memoryefficient exact attention with io-awareness",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Xiang Deng",
                "Yu Gu",
                "Boyuan Zheng",
                "Shijie Chen",
                "Samuel Stevens",
                "Boshi Wang",
                "Huan Sun",
                "Yu Su"
            ],
            "title": "Mind2web: Towards a generalist agent for the web, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Tuan Dinh",
                "Jinman Zhao",
                "Samson Tan",
                "Renato Negrinho",
                "Leonard Lausen",
                "Sheng Zha",
                "George Karypis"
            ],
            "title": "Large language models of code fail at completing code with potential bugs",
            "venue": "arXiv preprint arXiv:2306.03438,",
            "year": 2023
        },
        {
            "authors": [
                "Xueying Du",
                "Mingwei Liu",
                "Kaixin Wang",
                "Hanlin Wang",
                "Junwei Liu",
                "Yixuan Chen",
                "Jiayi Feng",
                "Chaofeng Sha",
                "Xin Peng",
                "Yiling Lou"
            ],
            "title": "Classeval: A manually-crafted benchmark for evaluating llms on class-level code generation, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Sarah Fakhoury",
                "Saikat Chakraborty",
                "Madan Musuvathi",
                "Shuvendu K. Lahiri"
            ],
            "title": "Towards generating functionally correct code edits from natural language issue descriptions, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Zhiyu Fan",
                "Xiang Gao",
                "Martin Mirchev",
                "Abhik Roychoudhury",
                "Shin Hwei Tan"
            ],
            "title": "Automated repair of programs from large language models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Daniel Fried",
                "Armen Aghajanyan",
                "Jessy Lin",
                "Sida Wang",
                "Eric Wallace",
                "Freda Shi",
                "Ruiqi Zhong",
                "Wen tau Yih",
                "Luke Zettlemoyer",
                "Mike Lewis"
            ],
            "title": "Incoder: A generative model for code infilling and synthesis, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Claire Le Goues",
                "Michael Pradel",
                "Abhik Roychoudhury"
            ],
            "title": "Automated program repair",
            "venue": "Communications of the ACM,",
            "year": 2019
        },
        {
            "authors": [
                "David Gros",
                "Prem Devanbu",
                "Zhou Yu"
            ],
            "title": "Ai safety subproblems for software engineering researchers, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Rahul Gupta",
                "Soham Pal",
                "Aditya Kanade",
                "Shirish Shevade"
            ],
            "title": "Deepfix: Fixing common c language errors by deep learning",
            "venue": "In Proceedings of the aaai conference on artificial intelligence,",
            "year": 2017
        },
        {
            "authors": [
                "Maurice H. Halstead"
            ],
            "title": "Elements of Software Science (Operating and programming systems series)",
            "venue": "Elsevier Science Inc.,",
            "year": 1977
        },
        {
            "authors": [
                "Dan Hendrycks",
                "Steven Basart",
                "Saurav Kadavath",
                "Mantas Mazeika",
                "Akul Arora",
                "Ethan Guo",
                "Collin Burns",
                "Samir Puranik",
                "Horace He",
                "Dawn Song",
                "Jacob Steinhardt"
            ],
            "title": "Measuring coding challenge competence with apps, 2021",
            "year": 2021
        },
        {
            "authors": [
                "Xinyi Hou",
                "Yanjie Zhao",
                "Yue Liu",
                "Zhou Yang",
                "Kailong Wang",
                "Li Li",
                "Xiapu Luo",
                "David Lo",
                "John Grundy",
                "Haoyu Wang"
            ],
            "title": "Large language models for software engineering: A systematic literature review, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Edward J Hu",
                "Yelong Shen",
                "Phillip Wallis",
                "Zeyuan Allen-Zhu",
                "Yuanzhi Li",
                "Shean Wang",
                "Lu Wang",
                "Weizhu Chen"
            ],
            "title": "LoRA: Low-rank adaptation of large language models",
            "venue": "In International Conference on Learning Representations,",
            "year": 2022
        },
        {
            "authors": [
                "Sam Ade Jacobs",
                "Masahiro Tanaka",
                "Chengming Zhang",
                "Minjia Zhang",
                "Leon Song",
                "Samyam Rajbhandari",
                "Yuxiong He"
            ],
            "title": "Deepspeed ulysses: System optimizations for enabling training of extreme long sequence transformer models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Jiajun Jiang",
                "Yingfei Xiong",
                "Hongyu Zhang",
                "Qing Gao",
                "Xiangqun Chen"
            ],
            "title": "Shaping program repair space with existing patches and similar code",
            "venue": "In Proceedings of the 27th ACM SIGSOFT international symposium on software testing and analysis,",
            "year": 2018
        },
        {
            "authors": [
                "Tae-Hwan Jung"
            ],
            "title": "Commitbert: Commit message generation using pre-trained programming language model, 2021",
            "year": 2021
        },
        {
            "authors": [
                "Ren\u00e9 Just",
                "Darioush Jalali",
                "Michael D. Ernst"
            ],
            "title": "Defects4J: A Database of existing faults to enable controlled testing studies for Java programs",
            "venue": "ISSTA",
            "year": 2014
        },
        {
            "authors": [
                "Sungmin Kang",
                "Juyeon Yoon",
                "Shin Yoo"
            ],
            "title": "Large language models are few-shot testers: Exploring llm-based general bug reproduction, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Rafael-Michael Karampatsis",
                "Charles Sutton"
            ],
            "title": "How often do single-statement bugs occur? the manysstubs4j dataset",
            "venue": "IEEE/ACM 17th International Conference on Mining Software Repositories (MSR), pp",
            "year": 2020
        },
        {
            "authors": [
                "Douwe Kiela",
                "Max Bartolo",
                "Yixin Nie",
                "Divyansh Kaushik",
                "Atticus Geiger",
                "Zhengxuan Wu et. al"
            ],
            "title": "Dynabench: Rethinking benchmarking in nlp",
            "year": 2021
        },
        {
            "authors": [
                "Yunho Kim",
                "Seokhyeon Mun",
                "Shin Yoo",
                "Moonzoo Kim"
            ],
            "title": "Precise learn-to-rank fault localization using dynamic and static features of target programs",
            "venue": "ACM Transactions on Software Engineering and Methodology (TOSEM),",
            "year": 2019
        },
        {
            "authors": [
                "Yuhang Lai",
                "Chengxi Li",
                "Yiming Wang",
                "Tianyi Zhang",
                "Ruiqi Zhong",
                "Luke Zettlemoyer",
                "Scott Wen tau Yih",
                "Daniel Fried",
                "Sida Wang",
                "Tao Yu"
            ],
            "title": "Ds-1000: A natural and reliable benchmark for data science code generation, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Yujia Li",
                "David Choi",
                "Junyoung Chung",
                "Nate Kushman",
                "Julian Schrittwieser",
                "R\u00e9 mi Leblond et. al"
            ],
            "title": "Competition-level code generation with AlphaCode",
            "venue": "dec 2022a. doi: 10.1126/science.abq1158. URL https://doi.org/10.1126%2Fscience",
            "year": 2022
        },
        {
            "authors": [
                "Zhiyu Li",
                "Shuai Lu",
                "Daya Guo",
                "Nan Duan",
                "Shailesh Jannu",
                "Grant Jenks",
                "Deep Majumder",
                "Jared Green",
                "Alexey Svyatkovskiy",
                "Shengyu Fu",
                "Neel Sundaresan"
            ],
            "title": "Automating code review activities by large-scale pre-training, 2022b",
            "year": 2022
        },
        {
            "authors": [
                "Percy Liang",
                "Rishi Bommasani",
                "Tony Lee",
                "Dimitris Tsipras",
                "Dilara Soylu",
                "Michihiro Yasunaga et. al"
            ],
            "title": "Holistic evaluation of language models, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Jiawei Liu",
                "Chunqiu Steven Xia",
                "Yuyao Wang",
                "Lingming Zhang"
            ],
            "title": "Is your code generated by chatgpt really correct? rigorous evaluation of large language models for code generation",
            "venue": "arXiv preprint arXiv:2305.01210,",
            "year": 2023
        },
        {
            "authors": [
                "Nelson F. Liu",
                "Kevin Lin",
                "John Hewitt",
                "Ashwin Paranjape",
                "Michele Bevilacqua",
                "Fabio Petroni",
                "Percy Liang"
            ],
            "title": "Lost in the middle: How language models use long contexts, 2023b",
            "year": 2023
        },
        {
            "authors": [
                "Shangqing Liu",
                "Yanzhou Li",
                "Xiaofei Xie",
                "Yang Liu"
            ],
            "title": "Commitbart: A large pre-trained model for github commits, 2023c",
            "year": 2023
        },
        {
            "authors": [
                "Xiao Liu",
                "Hao Yu",
                "Hanchen Zhang",
                "Yifan Xu",
                "Xuanyu Lei",
                "Hanyu Lai et. al"
            ],
            "title": "Agentbench: Evaluating llms as agents, 2023d",
            "year": 2023
        },
        {
            "authors": [
                "Shuai Lu",
                "Daya Guo",
                "Shuo Ren",
                "Junjie Huang",
                "Alexey Svyatkovskiy",
                "Ambrosio Blanco et. al"
            ],
            "title": "Codexglue: A machine learning benchmark dataset for code understanding and generation",
            "year": 2021
        },
        {
            "authors": [
                "Fernando Mart\u0131\u0301nez-Plumed",
                "Pablo Barredo",
                "Se\u00e1n \u00d3 h\u00c9igeartaigh",
                "Jos\u00e9 Hern\u00e1ndez-Orallo"
            ],
            "title": "Research community dynamics behind popular ai benchmarks",
            "venue": "Nature Machine Intelligence,",
            "year": 2021
        },
        {
            "authors": [
                "Thomas J. McCabe"
            ],
            "title": "A complexity measure",
            "venue": "IEEE Transactions on Software Engineering,",
            "year": 1976
        },
        {
            "authors": [
                "Martin Monperrus"
            ],
            "title": "Automatic software repair",
            "venue": "ACM Computing Surveys,",
            "year": 2018
        },
        {
            "authors": [
                "Manish Motwani",
                "Yuriy Brun"
            ],
            "title": "Better automatic program repair by using bug reports and tests",
            "year": 2023
        },
        {
            "authors": [
                "Niklas Muennighoff",
                "Qian Liu",
                "Armel Zebaze",
                "Qinkai Zheng",
                "Binyuan Hui",
                "Terry Yue Zhuo",
                "Swayam Singh",
                "Xiangru Tang",
                "Leandro von Werra",
                "Shayne Longpre"
            ],
            "title": "Octopack: Instruction tuning code large language models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Gabriel Orlanski",
                "Kefan Xiao",
                "Xavier Garcia",
                "Jeffrey Hui",
                "Joshua Howland",
                "Jonathan Malmaud",
                "Jacob Austin",
                "Rishabh Singh",
                "Michele Catasta"
            ],
            "title": "Measuring the impact of programming language distribution, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Simon Ott",
                "Adriano Barbosa-Silva",
                "Kathrin Blagec",
                "Janina Brauner",
                "Matthias Samwald"
            ],
            "title": "Mapping global dynamics of benchmark creation and saturation in artificial intelligence",
            "venue": "Nature Communications,",
            "year": 2022
        },
        {
            "authors": [
                "Stephen Robertson",
                "Hugo Zaragoza"
            ],
            "title": "The probabilistic relevance framework: Bm25 and beyond",
            "venue": "Foundations and Trends\u00ae in Information Retrieval,",
            "year": 2009
        },
        {
            "authors": [
                "Baptiste Rozi\u00e8re",
                "Jonas Gehring",
                "Fabian Gloeckle",
                "Sten Sootla",
                "Itai Gat",
                "Xiaoqing Ellen Tan et. al"
            ],
            "title": "Code llama: Open foundation models for code, 2023",
            "year": 2023
        },
        {
            "authors": [
                "David Schlangen"
            ],
            "title": "Language tasks and language games: On methodology in current natural language processing research, 2019",
            "year": 2019
        },
        {
            "authors": [
                "Dominik Sobania",
                "Martin Briesch",
                "Carol Hanna",
                "Justyna Petke"
            ],
            "title": "An analysis of the automatic bug fixing performance of chatgpt",
            "year": 2023
        },
        {
            "authors": [
                "Aarohi Srivastava",
                "Abhinav Rastogi",
                "Abhishek Rao",
                "Abu Awal Md Shoeb et. al"
            ],
            "title": "Beyond the imitation game: Quantifying and extrapolating the capabilities of language models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Rosalia Tufano",
                "Luca Pascarella",
                "Michele Tufano",
                "Denys Poshyvanyk",
                "Gabriele Bavota"
            ],
            "title": "Towards automating code review",
            "year": 2021
        },
        {
            "authors": [
                "Junjie Wang",
                "Yuchao Huang",
                "Chunyang Chen",
                "Zhe Liu",
                "Song Wang",
                "Qing Wang"
            ],
            "title": "Software testing with large language model: Survey, landscape, and vision, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Chunqiu Steven Xia",
                "Lingming Zhang"
            ],
            "title": "Less training, more repairing please: revisiting automated program repair via zero-shot learning",
            "venue": "In Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering,",
            "year": 2022
        },
        {
            "authors": [
                "Chunqiu Steven Xia",
                "Lingming Zhang"
            ],
            "title": "Conversational automated program repair, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Chunqiu Steven Xia",
                "Matteo Paltenghi",
                "Jia Le Tian",
                "Michael Pradel",
                "Lingming Zhang"
            ],
            "title": "Universal fuzzing via large language models",
            "venue": "arXiv preprint arXiv:2308.04748,",
            "year": 2023
        },
        {
            "authors": [
                "John Yang",
                "Akshara Prabhakar",
                "Karthik Narasimhan",
                "Shunyu Yao"
            ],
            "title": "Intercode: Standardizing and benchmarking interactive coding with execution feedback, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Xin Yang",
                "Raula Gaikovina Kula",
                "Norihiro Yoshida",
                "Hajimu Iida"
            ],
            "title": "Mining the modern code review repositories: A dataset of people, process and product",
            "venue": "In Proceedings of the 13th International Conference on Mining Software Repositories,",
            "year": 2016
        },
        {
            "authors": [
                "Shunyu Yao",
                "Howard Chen",
                "John Yang",
                "Karthik Narasimhan"
            ],
            "title": "Webshop: Towards scalable real-world web interaction with grounded language agents, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Pengcheng Yin",
                "Wen-Ding Li",
                "Kefan Xiao",
                "Abhishek Rao",
                "Yeming Wen",
                "Kensen Shi",
                "Joshua Howland",
                "Paige Bailey",
                "Michele Catasta",
                "Henryk Michalewski",
                "Alex Polozov",
                "Charles Sutton"
            ],
            "title": "Natural language to code generation in interactive data science notebooks, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Hao Yu",
                "Bo Shen",
                "Dezhi Ran",
                "Jiaxin Zhang",
                "Qi Zhang",
                "Yuchi Ma",
                "Guangtai Liang",
                "Ying Li",
                "Tao Xie",
                "Qianxiang Wang"
            ],
            "title": "Codereval: A benchmark of pragmatic code generation with generative pre-trained models, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Tao Yu",
                "Rui Zhang",
                "Kai Yang",
                "Michihiro Yasunaga",
                "Dongxu Wang",
                "Zifan Li",
                "James Ma",
                "Irene Li",
                "Qingning Yao",
                "Shanelle Roman",
                "Zilin Zhang",
                "Dragomir Radev"
            ],
            "title": "Spider: A large-scale human-labeled dataset for complex and cross-domain semantic parsing and text-to-SQL task",
            "venue": "In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing,",
            "year": 2018
        },
        {
            "authors": [
                "Daoguang Zan",
                "Bei Chen",
                "Dejian Yang",
                "Zeqi Lin",
                "Minsu Kim",
                "Bei Guan",
                "Yongji Wang",
                "Weizhu Chen",
                "Jian-Guang Lou"
            ],
            "title": "Cert: Continual pre-training on sketches for library-oriented code generation, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Daoguang Zan",
                "Bei Chen",
                "Fengji Zhang",
                "Dianjie Lu",
                "Bingchao Wu",
                "Bei Guan",
                "Yongji Wang",
                "Jian-Guang Lou"
            ],
            "title": "Large language models meet nl2code: A survey, 2023",
            "year": 2023
        },
        {
            "authors": [
                "Jiyang Zhang",
                "Sheena Panthaplackel",
                "Pengyu Nie",
                "Junyi Jessy Li",
                "Milos Gligoric"
            ],
            "title": "Coditt5: Pretraining for source code and natural language editing, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Zibin Zheng",
                "Kaiwen Ning",
                "Jiachi Chen",
                "Yanlin Wang",
                "Wenqing Chen",
                "Lianghong Guo",
                "Weicheng Wang"
            ],
            "title": "Towards an understanding of large language models in software engineering",
            "venue": "tasks. arXiv preprint arXiv:2308.11396,",
            "year": 2023
        },
        {
            "authors": [
                "Shuyan Zhou",
                "Frank F. Xu",
                "Hao Zhu",
                "Xuhui Zhou",
                "Robert Lo",
                "Abishek Sridhar",
                "Xianyi Cheng",
                "Yonatan Bisk",
                "Daniel Fried",
                "Uri Alon",
                "Graham Neubig"
            ],
            "title": "Webarena: A realistic web environment for building autonomous agents, 2023",
            "year": 2023
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "Language models (LMs) are rapidly being deployed in commercial products such as chatbots and coding assistants. At the same time, existing benchmarks have become saturated (Kiela et al., 2021; Ott et al., 2022) and fail to capture the frontier of what state-of-the-art LMs can and cannot do. There is a need for challenging benchmarks that more accurately reflect real-world applications of LMs to help shape their future development and usage (Srivastava et al., 2023).\nBuilding a good benchmark is difficult since tasks must be challenging enough to stump existing models, but model predictions must also be easy to verify (Mart\u0131\u0301nez-Plumed et al., 2021). Coding\n\u2217Equal contribution. Correspondence to {carlosej,jy1682}@princeton.edu. Data, code, and leaderboard at swebench.com\ntasks are appealing as they pose challenging problems to LMs yet generated solutions can be easily verified by running unit tests. However, existing coding benchmarks, such as HumanEval (Chen et al., 2021), mostly involve self-contained problems that can be solved in a few lines of code.\nIn the real world, software engineering is not as simple. Fixing a bug might involve navigating a large repository, understanding the interplay between functions in different files, or spotting a small error in convoluted code. Inspired by this, we introduce SWE-bench, a benchmark that evaluates LMs in a realistic software engineering setting. As shown in Figure 1, models are tasked to resolve issues (typically a bug report or a feature request) submitted to popular GitHub repositories. Each task requires generating a patch describing changes to apply to the existing codebase. The revised codebase is then evaluated using the repository\u2019s testing framework.\nSWE-bench offers several advantages over existing LM programming benchmarks. These include, a realistic setting that utilizes user-submitted issues and solutions, diverse inputs featuring unique code problems from 12 repositories, a robust framework for execution-based evaluation, and the ability to continuously update the benchmark with new instances, requiring minimal human intervention.\nWe evaluate multiple state-of-the-art LMs on SWE-bench and find that they fail to solve all except the simplest issues. Using a BM25 retriever, Claude 2 is only able to resolve 1.96% of the issues.\nIn addition to SWE-bench our contributions include the release of a training dataset, SWE-benchtrain, which is essential for advancing open model development in this challenging domain. This dataset comprises a collection of 19,000 non-testing task instances derived from 37 repositories. Utilizing SWE-bench-train, we release two fine-tuned models, SWE-Llama 7b and 13b, based on the CodeLlama (Rozie\u0300re et al., 2023) model. We find that in some settings SWE-Llama 13b is competitive with Claude 2 and is capable of processing contexts exceeding 100,000 tokens."
        },
        {
            "heading": "2 SWE-BENCH",
            "text": "SWE-bench is a benchmark featuring GitHub issues from popular repositories that report bugs or request new features, and pull requests that make changes to the repository to resolve these issues. The task is to generate a pull request that addresses a given issue and passes tests related to the issue."
        },
        {
            "heading": "2.1 BENCHMARK CONSTRUCTION",
            "text": "GitHub is a rich data source for software development, but repositories, issues, and pull requests can be noisy, ad-hoc, or poorly documented or maintained. To find high-quality task instances at scale, we use a 3-stage pipeline as follows.\nStage I: Repo selection and data scraping. We start by collecting pull requests (PRs) from 12 popular open-source Python repositories on GitHub, producing about \u223c 90,000 PRs in total. We focus on popular repositories as they tend be better maintained, have clear contributor guidelines, and have better test coverage. Each PR has an associated codebase specified by it\u2019s base commit.\nStage II: Attribute-based filtering. We create candidate tasks by selecting the merged PRs that (1) resolve a GitHub issue and (2) make changes to the test files of the repository, which indicates that the user likely contributed tests to check whether the issue has been resolved.\nStage III: Execution-based filtering. For each candidate task, we apply the PR\u2019s test content, and log the associated test results before and after the PR\u2019s other content is applied. We filter out task instances without at least one test where its status changes from a fail to pass (henceforth referred to as fail-to-pass test). We also filter out instances that result in installation or runtime errors.\nThrough these stages of filtering, the original 90,000 PRs are filtered down to the 2,294 task instances which comprise SWE-bench. A final breakdown of these task instances across repositories is presented in Figure 3, and Table 1 highlights the key features of SWE-bench task instances. We highlight that the codebases are large with thousands of files, and the reference pull requests often make changes to multiple files at once. Technical details about SWE-bench\u2019s construction pipeline are discussed in Appendix A. Additional dataset statistics are in Appendix A.5."
        },
        {
            "heading": "2.2 TASK FORMULATION",
            "text": "Model input. A model is given an issue text description and a complete codebase. The model is then tasked to make an edit to the codebase to resolve the issue. In practice, we represent edits as patch files, which specify which lines in the codebase to modify in order to resolve the issue.\nEvaluation metrics. To evaluate a proposed solution, we apply the generated patch, using unix\u2019s patch program, to the codebase and then execute the unit and system tests associated with the task instance. If the patch applies successfully and all of these tests pass we consider the proposed solution to have successfully resolved the issue. The metric for our benchmark is the percentage of task instances that are resolved. Additional technical details in Appendix A.4."
        },
        {
            "heading": "2.3 FEATURES OF SWE-BENCH",
            "text": "Traditional benchmarks in NLP typically involve only short input and output sequences and consider somewhat \u201ccontrived\u201d problems created specifically for the benchmark. In contrast, SWE-bench\u2019s realistic construction setting imbues the dataset with unique properties, which we discuss below.\nReal-world software engineering tasks. Since each task instance in SWE-bench consists of a large and complex codebase and a description of a relevant issue, solving SWE-bench requires demonstrating sophisticated skills and knowledge possessed by experienced software engineers but are not commonly evaluated in traditional code generation benchmarks.\nContinually updatable. Our collection process can be easily applied to any Python repository on GitHub and requires minimal human intervention. Therefore, we can extend SWE-bench with a continual supply of new task instances and evaluate LMs on issues created after their training date, which ensures that the solution was not included in their training corpus.\nDiverse long inputs. Issue descriptions are typically long and detailed (195 words on average), and codebases regularly contain many thousands of files. Solving SWE-bench requires identifying the relatively small number of lines that need to be edited to solve an issue amongst a sea of context.\nRobust evaluation. For each task instance, there is at least one fail-to-pass test which was used to test the reference solution, and 40% of instances have at least two fail-to-pass tests. These tests evaluate whether the model addressed the problem in the issue. In addition, a median of 51 additional tests run to check whether prior functionality is properly maintained.\nCross-context code editing. Unlike prior settings that may constrain edit scope to an individual function or class (e.g., Chen et al., 2021; Cassano et al., 2022) or provide cloze-style fill-in blanks (e.g., Lu et al., 2021; Fried et al., 2023), SWE-bench does not provide such explicit guidance. Rather than merely having to produce a short code snippet, our benchmark challenges models to generate revisions in multiple locations of a large codebase. SWE-bench\u2019s reference solutions average editing 1.7 files, 3.0 functions, and 32.8 lines (added or removed).\nWide scope for possible solutions. The task of repository-scale code editing can serve as a level playing field to compare approaches ranging from retrieval and long-context models to decisionmaking agents, which could reason and act in code. SWE-bench also allows creative freedom, as models can generate novel solutions that may deviate from the reference PR."
        },
        {
            "heading": "3 SWE-LLAMA: FINE-TUNING CODELLAMA FOR SWE-BENCH",
            "text": "It is important to benchmark the performance of open models on SWE-bench alongside proprietary models. At the time of writing, only the CodeLlama models (Rozie\u0300re et al., 2023) are able to handle the very long contexts necessary. However, we observe that the off-the-shelf CodeLlama variants\nare not capable of following the detailed instructions to generate repository-wide code edits, and typically output placeholder responses or unrelated code. To better evaluate the capabilities of these models, we perform supervised fine-tuning on the 7 billion- and 13 billion-parameter CodeLlamaPython models. The resulting models are specialized repository editors that can run on consumer hardware and resolve GitHub issues.\nTraining data. We follow our data collection procedure and collect 19,000 issue-PR pairs from an additional 37 popular Python package repositories. In contrast to Section 2.1, we do not require that pull requests contribute test changes. This allows us to create a much larger training set to use for supervised fine-tuning. To eliminate the risk of data contamination, the set of repositories in the training data is disjoint from those included in the evaluation benchmark.\nTraining details. Given the instructions, an issue text from GitHub and the relevant code files as the prompt, we finetune SWE-Llama to generate the patch that solved the given issue (the \u201cgold patch\u201d). For memory efficiency, we fine-tune only the weights of the attention sublayer using LoRA Hu et al. (2022), and exclude training sequences with more than 30,000 tokens, reducing the effective size of the training corpus to 10,000 instances. More details are provided in Appendix B."
        },
        {
            "heading": "4 EXPERIMENTAL SETUP",
            "text": "In this section we explain how inputs are constructed to run SWE-bench evaluation. In addition, we review the models that we evaluate in this work."
        },
        {
            "heading": "4.1 RETRIEVAL-BASED APPROACH",
            "text": "SWE-bench instances provide an issue description and a codebase as input to the model. While issues descriptions are usually short (195 words on average as shown in Table 1), codebases consist of many more tokens (438K lines on average) than can typically be fit into an LMs context window. Then the question remains of exactly how to choose the relevant context to provide to the model?\nTo address this issue for our baselines, we simply use a generic retrieval system to select the files to insert as context. In particular, we evaluate models under two relevant context settings: 1) sparse retrieval and 2) an oracle retrieval.\nSparse retrieval. Dense retrieval methods are ill-suited to our setting due to very long key and query lengths, and especially the unusual setting of retrieving code documents with natural language queries. Therefore, we choose to use BM25 retrieval (Robertson et al., 2009) to retrieve relevant files to provide as context for each task instance. We experiment with three different maximum context limits, and simply retrieve as many files as fits within the specified limit. We evaluate each model on all limits that fit within its context window and report the best performance. From observation, models perform best on the shortest context window, as shown in Table 2.\n\u201cOracle\u201d retrieval. For analysis purposes we also consider a setting where we \u201cretrieve\u201d the files edited by the reference patch that solved the issue on GitHub. This \u201coracle\u201d setting is less realistic,\nsince an engineer working on addressing an issue may not know a priori which files need to be modified. In addition, this setting is also not necessarily comprehensive since edited files alone may not include all the required context to understand exactly how software will behave when interacting with unseen parts of the code.\nWe compare the BM25 retrieval results with those of the \u201coracle\u201d retrieval setting, as shown in Table 3. We observe that in approximately 40% of instances, BM25 retrieves a superset of the oracle files for the 27,000-token context limit. However, in almost half of the instances with the 27,000-token limit, it retrieves none of the files from the \u201coracle\u201d context."
        },
        {
            "heading": "4.2 INPUT FORMAT",
            "text": "Once the retrieved files are selected using one of the two methods above, we construct the input to the model consisting of task instructions, the issue text, retrieved files and documentation, and finally an example patch file and prompt for generating the patch file. Examples of instances and further details on this formulation are provided in Appendix D."
        },
        {
            "heading": "4.3 MODELS",
            "text": "Due to the need to process long sequence lengths, there are only a few models that are currently suitable for SWE-bench. Thus we evaluate ChatGPT-3.5 (gpt-3.5-turbo-16k-0613), GPT-4 (gpt-4-32k-0613), Claude 2, and SWE-Llama with their context limits shown in Table 4."
        },
        {
            "heading": "5 RESULTS",
            "text": "We report results for models using different retrieval mechanisms and prompting styles, then provide some analysis and insight into model performance and difficulty. We summarize models\u2019 performance using BM25 retrieval in Table 5. Across the board, models struggle significantly to resolve issues. The best performing model, Claude 2, is only able to resolve 1.96% of the issues.\nTo analyze the importance of the retriever to the overall system results, we present the \u201coracle\u201d retrieval results in Appendix Table 18. There, Claude 2 is able to resolve 4.8% of issues using the \u201coracle\u201d retriever. We further analyze the importance of context in the discussion below.\nDifficulty differs across repositories. When breaking performance down by repository, all models trend similarly across different repositories as show in Figure 4. Despite this, the issues resolved by each model do not necessarily overlap extensively. For example, in the \u201coracle\u201d setting Claude 2 and\nSWE-Llama 13b perform comparably, with each model resolving 110 and 91 instances respectively. Yet of these instances, Claude 2 only solves 42% of the instances solved by SWE-Llama.\nThis may also be related to the presence of images in issues, which can be encoded into the issue markdown with embedded image links (i.e. ![image][https://...]). Some repositories naturally feature more instances with images; for example 32% of matplotlib and 10% of seaborn instances contain embedded images in their issue text compared to just 2% of all instances. Solving these instances may require multi-modal LMs or some kind of external tool use to process images.\nDifficulty correlates with context length. Chat models may be pre-trained on long sequences of code but are typically asked to generate shorter coder snippets with limited context provided to frame the question. As shown in Figure 5, we see that as total context length increases, Claude 2\u2019s performance drops considerably; behavior that is also observed in other models. In our evaluation settings, models see a lot of code that may not be directly related to solving the issue at hand, and they seem to frequently struggle with localizing problematic code needing to be updated. This result corroborates other studies showing that models become distracted by additional context and may be sensitive to the relative location of target sequences (Liu et al., 2023b). Even when increasing the maximum context size for BM25 would increase recall with respect to the oracle files, performance drops, as shown in Table 2, as models are simply ineffective at localizing problematic code.\nFurther investigating this, we provide an input ablation on the \u201coracle\u201d retrieval context, \u201coracle\u201dcollapsed, where retrieved files are collapsed entirely, except for the lines actually edited by the true pull request (with \u00b115 lines of buffer) shown in Table 6. In this setting, we see increases in performance, with GPT-4 jumping from 1.3% to 3.4% and Claude 2 from 4.8% to 5.9%.\nDifficulty does not correlate with issue resolution date. In Table 7 we show model results in the \u201coracle\u201d retrieval setting, partitioned by date, for PRs created before or after 2023. We find that for most models there\u2019s little difference in performance before or after this date, with the exception of GPT-4. We consider this result to be largely promising as it suggests that despite models having been exposed to some version of an repository\u2019s codebase, they are unlikely to \u201ccheat\u201d to address issues simply by generating a more recent version of the repository.\nFinetuned models are sensitive to context distribution shifts. The finetuned models SWE-Llama 7b and 13b perform surprisingly poorly with BM25 retrieved context. As these models were finetuned using the \u201coracle\u201d retrieval as context, we suspect this shift in context makes it difficult for the model to perform reliably. For instance, SWE-Llama was trained to edit every file included as context whereas in the BM25 setting many files provided in context are not expected to be changed.\nGenerating patches is easier than generating whole files. Models are often trained using standard code files and likely rarely see patch files. We generally formulate our task to have models generate patch files as opposed to recreating the entire file with their proposed change, since patch files will usually be a much more efficient representation of a file change. As shown in Table 5, we observe that models still struggle with generating well-formatted patch files. So we experiment with asking models to instead regenerate entire files with their proposed changes to resolve the issue. In this setting, we find that models generally perform worse at this task than when generating patch files; for instance, Claude 2 scores at 2.2% compared to 4.8% in the main table for \u201coracle\u201d retrieval. Even when controlling for instance length, generating on the shorter half of the task instances by input tokens yields 3.9% compared to 7.8% for generating patches with Claude 2.\nLanguage models tend to generate shorter, simpler edits. Model generated patch files tend to add and remove fewer lines than their respective gold patch. As shown in Table 8, compared to an average gold patch, model generated patch files that apply correctly are less than half the total length (74.5 versus 30.1 lines) of gold edit patch files, and rarely edit more than a single file."
        },
        {
            "heading": "5.1 A QUALITATIVE ANALYSIS OF SWE-LLAMA GENERATIONS",
            "text": "We select 11 generations from SWE-Llama and Claude 2 to better understand the quality of the task and generated patches under the \u201coracle\u201d retrieval setting. Here we discuss an example from SWELlama and our overall findings, with in-depth analyses for other examples shown in Appendix F.\nWe\u2019ll consider the task instance sphinx-doc sphinx-8713 from the Sphinx documentation generator, shown in Figure 6. The issue states that the napoleon extension of Sphinx is not properly formatting the documentation keyword \u201cOther Parameters\u201d when the config setting napoleon.use_param is set to True. The issue text further provides a detailed code snippet of where the problematic source code is suspected to be, as well as some code examples for reproducing the error and additional information related to package versions. For this particular instance, the model did not resolve the task, failing to pass some of the tests resolved by the gold solution.\nIn the \u201coracle\u201d retrieval setting, the model input provides this issue text along with some instructions, the full contents of files edited by the gold patch, and an example of the diff format we expect the answer to be in. The total model input consists of 1,558 lines of context or 20,882 tokens. When comparing the gold patch and the model\u2019s patch, we find an obvious mistake. While the model edits the correct function, _parse_other_parameters_section at line 684 in sphinx/ext/napoleon/docstring.py , it changes the function to behave as if napoleon. use_param were always True instead of checking the config setting first and copying what the _parse_parameters_section does, like the gold patch. In the tests, test_parameters _with_class_reference directly compares the documentation produced using a config where napoleon_use_param is set to False, which catches the model\u2019s error immediately.\nComparing results across all the examples we consider, we notice a few prominent trends in behavior. Models tend to write primitive Python code and do not leverage existing third-party libraries or the rest of the codebase for their solutions. Models\u2019 generations also reflect a \u201cgreedy\u201d approach of solving the problem exactly, with little regard for code style or logical constraints that might be reflected by the codebase (i.e. using relative instead of absolute imports). In contrast, we observe that many gold patches will make structural improvements that cover a much larger scope of the codebase; these edits not only resolve the issue, but also anticipate and solve potential future issues."
        },
        {
            "heading": "6 RELATED WORK",
            "text": "Evaluation of LMs. Several recent works for evaluating LMs have either proposed a collection of mutually distinct tasks spanning across multiple domains (Hendrycks et al., 2021; Liang et al., 2022; Srivastava et al., 2023) or turned to the web as an interactive setting featuring tasks that require\nmultiple steps to solve (Yao et al., 2022; Zhou et al., 2023; Deng et al., 2023; Liu et al., 2023d). There are several drawbacks with such a \u201cpotpourri\u201d style setup. First, each task tends to narrowly focus on one or a few skills, resulting in challenges that are typically too simple, pigeonhole the model into a reduced role, and do not provide models with the bandwidth to exercise their versatility or potentially demonstrate new abilities (Srivastava et al., 2023). Consequently, a model\u2019s performance on such task conglomerations may not yield actionable, deep insights regarding its capabilities and how to improve them (Schlangen, 2019; Mart\u0131\u0301nez-Plumed et al., 2021; Bowman & Dahl, 2021). SWEbench addresses these shortcomings, as our work demonstrates that it is significantly challenging, presents a wide range of possibilities for improving LMs to solve this task, and is easy to refresh over time with new task instances, each of which introduce novel, nuanced, and practical challenges.\nCode Generation Benchmarks. HumanEval (Chen et al., 2021) is the current standard in a longstanding pursuit of synthesizing code from natural language descriptions (Yu et al., 2018; Austin et al., 2021; Hendrycks et al., 2021; Li et al., 2022a; Zan et al., 2023). In the past year, subsequent benchmarks have sought to augment HumanEval with extensions to different languages (Cassano et al., 2022; Athiwaratkun et al., 2023; Orlanski et al., 2023), variations in edit scope (Yu et al., 2023; Du et al., 2023), similar but novel code completion tasks (Muennighoff et al., 2023), and more testing (Liu et al., 2023a). Simultaneously, separate works have sought to introduce new coding paradigms (Yin et al., 2022; Yang et al., 2023) or design library-specific problems (Lai et al., 2022; Zan et al., 2022). Instead of partitioning problems into siloed datasets and curtailing them for simplicity\u2019s sake, SWE-bench\u2019s collection procedure transforms the source code with minimal post-processing, preserving a much broader set of challenges grounded in real-world software engineering beyond closed form completion, such as patch generation, reasoning over long contexts, navigating a codebase directory, and capturing dependency-based relationships across modules.\nML for Software Engineering. To overcome traditional program analysis techniques that may not scale or incorporate natural language, one direction of current software engineering research is to use neural networks, including LMs, to automate real-world software development processes (Maniatis et al., 2023; Zheng et al., 2023; Hou et al., 2023). Use cases include automating commit generation (Jung, 2021; Liu et al., 2023c), PR review (Yang et al., 2016; Li et al., 2022b; Tufano et al., 2021), bug localization Kim et al. (2019); Chakraborty et al. (2018), testing (Kang et al., 2023; Xia et al., 2023; Wang et al., 2023), and program repair (Gupta et al., 2017; Allamanis et al., 2017; Monperrus, 2018; Jiang et al., 2018; Goues et al., 2019; Gao et al., 2022; Dinh et al., 2023; Motwani & Brun, 2023). Most relevant to SWE-bench are works that have sought to apply LMs towards automated program repair (Xia & Zhang, 2022; 2023; Fan et al., 2023; Sobania et al., 2023), guiding code editing with commits (Chakraborty & Ray, 2021; Zhang et al., 2022; Fakhoury et al., 2023). However, none of the existing datasets (Just et al., 2014; Karampatsis & Sutton, 2019) present code context at the scale of SWE-bench. Moreover, SWE-bench can be easily extended to new programming languages and repositories, and it provides a significantly more realistic and challenging arena to carry out experiments towards augmenting LMs with software engineering tools and practices."
        },
        {
            "heading": "7 DISCUSSION",
            "text": "Limitations and future directions. SWE-bench task instances are all in Python; we hope to apply SWE-bench\u2019s task instance collection procedure to expand its coverage to more programming languages and domains. Second, our experiments aim to establish a baseline of the simplest and most straight-forward approaches for this task; we do not intend to constrain future methodologies to the same type of approach and encourage future work to investigate different methods (e.g., agent-based approaches, tool augmented LMs). Lastly, while this work evaluates models using execution-based code testing, relying solely on this method is insufficient to guarantee reliable performance of model generations, as we find automated code generations from LMs can frequently be less comprehensive, efficient, or readable compared to human-written solutions.\nConclusion. The complexity of real-world software development processes extends far beyond just code completion. By drawing on the open-source collaborative pipeline, SWE-bench creates a faithful mirror of real world coding environments. This more realistic environment encourages creative solutions that can have immediate applicability in open-source software development. We hope that this benchmark and our other contributions can serve as valuable assets in the future development of LMs that are more practical, intelligent, and autonomous."
        },
        {
            "heading": "8 ETHICS STATEMENT",
            "text": "SWE-bench is collected entirely from public repositories with licenses that permit software usage that our contributions are in accordance with. Details of the licenses are included in Table 12. During the collection or evaluation processes, we do not collect information about GitHub users, and the SWE-bench task instances do not use GitHub data beyond what is offered via the public API and website. Our contributions do not involve any human subject participation; we do not perform crowdsourcing or recruit human task workers for any part of SWE-bench, including its collection and evaluation procedures along with the experiments. SWE-bench\u2019s filtering criteria for GitHub repositories based on popularity does not implicitly or explicitly rely on any discriminative or biased heuristics for repository selection. For the dataset release, we plan to open source the SWE-bench task instances, the collection and evaluation infrastructure, the experimental results, the training data used for fine-tuning SWE-Llama models, and the SWE-Llama model weights. Following best practice precedents, we will also put forth ample documentation to describe each component and its use, and we will also put in place convenient communication channels for soliciting feedback to improve SWE-bench. SWE-bench does not put forth any immediately harmful insights. We briefly discuss the potential impact of SWE-bench\u2019s usage in Section E."
        },
        {
            "heading": "9 REPRODUCIBILITY STATEMENT",
            "text": "For our submission, we have uploaded the entirety of the source code as a zipped file that has been properly anonymized. We have organized the codebase such that separate directories correspond to different contributions within the main paper (i.e. dataset collection, evaluation, open source model inference, SWE-Llama training, etc.). The source code contains inline documentation that details purpose and usage of different parts of the codebase. In addition, we also include the full set of 2294 SWE-bench task instances that contains all the components discussed in the main paper. Beyond the documentation in the source code, we include thorough technical details for the collection pipeline and evaluation procedures in Section A.2 and Section A.4 that complements the original details in Section 2 of the main paper. These sections fully cover the logic presented in the code and can be helpful for understanding it. Moving forward, as discussed in the ethics statement, we plan to more formally release SWE-bench to the public as an open source repository with thorough details that describes the benchmark, outlines the code, and details its usage. A major component of SWEbench is the collection framework, which will be part of the open sourced code. Because of its easily maintainable design, as discussed in the main paper, our hope and belief is that SWE-bench should be highly reproducible."
        },
        {
            "heading": "10 ACKNOWLEDGEMENTS",
            "text": "We thank Danqi Chen, Tri Dao, Zexuan Zhong, Tianyu Gao, Will Merrill, Mengzhou Xia, Dan Friedman, Adithya Bhaskar, Austin Watkins, Aatmik Gupta, and Richard Zhu for their valuable feedback and advice. We acknowledge support from the National Science Foundation under Grant No. 2239363. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation."
        },
        {
            "heading": "APPENDIX",
            "text": "In the appendix, we provide more thorough details regarding the dataset construction process, evaluation pipeline, and characterization of the SWE-bench benchmark."
        },
        {
            "heading": "A BENCHMARK DETAILS",
            "text": "This section complements Section 2 with a more technical and fine-grained summary of the data collection, execution-based validation, and evaluation procedures, along with a fuller characterization of the task instances."
        },
        {
            "heading": "A.1 HIGH LEVEL OVERVIEW",
            "text": "Pull request scraping. From a list of the top 5,000 most downloaded PyPI libraries during August 2023, we select the top 100 packages, identify each library\u2019s corresponding open-source GitHub repository, verify which packages have licenses allowing for free software use, and collect all PRs for these repositories via the GitHub developer API. We elect to source problems from well-trafficked repositories because widespread use usually suggests that the repository has extensive documentation, structured open-source development guidelines, and working, well-formatted code.\nTask instance construction. We construct candidate task instances from PRs that satisfy three conditions. First, the PR\u2019s status must be Merged. A Merged status indicates that the PR\u2019s associated code changes were accepted and incorporated into its parent repository. Second, the PR resolves one or more issues in its repository. An issue is defined according to its canonical usage in GitHub as a digital ticket for tracking bugs, enhancements, or any general development goals for a software project. We scan a PR\u2019s title, body, and commit messages for linked issues (i.e. \u201cfixes #24\u201d). Third, the PR must introduce one or more new tests. A new test is counted when a PR\u2019s code changes edits a file path containing a testing-related keyword (e.g. \u201ctest\u201d, \u201ctesting\u201d).\nA PR that satisfies these criteria is then converted into a candidate task instance such as the example in Figure 7. The codebase C is identified by the repository\u2019s owner/name moniker and the pull request\u2019s base commit. Recovering the actual codebase from this information is straightforward. We create mirrors of the original GitHub repositories, where each mirror is uniquely identified as owner name. Cloning a repository\u2019s corresponding mirror and checking out the base commit yields C in its pre-PR state. The problem statement P is an aggregate of all related issues\u2019 titles and descriptions along with any subsequent comments written before the timestamp of the PR\u2019s initial commit to avoid leakage of solution details. A PR\u2019s code changes are separated into a test patch and a gold patch \u03b4. T consists of all tests from files edited in the test patch. As shown in Figure 7, both T and \u03b4 are stored as patch files. Further details about parsing PR and semantic data is in Appendix A.2.\nExecution-based validation. We verify the usability of a task instance via execution. For each candidate, we first define a virtual environment to serve as an execution context, then install C before applying any patches, and finally run T once before and once after the solution \u03b4 is applied. A candidate is removed from consideration for the final dataset if any step in the verification process fails. In addition, to ensure that a solution \u03b4 is non-trivial, we compare the pre-solution and postsolution validation logs to check for whether there are one or more tests in T where the status changes from fail to pass. Lastly, we exclude task instances with tests that invoke newly created functions or classes first introduced in the solution \u03b4. Since naming such constructs is typically an arbitrary process and usually not explicitly specified in the problem statement, resolving tests such as these may be an impossible task even for human developers. Information about execution contexts, codebase installation, determining test statuses from logs, and more are in Appendix A.3.\nContinuous Updates. SWE-bench\u2019s collection process is easily extensible to any open source code repositories, allowing for easy and low-maintenance extension to new programming languages and code domains. This design also provides SWE-bench with temporal robustness; as new language models trained on more recent source code are released over time, SWE-bench can simply be updated to produce new task instances based on PRs created after any LM\u2019s training date.\nhttps://hugovk.github.io/top-pypi-packages/"
        },
        {
            "heading": "Problem Statement",
            "text": ""
        },
        {
            "heading": "A.2 CONSTRUCTION PROCESS",
            "text": "We discuss additional details regarding the conversion of a pull request object into a candidate task instance. At a high level, the main goal of this conversion is to acquire relevant information for putting together the codebase C, problem statement P , unit tests T , and solution \u03b4 components introduced in Section 2. To this end, a SWE-bench task instance consists of the following fields, presented in the following Table 9. Collectively, the fields correspond to the four task instance modules.\nProblem Statement. The problem statement P for each task instance is readily available as the problem statement field. The problem statement is an aggregate of all issues\u2019 first comments along with any comments attached to those issues that were created before the creation date of the PR\u2019s initial commit. We crawl for issues from PR\u2019s title, body, and commit messages. After\nconcatenating these components\u2019 text data, we first remove any Markdown-style comments, then look through the remaining text for references to issue numbers (a pound # sign followed by a number) and check whether the word preceding the issue number reference is included in a set of keywords suggesting that the issue was resolved by the PR (e.g. \u201ccloses\u201d, \u201cfixes\u201d, \u201cresolves\u201d). The found issues are recorded in the issue numbers field, then separate web requests are made to retrieve each issue\u2019s data. To form the problem statement, each issue\u2019s title and body are added together and then concatenated with the next issue\u2019s if there are multiple. It is also during this step that the hints text field is created and collected from the PR\u2019s comment section, where text from comments created before the PR\u2019s initial commit. The intuition for this collection methodology is that such PR comments would likely contain natural language and pseudo-code suggestions to the original human task worker regarding how to complete the problem at hand. The experiments presented in this work do not make use of hints text, but we believe this information may be interesting for future investigations.\nCodebase. The codebase C content is not stored in plaintext for every task instance. Rather, the task instance contains a reference to the relevant codebase via the repo and base commit field. Both fields are available in the original PR\u2019s data. To make retrieval of the codebase C from these two elements reproducible and reliable, we create mirrors of the original repository. Mirrors for the repository constituting both the evaluation and fine tuning data are collected and open-sourced under the SWE-bench GitHub organization. Because an original repository\u2019s code may be subject to changes in its commit and edit history outside of the authors\u2019 control, we choose to create a mirror repository to ensure that later modifications to the codebase do not potentially render a task instance unusable due to a corruption or removal of the associated base commit. Additionally, we create a mirror instead of cloning and storing the latest version of a repository. This is because a mirror retains the original commit hashes, history, branches, and tags, serving as a faithful and complete history of the technical details of the original repository. A mirror does not retain stars, watchers, issues, or pull requests from the original repository.\nWe create a mirror from a repository after and within the same day when task instances were collected. The mirror retains the original repository\u2019s \u201cowner/name\u201d moniker, except that the \u201c/\u201d character is converted to a \u201c \u201d to confirm to GitHub naming conventions. Given this infrastructure, retrieving a task instance\u2019s codebase is straightforward. First, the correct mirror can be cloned from the SWE-bench organization using repo. Next, within the local copy of the mirror, checking out the base commit will reset the repository to codebase C. To proceed to another task instance from the same repository, git version control is used to automatically remove any modifications associated with the current task instance before checking out the next task instance\u2019s base commit.\nSolution, Test Patches. The solution \u03b4 and tests T are derived from the file changes data, or diff, of a PR. As mentioned in Section 2.1, the original diff along with solution \u03b4 and tests T are represented as a .patch file, a format for efficiently specifying transformations to line-based text files. Generally speaking, a .patch is structured as a list of blocks, where each block consists of a header and one or more hunks that collectively correspond to changes to a single file. The header contains metadata specifying a file path and line numbers, while the actual modifications to the target file are encoded as multiple lines prefixed by \u201c+\u201d and \u201c-\u201d to indicate additions and removals. To create the tests T , we first identifying every unique block within the patch, then pick out and conglomerate blocks with file paths that contain testing-related keywords (e.g. \u201ctests\u201d, \u201ctesting\u201d). The remaining blocks are merged to form the solution \u03b4. We validate the robustness of the script written to parse correctly T and \u03b4 by applying both patches to the corresponding codebase C and running the tests; we then check that the results reproduce the behavior of the base PR\u2019s diff data. The solution \u03b4 is saved as the patch field while the tests T are saved as the test patch field.\nRemaining Fields. The created at field is a timestamp that specifies when the base PR was created. We retain the created at field from the original data and use this field to perform temporal analysis of model performance. The version field is a string that corresponds to the release version, with respect to the repo, during which the PR was released. Depending on availability and the amount of effort required for each method, we create the version field by retrieving the information directly from the source code, building the repository locally and invoking code to display the version to standard output, or comparing the created at field with a timeline of release versions\nDocumentation for creating a mirror repository using GitHub\nfrom a repository\u2019s webpage. We create executable contexts for every version of a repository, as discussed in greater detail in \u00a7 A.3."
        },
        {
            "heading": "A.3 EXECUTION-BASED VALIDATION",
            "text": "After filtering through all the PRs from a repository and converting those that satisfy the aforementioned criteria into candidate task instances, the next step is to validate the usability of each task instance via execution. This procedure is broken down into three steps. First, we create executable contexts for each release version of a repository. Next, we check whether the solution \u03b4 and tests T can be applied, installed, and run successfully on top of codebase C. Finally, we examine each task instance\u2019s execution log to verify a specific set of behaviors to ensure that the task is usable and fair for model evaluation.\nExecutable Contexts. We choose to create executable contexts per release version after experimenting with various degrees of granularity with regards to what definition level to define virtual environments for. Defining task instance-specific contexts is most conducive to ensuring end-to-end installation success, but comes at the cost of laborious manual handcrafting. On the other hand, a repository-specific context based on the latest version of a repository is typically too coarse of a definition that is not compatible with older versions\u2019 requirements. We find that release versions are a good proxy for capturing the dependency requirements across a subset of task instances, striking a manageable balance between installation success and manual effort. We manually create each executable context by examining the codebase of the latest task instance for each version. Based on the source code and documentation typically found in the repository\u2019s README and CONTRIBUTING guides, we find out the Python version, necessary dependencies, and installation command.\nValidation Engine. The purpose of the validation engine is to verify candidate task instances. Specifically, this step checks first, that the solution \u03b4 and tests T can be applied to codebase C, and second, that the codebase can be properly installed and run within the corresponding virtual environment. To do this, we perform validation repository-by-repository, where for each repository\u2019s set of task instances, we perform the following procedure:\n1. Create executable contexts as conda envs. based on latest task instance per version.\n2. Group task instances by version.\n3. Iterate across each task instances group, where for each task instance, we perform the following within the corresponding conda env.\n(a) Remove any file changes and checkout the task instance\u2019s base commit. This sets the repository to codebase C.\n(b) Run the installation command to instantiate codebase C. (c) Apply the test patch T to codebase C. (d) Run the testing script, determined from test patch T , to generate test result logs logpre. (e) Apply the solution \u03b4 patch to the codebase C with tests T . (f) Run the testing script from part (d) again to generate test result logs logpost.\nThe testing command consists of the testing framework used by the repository (e.g. pytest, tox) with paths specified in T appended. The testing command would run any and all tests that are specified within the contents of each file path. If any of the steps (a) through (f) fails, the candidate task instance is discarded from consideration. With moderate variation across repositories, we observe that this step generally removes half of the candidate task instances.\nExamining Validation Logs. Last but not least, we check the logs logpre and logpost created by the validation engine for specific properties. First, to guard against arbitrary naming choices, we check logpre for ImportError and AttributeError occurrences, which are potentially indicative of dependency naming related errors that would trivial and near-impossible to address correctly. To this end, we remove all task instances with such errors in their logpre from consideration. Next, we compare the test results to check that the task instance is non-trivial, indicated by at least one or more tests having a fail status before the solution \u03b4 is applied, then a pass status after. To check this, we first define several repository-specific parsers to convert logpre and logpost into mappings of test ti \u2208 T to a status s \u2208 [fail,pass]. Given these two data structures, we then check that there\nexists at least one ti where s changes from fail to pass. If no such tests are found, the task instance is removed from consideration.\nIf a task instance fulfills these two criteria, then it is included in the evaluation dataset. Table 10 displays a summary of how many task instances were removed from consideration across the construction process and execution based validation steps. We save all finalized task instances to a single .json file that is open sourced and available for download.\nAlongside the task instances, we also create a corresponding folder containing the ground truth test results. For each task instance, from their respective logpre and logpost test-to-status mappings, we create a test results data structure where the keys are FAIL TO FAIL, FAIL TO PASS, PASS TO FAIL, and PASS TO PASS, and the values are lists of tests. By \u201ccaching\u201d these results, we remove the need to re-run the solution \u03b4 at evaluation time (although re-running is an available option). We use this data structure to verify task completion, as discussed in Section A.4."
        },
        {
            "heading": "A.4 EVALUATION PROCEDURE",
            "text": ""
        },
        {
            "heading": "SWE-Bench Task",
            "text": "We provide a visualization of the evaluation procedure in Figure 8. The evaluation procedure scores the model\u2019s \u03b4\u0302 .patch generation with respect to the behavior of the solution \u03b4. At a finer-grained level, the evaluation procedure can be broken down into four separate steps, highlighted by the numbered steps in Figure 8. First, the codebase and problem statement are visible and given to the\nLM; the LM then generates a .patch prediction \u03b4\u0302. In the evaluation step, the following steps are performed per prediction on the target task instance:\n1. Remove any file changes and checkout the task instance\u2019s base commit. This sets the repository to codebase C.\n2. Activate the executable context corresponding to the task instance\u2019s version.\n3. Run installation command to instantiate codebase C.\n4. Apply test patch T to codebase C.\n5. Apply prediction patch \u03b4\u0302 to codebase C with tests T .\n6. If the previous step fails, we attempt to fix prediction patch \u03b4\u0302 automatically and reapply it.\n7. Run the testing script, determined from test patch T , to generate test result logs log\u03b4\u0302 .\nSteps 1 through 4 reliably do not fail due to verification during the task instance validation process. If applying the prediction patch (Step 5) fails, we attempt to repair the prediction patch file by removing unnecessary context lines and recalculating the header values (Step 6). If the remaining patch fails again or running the test command (Step 7) fails, then the prediction is automatically given a score of 0. Assuming these steps succeed, the output log log\u03b4\u0302 can then be converted to a test-to-status mapping, identical in structure to the via the appropriate, repository-specific parser introduced in \u00a7 A.3.\nEvaluation Metrics Calculation. To determine task completion, we compare the test-to-status mapping parsed from log\u03b4\u0302 with the list of tests corresponding to the FAIL TO PASS and PASS TO PASS keys from the ground truth test results data structure. Determining task completion is straightforward; we check that all FAIL TO PASS and PASS TO PASS tests are found and have a pass status in the evaluation test-to-status mapping. If a test is missing or has a non-pass status, it is considered a fail status. As defined and used in the main paper, a task is considered solved if all tests across FAIL TO PASS and PASS TO PASS pass."
        },
        {
            "heading": "A.5 EVALUATION TEST SET CHARACTERIZATION",
            "text": "We include an expanded form of Table 1 that includes repository specific statistics in Table 11. Table 12 presents a brief description of each repository extracted from the repository\u2019s documentation along with the repository\u2019s associated open source license. The associated licenses all permit noncommercial usage of the original library source code as long as the permissions in the original licenses are upheld and retained. In addition to the original statistics presented in Table 1, we introduce three new values. The \u03b4 # Lines Added and \u03b4 # Lines Removed together sum up to \u03b4 Lines Edited. \u201cAdded\u201d refers to the number of new lines that are introduced, while \u201cRemoved\u201d are preexisting lines taken out by the solution. The |T | (Pass to Pass) statistic refers to the number of tests that were passing before the solution \u03b4 was applied during the validation pipeline. Unlike fail to pass tests that are intended to characterize the problem statement P and determine if a revision addresses the issue, pass to pass tests are included to ensure that the revision does not break or violate any existing expected behavior. These tests are extracted during the validation log examination phase as discussed in \u00a7 A.3. We note that fail to fail tests and pass to fail tests are not considered during evaluation, and those statistics are not reflected in the above table.\nTask Instance Issue Categories. To provide a better sense of the types of problems that SWE-bench task instances include, we perform simple analyses on the issues, identified by the issue numbers field, for each task instance. Per issue, we inspect metadata, specifically tags, to characterize the type of contribution put forth by the PR. Table 13 groups and shows several examples of the 2,289 tags we found across all issues. While the absolute majority of issues are associated with bug fixes, SWE-bench\u2019s task instances are associated with a diverse set of code changes with purposes beyond debugging and error correction.\nAttribute Distributions. In Figure 9, we present plots of the cumulative distribution function for attributes introduced in Table 1. From these plots, we see that the median SWE-bench task instance has a problem description of 140 words, and will take place within a codebase containing just shy of 1900 files and 400K lines. The corresponding reference solution \u03b4 will usually edit a single function\nwithin a file, changing \u223c15 lines, and has a single fail to pass test to verify the correctness of the change along with 51 pass to pass tests to check whether existing behavior is preserved.\nPatch Fix Rate. We present Table 14, which presents summary statistics of how many task instances each model generated patches for (out of 2294), how many of these patches applied successfully, and how many of the successfully applied patches required undergoing the patch fixing procedure introduced in Appendix A.4. We find that fixed patches tend to make up a smaller percentage of the SWE-Llama patches that successfully applied, suggesting that SWE-Llama\u2019s fine tuning procedure has a positive effect on generating well-formatted patches. For closed source models, fewer patches apply successfully, and of the ones that do, a greater percentage require the post-generation fix, suggesting that models still struggle with patch generation and structured outputs in general."
        },
        {
            "heading": "A.6 DEVELOPMENT SET CHARACTERIZATION",
            "text": "In addition to the evaluation test set, we also provide a development set for evaluating models and tuning hyperparameters before running on the final test set. Following the style of tables and graphs from before, we present similar statistics to characterize the 225 development task instances (slightly more than 10% of the main evaluation set) collected from 6 open source repositories with licenses permitting such usage. The development set was collected following the exact same set of methodologies and filters as the main evaluation set. In addition to the pre-existing steps, we also filter the development set to keep task instances that were created after January 1, 2019. Similar to Table 12, in Table 15, we briefly summarize the purpose and licenses of the 6 selected repositories.\nFollowing Table 13, we also list the tags associated with the the development set tasks in Table 16, again showcasing the diversity and coverage of task types beyond fixing bugs. Compared to the main evaluation tasks, we can also see tags (e.g., \u201cCrash :collision:\u201d, \u201cio\u201d) that refer to issues presenting problems which are unique to the repositories in the development set.\nFollowing Table 1, we present the same set of repository-specific average statistics for the 6 repositories in the development set in Table 17. Across the entire development set, each task instance has 19.9 average / 2 median F2P tests. There are 171.3 average / 79.0 median P2P tests, and 191.2 average / 101.0 median tests in total per task instance."
        },
        {
            "heading": "B ADDITIONAL DETAILS ON TRAINING SWE-LLAMA",
            "text": ""
        },
        {
            "heading": "B.1 TRAINING DETAILS",
            "text": "Optimization. We finetune using LoRA (Hu et al., 2022) with r = 16, \u03b1 = 16, dropout = 0.05, on the query, key, value, and output projection matrices of every attention sublayer. We train with a learning rate of 6e \u2212 4 and a batch size of 32 sequences per gradient step for a maximum of 4 epochs. During training, we save checkpoints every 50 steps, and after training, select the best checkpoint based on the validation loss on a held-out 100 instances. SWE-Llama 7b was initialized with CodeLlama-Python 7b and trained in 20 hours on 4 NVIDIA A100s. SWE-Llama 13b was initialized with CodeLlama-Python 13b and trained in 47 hours on 8 NVIDIA A100s. We used DeepSpeed Ulysses (Jacobs et al., 2023) and Flash Attention (Dao et al., 2022) to enable long context training."
        },
        {
            "heading": "C ADDITIONAL RESULTS",
            "text": ""
        },
        {
            "heading": "C.1 RESULTS WITH \u201cORACLE\u201d RETRIEVAL",
            "text": "Using the \u201coracle\u201d retrieval method described in Section 4.1, we show the general performance results in Table 18. Naturally, providing only the files edited by the reference solution\u2019s pull request, model performance improves compared to the noisier BM25 retrieval setting."
        },
        {
            "heading": "C.2 EVALUATION TEST SET",
            "text": "We include a repository-by-repository breakdown of model performance in Table 19 that corresponds to Figure 4 in the main paper. As discussed, in the main paper, performance differs heavily across repositories."
        },
        {
            "heading": "C.3 GPT-4 EVALUATION SUBSET RESULTS",
            "text": "In this section, we present the statistics shown in Table 5 for the 25% random subset that GPT-4 was tested in Table 20. As the selection of the subset is random, we find that the % Resolved and % Apply rates are consistent with the main results, and not significantly skewed towards being simpler or more difficult than the general evaluation set."
        },
        {
            "heading": "C.4 EXTENDED TEMPORAL ANALYSIS",
            "text": "In this section, we present an extended temporal analysis of task instances solved by year that follows the analysis shown in Table 7 of the evaluation section in the main paper. In Table 21, we present the % Resolved statistic across models under the \u201cOracle\u201d retrieval setting for 6 different temporal partitions that group tasks by the years in which the issues were created. It is evident from the table that there is no consistent correlation between model performance and year, supporting our conclusion that despite having potentially seen older versions of code within its pre-training datasets, understanding and implementing in fixes in SWE-bench is a difficult task that requires understanding and cannot be accomplished feasibly or consistently via memoization of observed data."
        },
        {
            "heading": "C.5 F2P, P2P RATE ANALYSIS",
            "text": "In the main paper results, we present the \u201c% Resolved\u201d statistic that indicates how many task instances were completely solved by the different models. In this section, we provide more finegrained insight into the gap of task instances where 1. The model\u2019s patch generation was applied successfully and 2. The task instance was not resolved. Assuming a patch is applied successfully, we define 6 cases in Table 22 that fully capture the distribution of all possible outcomes based on the pass/fail results of F2P and P2P tests. In addition to the \u201cResolved\u201d outcome that has been established, we introduce five new terms. The \u201cBreaking Resolved\u201d outcome refers to when the desired behavior of the issue has been accomplished (all F2P tests pass), but not all prior behavior is maintained (not all P2P tests pass). \u201cPartially Resolved\u201d refers to when prior behavior of a codebase was maintained (all P2P tests pass); however, the desired behavior is not fully accomplished (not all F2P tests pass). The \u201cWork in Progress\u201d case is when the desired behavior is not fully accomplished (not all F2P tests pass) and the prior behavior of the codebase is not maintained (not all P2P tests pass). A \u201cNo-Op\u201d is when a code change does not have any effect on the original codebase; prior\nbehavior is maintained (all P2P tests pass) but the issue remains completely unresolved (0 F2P tests pass). Finally, if the issue is unresolved (0 F2P tests pass) and prior working behavior is reverted (some P2P tests fail), the codebase is left in a worse state, which we define to be a \u201cRegression\u201d.\nIn Table 23, we categorize patch generations that successfully applied according to these six cases. We find that of non-\u201cResolved\u201d issues, the majority of patch generations proposed by the model do not solve a single F2P test case from the corresponding task instance (\u201cNo-Op\u201d and \u201cRegression\u201d). Within the subset of these cases, the majority (60% to 70%) of cases are a No-Op, while the model breaks existing behavior for the remainder of these situations.\nGenerally, the cases where model generations pass some, but not all tests (\u201cBreaking Resolved\u201d, \u201cPartially Resolved\u201d, \u201cWork in Progress\u201d) cumulatively represent a smaller subset of problems relative to the other three categories. From manual inspection of several of these cases, it is clear that the model demonstrates some understanding of the task requirements. However, due to the baseline methods\u2019 limited view of the codebase that does not include information such as inter-file dependencies and functions\u2019 relationships, for many of these task instances often fail because a change that correctly resolves the immediate issue does not account for other modules that use and are affected by the changed entity. We include several case studies that directly highlight these shortcomings in Section F Overall, these results highlight not just the difficulty of SWE-bench, but also point to the potential value of providing feedback via an execution environment that would allow models to run fixes against existing tests, then decide whether to continue editing or submit the patch for review."
        },
        {
            "heading": "C.6 PATCH GENERATION EXTENDED ANALYSIS",
            "text": "In this section, we present a statistics to quantify various facets of patch generations following the metrics laid out in Table 8. In Table 24, we recalculate these values for all patch generations in the oracle retrieval setting for all models, regardless of whether or not the patch was applied"
        },
        {
            "heading": "2023 244 61 4.51 1.56 0.00 4.07 3.50",
            "text": ""
        },
        {
            "heading": "2022 395 117 4.05 0.85 3.42 2.80 2.46",
            "text": ""
        },
        {
            "heading": "2021 383 102 4.18 0.00 2.94 4.45 2.56",
            "text": ""
        },
        {
            "heading": "2020 427 109 5.15 0.71 0.00 3.96 3.43",
            "text": ""
        },
        {
            "heading": "2019 437 112 5.72 1.49 1.79 4.55 2.21",
            "text": "successfully. Across all metrics, we find that patch generations across models are much closer in size to the characteristics of average gold edits. While some models still generate fewer lines relative to the corresponding Gold edit (e.g., Claude-2, ChatGPT-3.5, GPT-4), the SWE-Llama models edits are on average longer in most respects.. When considering both Table 8 and Table 24, it becomes clear that models struggle with generating longer output sequences to be correctly formatted patches. Further inspection of such occurrences, as shown in our case studies in Section F, indicate that hallucinations, abiding to existing code style/structure, and referencing long range dependencies correctly are common errors that surface more frequently in longer generations."
        },
        {
            "heading": "C.7 SOFTWARE ENGINEERING METRICS",
            "text": "We perform preliminary evaluations that explore using software engineering metrics to evaluate the efficiency and complexity of large code blocks integrated within a complex codebase. Unlike semantic similarity scoring functions for evaluating fluency and surface form likeness that are popular with traditional NLP benchmarks and have been adopted for code generation, metrics such as Cyclomatic complexity McCabe (1976) and Halstead complexity measures Halstead (1977) are founded upon logical abstractions (e.g., Abstract Syntax Trees) and software principles to quantify the complexity, efficiency, and readability of code as a scalar value. The patch generations and SWE-bench evaluation logs are rich sources of information that software engineering metrics and static analyzers can readily be applied to. Unlike small, code contest benchmarks where the insights of software engineering metrics are not meaningful due to the minuscule scope of the target functionality, SWE-bench\u2019s task is complex enough that practitioners can use these tools to gain well-structured, rigorous, and wide-ranging feedback signals on the complexity of a patch generation\u2019s change and its effect on the rest of the codebase.\nWe include our exploratory work here that demonstrates how software engineering metrics can reliably capture characteristics of code quality, and how comparing these statistics across two patches can provide automatic observations about model capabilities. We use the Radon package, a library for computing different software engineering metrics directly from source code.\nRadon Documentation, open-source codebase\nWe look specifically at successfully applied Claude 2 patch predictions in the \u201cOracle\u201d retrieval setting for the psf/requests repository, which several models perform best at as reflected in Figure 4. Per prediction, we apply the patch to the codebase, then calculate the Cyclomatic complexity and Halstead complexity scores for the modified functions. Cyclomatic complexity quantifies the control flow of a function, counting the number of independent execution paths through the source code (McCabe, 1976). A higher Cyclomatic complexity score suggests a more complex function that has higher likelihood of defects and usually suggests difficult maintainability. Halstead complexity counts the number of operators and operands in a program (Halstead, 1977). Per prediction, we also perform the same set of steps for the corresponding gold patch.\nWe find that software engineering metrics provides automatic qualitative insights into model performance. Consider the following simple case study in Figure 10. While the model patch prediction (left) is fewer lines (6 instead of 11) and modifies fewer files (1 instead of 2) compared to the gold reference solution (right), the model\u2019s edit places a conditional within a relatively complex and widely used HTTPAdapter class. This introduces two new potential execution outcomes, raising the Cyclomatic complexity of HTTPAdapter from 3 to 5. In contrast, while longer, the reference solution imports intra-module dependencies, modifies a logically simpler function in get connection, and defines a new error type InvalidProxyURL to capture the novel bug described by the issue."
        },
        {
            "heading": "D ADDITIONAL EXPERIMENTAL DETAILS",
            "text": ""
        },
        {
            "heading": "D.1 RETRIEVAL DETAILS",
            "text": "Sparse retrieval. During retrieval we make a slight augmentation to the documents by pre-pended files\u2019 contents with their file paths to better enable retrieval based on filenames that may be mentioned directly in the issue.\nProblem Statement: Misleading exception with invalid protocol in proxy variable. When the value of https proxy or HTTPS PROXY variable(s) accidentally miss one \u2019/\u2019 in the protocol, a traceback is thrown to the user which doesn\u2019t pin point that the issue is with the proxy configuration...\nOracle retrieval. Oracle retrieval file paths are simply extracted directly from the reference solution\u2019s patch file excluding test files.\nD.2 INFERENCE SETTINGS\nSince generations are relatively expensive, we only generate a single patch file per instance. Following precedent in code generation for evaluation in Pass@1 (Chen et al., 2021; Rozie\u0300re et al., 2023), we simply use greedy decoding for all models."
        },
        {
            "heading": "D.3 PROMPT TEMPLATE EXAMPLE",
            "text": "Models are prompted with the following general template with slight variations depending on the model used.\nYou will be provided with a partial code base and an issue statement explaining a problem to resolve. <issue> {ISSUE TEXT} </issue>\n<code> [start of README.md] {README.md text} [end of README.md] [start of file_1.py] {file_1.py text} [end of file_1.py] ... </code>\nHere is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change,\nand the removed and added lines. A single patch file can contain changes to multiple files.\n<patch> --- a/file.py +++ b/file.py @@ -1,27 +1,35 @@ def euclidean(a, b): - while b: - a, b = b, a % b - return a + if b == 0: + return a + return euclidean(b, a % b)\ndef bresenham(x0, y0, x1, y1): points = [] dx = abs(x1 - x0) dy = abs(y1 - y0)\n- sx = 1 if x0 < x1 else -1 - sy = 1 if y0 < y1 else -1 - err = dx - dy + x, y = x0, y0 + sx = -1 if x0 > x1 else 1 + sy = -1 if y0 > y1 else 1\n- while True: - points.append((x0, y0)) - if x0 == x1 and y0 == y1: - break - e2 = 2 * err - if e2 > -dy: + if dx > dy: + err = dx / 2.0 + while x != x1: + points.append((x, y)) err -= dy - x0 += sx - if e2 < dx: - err += dx - y0 += sy + if err < 0: + y += sy + err += dx + x += sx + else: + err = dy / 2.0 + while y != y1: + points.append((x, y)) + err -= dx + if err < 0: + x += sx + err += dy + y += sy\n+ points.append((x, y)) return points </patch>\nI need you to solve the provded issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the format shown above.\nRespond below:\nExperiments using slightly more or fewer lines of instructions or examples seemed to not affect overall performance substantially, except for the findings of experiments stated in Section 5."
        },
        {
            "heading": "E SOCIETAL IMPACT",
            "text": "As reasoning on code has emerged as a foundational skill underlying many LM\u2019s capability, a potential future of machine-automated software engineering raises many important questions and has important potential ramifications with regards to AI Safety (Gros et al., 2023). It is important to address questions on how to ensure AI-generated code is faithful to human intents and what guardrails might be in place when human objectives are misinterpreted by code agents that then carry out the task. To observe such problems in a controlled setting and manifest their solutions, we hope SWEbench might serve as a testbed for designing safe, robust measures towards aligned, verifiable, and safe AI-driven software engineering.\nF IN-DEPTH ANALYSIS OF SWE-LLAMA GENERATIONS\nIn this section, we provide five additional qualitative analyses of generations from both Claude 2 and SWE-Llama generations (Oracle retrieval setting) following the style of Section 5.1.\nClaude 2 qualitative studies can be found in Tables 25 and 26. Tables 27, 28, and 29 are task instances that Claude 2 did not address correctly. SWE-Llama qualitative studies are covered across Tables 30, 31, 32, 33, 34. For Tables 30, 31, and 32, we present task instances solved correctly by SWE-Llama 13b. In Table 33 and 34, we present two task instances where SWE-Llama 13b does not address the issue correctly, pointing out a subset of the reasoning and generation skills that models may not be adept at enough to accomplish the task at hand.\nThe observations we make across these sections corroborate with the points stated in the main paper, which is that models tend to struggle with multi-line and multi-file changes, are more adept when the required fix is relatively short, and need help with understanding the codebase in an efficient manner."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "TypeError when supplying a boolean X to HuberRegressor fit #### Description \u2018TypeError\u2019 when fitting \u2018HuberRegressor\u2019 with boolean predictors.\n#### Steps/Code to Reproduce\nimport numpy as np from sklearn.datasets import make_regression from sklearn.linear_model import HuberRegressor\n# Random data X, y, coef = make_regression(n_samples=200, n_features=2, noise=4.0, coef\n=True, random_state=0) X_bool = X > 0 X_bool_as_float = np.asarray(X_bool, dtype=float)\n# Works huber = HuberRegressor().fit(X, y) # Fails (!) huber = HuberRegressor().fit(X_bool, y) # Also works huber = HuberRegressor().fit(X_bool_as_float, y)\n#### Expected Results No error is thrown when \u2018dtype\u2019 of \u2018X\u2019 is \u2018bool\u2019 (second line of code in the snipped above, .fit(X_bool, y) ). Boolean array is expected to be converted to \u2018float\u2019 by \u2018HuberRegressor.fit\u2019 as it is done by, say \u2018LinearRegression\u2019.\n#### Actual Results \u2018TypeError\u2018 is thrown: (Remaining lines omitted)"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/sklearn/linear_model/huber.py b/sklearn/linear_model/huber.\npy --- a/sklearn/linear_model/huber.py +++ b/sklearn/linear_model/huber.py @@ -251,7 +251,8 @@ def fit(self, X, y, sample_weight=None):\nself : object \"\"\" X, y = check_X_y(\n- X, y, copy=False, accept_sparse=[\u2019csr\u2019], y_numeric=True) + X, y, copy=False, accept_sparse=[\u2019csr\u2019], y_numeric=True, + dtype=[np.float64, np.float32])\nif sample_weight is not None: sample_weight = np.array(sample_weight) check_consistent_length(y, sample_weight)\nModel Generated Patch --- a/sklearn/linear_model/huber.py +++ b/sklearn/linear_model/huber.py @@ -231,6 +231,9 @@ class HuberRegressor(LinearModel, RegressorMixin,\nBaseEstimator): self.tol = tol\n+ def _validate_data(self, X, y=None): + return X.astype(np.float64) if X.dtype == np.bool else X +\ndef fit(self, X, y, sample_weight=None): \"\"\"Fit the model according to the given training data.\n@@ -250,7 +253,7 @@ class HuberRegressor(LinearModel, RegressorMixin, BaseEstimator):\n------- self : object \"\"\"\n- X, y = check_X_y( + X, y = check_X_y(\nX, y, copy=False, accept_sparse=[\u2019csr\u2019], y_numeric=True) if sample_weight is not None:\nsample_weight = np.array(sample_weight) @@ -262,6 +265,9 @@ class HuberRegressor(LinearModel, RegressorMixin,\nBaseEstimator): raise ValueError(\n\"epsilon should be greater than or equal to 1.0, got %f\" % self.epsilon)\n+ + X = self._validate_data(X)"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\nsklearn/linear_model/tests/test_huber.py::test_huber_bool\nPass to Pass (9) sklearn/linear_model/tests/test_huber.py::test_huber_max_iter sklearn/linear_model/tests/test_huber.py::test_huber_gradient sklearn/linear_model/tests/test_huber.py::test_huber_sample_weights sklearn/linear_model/tests/test_huber.py::test_huber_sparse sklearn/linear_model/tests/test_huber.py::test_huber_scaling_invariant\nAdditional Pass to Pass Tests omitted...\nDiscussion. In this task instance, the issue is describing an issue regarding how types are cast. Specifically, when When fitting the HuberRegressor model with boolean predictors, like X_bool , a TypeError occurs. This issue arises because the HuberRegressor does not automatically convert boolean arrays to floats as some other models do, such as LinearRegression , causing a type mismatch error. For its fix, the model defines its own _validate_data function, which encapsulates the type casting logic, and applies it to X . While it passes the tests, this fix could be more efficient and potentially introduces stylistic and organizational inconsistencies. As demonstrated in the reference solution, there is a much simpler solution of passing in dtype arguments that leverage the existing flags of the check_X_y function call to resolve this more cleanly. Other files\u2019 content was not included in the oracle retrieval setting due to the context window limitation."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "[Bug]: sharex and sharey don\u2019t accept 0 and 1 as bool values\n### Bug summary When using \u20180\u2018 or \u20181\u2018 in place of \u2018False\u2018 or \u2018True\u2018 in \u2018sharex\u2018 or \u2018sharex\u2018 arguments of \u2018pyplot.subplots\u2018 an error is raised. ### Code for reproduction\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(ncols=2,sharey=1)\n### Actual outcome We get the following error :\nTraceback (most recent call last): (Earlier lines omitted) File \"/***/matplotlib/lib/matplotlib/gridspec.py\", line 293, in subplots _api.check_in_list([\"all\", \"row\", \"col\", \"none\"],\nFile \"/***/matplotlib/lib/matplotlib/_api/__init__.py\", line 131, in check_in_list\nraise ValueError(msg) ValueError: 1 is not a valid value for sharey; supported values are \u2019all\u2019\n, \u2019row\u2019, \u2019col\u2019, \u2019none\u2019\nUsing \u2018sharex\u2018 instead of \u2018sharey\u2018 produces the same error (albeit with the following warning:\nUserWarning: sharex argument to subplots() was an integer. Did you intend to use subplot() (without \u2019s\u2019)?\nbut this is expected and not part of the present issue) ### Expected outcome I expected values 1 and 0 to be understood as bool."
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py index 06dd3f19f6..32ee7c306e 100644 --- a/lib/matplotlib/gridspec.py +++ b/lib/matplotlib/gridspec.py @@ -276,9 +276,9 @@ class GridSpecBase:\nraise ValueError(\"GridSpec.subplots() only works for GridSpecs \"\n\"created with a parent figure\")\n- if isinstance(sharex, bool): + if isinstance(sharex, bool) or sharex == 1 or sharex == 0: sharex = \"all\" if sharex else \"none\" - if isinstance(sharey, bool): + if isinstance(sharey, bool) or sharey == 1 or sharey == 0:\nsharey = \"all\" if sharey else \"none\" # This check was added because it is very easy to type # \u2018subplots(1, 2, 1)\u2018 when \u2018subplot(1, 2, 1)\u2018 was intended."
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py --- a/lib/matplotlib/gridspec.py +++ b/lib/matplotlib/gridspec.py @@ -276,21 +276,12 @@ def subplots(self, *, sharex=False, sharey=False,\nsqueeze=True, - if isinstance(sharex, bool): + if not isinstance(sharex, str): sharex = \"all\" if sharex else \"none\" - if isinstance(sharey, bool): + if not isinstance(sharey, str): sharey = \"all\" if sharey else \"none\" - # This check was added because it is very easy to type - # \u2018subplots(1, 2, 1)\u2018 when \u2018subplot(1, 2, 1)\u2018 was intended. - # In most cases, no error will ever occur, but mysterious behavior - # will result because what was intended to be the subplot index is - # instead treated as a bool for sharex. This check should go away - # once sharex becomes kwonly. - if isinstance(sharex, Integral): - _api.warn_external( - \"sharex argument to subplots() was an integer. Did you \" - \"intend to use subplot() (without \u2019s\u2019)?\") - _api.check_in_list([\"all\", \"row\", \"col\", \"none\"], + + _api.check_in_list([\"all\", \"row\", \"col\", \"none\", False, True],\nsharex=sharex, sharey=sharey)"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\nlib/matplotlib/tests/test_subplots.py::test_shared\nPass to Pass (39) lib/matplotlib/tests/test_subplots.py::test_label_outer_span lib/matplotlib/tests/test_subplots.py::test_label_outer_non_gridspec lib/matplotlib/tests/test_subplots.py::test_shared_and_moved lib/matplotlib/tests/test_subplots.py::test_exceptions lib/matplotlib/tests/test_subplots.py::test_subplots_offsettext[png]\nAdditional Pass to Pass Tests omitted...\nDiscussion. This example asks for 1 and 0 to be treated as boolean values for the sharex and sharey arguments of the pyplot.subplots function. The current code raises an error. In the generated patch, the model adds 1 and 0 as acceptable values. However, the gold patch adds the acceptable values into a list [\"all\", \"row\", \"col\", \"none\", False, True] . It also removes the Integral related warning tied to this issue. This clean up along with the clarity of the check_in_list argument makes the code more concise and readable."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "ascii.qdp Table format assumes QDP commands are upper case ### Description ascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \u201cREAD SERR 1 2\u201d whereas QDP itself is not case sensitive and case use \u201cread serr 1 2\u201d. As many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n### Expected behavior The following qdp file should read into a \u2018Table\u2018 with errors, rather than crashing.\nread serr 1 2"
        },
        {
            "heading": "1 0.5 1 0.5",
            "text": "### How to Reproduce Create a QDP file:\n> cat > test.qdp read serr 1 2 1 0.5 1 0.5 <EOF>\n> python Python 3.10.9 (main, Dec 7 2022, 02:03:23) [Clang 13.0.0 (clang\n-1300.0.29.30)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> from astropy.table import Table >>> Table.read(\u2019test.qdp\u2019,format=\u2019ascii.qdp\u2019) WARNING: table_id not specified. Reading the first available table [\nastropy.io.ascii.qdp] Traceback (most recent call last): ...\nraise ValueError(f\u2019Unrecognized QDP line: {line}\u2019) ValueError: Unrecognized QDP line: read serr 1 2\nRunning \u201cqdp test.qdp\u201d works just fine.\nModel Generated Patch --- a/astropy/io/ascii/qdp.py +++ b/astropy/io/ascii/qdp.py @@ -60,7 +60,7 @@\nValueError: Unrecognized QDP line... \"\"\" _decimal_re = r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\"\n- _command_re = r\"READ [TS]ERR(\\s+[0-9]+)+\" + _command_re = r\"read [ts]err(\\s+[0-9]+)+\"\nsep = delimiter if delimiter is None:"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py --- a/astropy/io/ascii/qdp.py +++ b/astropy/io/ascii/qdp.py @@ -68,7 +68,7 @@ def _line_type(line, delimiter=None):\n_new_re = rf\"NO({sep}NO)+\" _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO\n|[-+]?nan))*)\" _type_re = rf\"\u02c6\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<\ndata>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\" - _line_type_re = re.compile(_type_re) + _line_type_re = re.compile(_type_re, re.IGNORECASE)\nline = line.strip() if not line:\nreturn \"comment\" @@ -306,7 +306,7 @@ def _get_tables_from_qdp_file(qdp_file,\ninput_colnames=None, delimiter=None):\nvalues = [] for v in line.split(delimiter):\n- if v == \"NO\": + if v.upper() == \"NO\":\nvalues.append(np.ma.masked) else:\n# Understand if number is int or float"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\nastropy/io/ascii/tests/test_qdp.py::test_roundtrip[True]\nPass to Pass (8) astropy/io/ascii/tests/test_qdp.py::test_get_tables_from_qdp_file astropy/io/ascii/tests/test_qdp.py::test_roundtrip[False] astropy/io/ascii/tests/test_qdp.py::test_read_example astropy/io/ascii/tests/test_qdp.py::test_roundtrip_example astropy/io/ascii/tests/test_qdp.py::test_roundtrip_example_comma astropy/io/ascii/tests/test_qdp.py::test_read_write_simple astropy/io/ascii/tests/test_qdp.py::test_read_write_simple_specify_name astropy/io/ascii/tests/test_qdp.py::test_get_lines_from_qdp\nDiscussion. This issue requests a fix for handling QDP files; specifically, it asks for the expectation of the commands to be uppercase to be removed. In the model generated patch, the model locates the READ and ERR commands mentioned in the issue description in a regex pattern and edits it directly. However, within the same file, it is clear that the regex pattern is used in additional patterns, such as _type_re , and so a fix to the \u201croot\u201d regex pattern may not be appropriate. In addition, amidst multiple regex pattern variables, identifying the correct one to modify requires reasoning that can potentially be helped by execution. This error in this solution is reflected in the fact that it not only fails to pass the given unit tests, but also fails existing tests enforcing prior behavior."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Width computation after histogram slightly wrong with log scale Note the slight overlap here:\n( so.Plot(tips, \"total_bill\") .add(so.Bars(alpha=.3, edgewidth=0), so.Hist(bins=4)) .scale(x=\"log\") )\n![image](https://user-images.githubusercontent.com/315810/ 178975852-d8fd830e-ae69-487d-be22-36531fca3f8f.png) It becomes nearly imperceptible with more bins:\n( so.Plot(tips, \"total_bill\") .add(so.Bars(alpha=.3, edgewidth=0), so.Hist(bins=8)) .scale(x=\"log\") )\n![image](https://user-images.githubusercontent.com/315810/ 178976113-7026b3ae-0b87-48df-adc0-00e90d5aea94.png) This is not about \u2018Bars\u2018; \u2018Bar\u2018 has it too:\n( so.Plot(tips, \"total_bill\") .add(so.Bar(alpha=.3, edgewidth=0, width=1), so.Hist(bins=4)) .scale(x=\"log\") )\n![image](https://user-images.githubusercontent.com/315810/ 178975910-484df65f-4ce6-482e-9992-5d02faf6b9ea.png)\nModel Generated Patch --- a/seaborn/_core/plot.py +++ b/seaborn/_core/plot.py @@ -1327,9 +1327,7 @@\nelif \"width\" in df: view_width = view_df[\"width\"]\nelse: - view_width = 0.8 # TODO what default? - spacing = scales[orient]._spacing(view_df.loc[view_idx,\norient]) - width.loc[view_idx] = view_width * spacing + width.loc[view_idx] = view_width\ndf[\"width\"] = width\nif \"baseline\" in mark._mappable_props:"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py --- a/seaborn/_core/plot.py +++ b/seaborn/_core/plot.py @@ -1377,10 +1377,9 @@ def _unscale_coords( - drop_cols = [*coord_cols, \"width\"] if \"width\" in df else\ncoord_cols out_df = (\ndf - .drop(drop_cols, axis=1) + .drop(coord_cols, axis=1)\n.reindex(df.columns, axis=1) # So unscaled columns retain their place\n@@ -1396,12 +1395,6 @@ def _unscale_coords( - if var == orient and \"width\" in view_df: - width = view_df[\"width\"] - out_df.loc[values.index, \"width\"] = ( - transform(values + width / 2) - transform(values -\nwidth / 2) - ) - return out_df diff --git a/seaborn/_marks/bar.py b/seaborn/_marks/bar.py --- a/seaborn/_marks/bar.py +++ b/seaborn/_marks/bar.py @@ -29,17 +29,23 @@ class BarBase(Mark): + transform = scales[orient]._matplotlib_scale.get_transform() + forward = transform.transform + reverse = transform.inverted().transform + + other = {\"x\": \"y\", \"y\": \"x\"}[orient] + + pos = reverse(forward(data[orient]) - data[\"width\"] / 2) + width = reverse(forward(data[orient]) + data[\"width\"] / 2) - pos + + val = (data[other] - data[\"baseline\"]).to_numpy() + base = data[\"baseline\"].to_numpy() + (Remaining lines omitted...)"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\ntests/_marks/test_bar.py::TestBars::test_log_scale\nPass to Pass (8) tests/_marks/test_bar.py::TestBar::test_categorical_positions_vertical tests/_marks/test_bar.py::TestBar::test_categorical_positions_horizontal tests/_marks/test_bar.py::TestBar::test_numeric_positions_vertical tests/_marks/test_bar.py::TestBar::test_numeric_positions_horizontal tests/_marks/test_bar.py::TestBar::test_set_properties\nAdditional Pass to Pass Tests omitted...\nDiscussion. The baseline model\u2019s inability to solve this issue can be directly attributed to a lack of an image input. We include this example to demonstrate that debugging real software issues may involve digesting images; this presents a whole separate body of understanding and reasoning-related challenges. Beyond the SWE-bench task, additional problems in software engineering, such as interpreting system design diagram, user interface specifications, and user feedback presents interesting vision-language challenges."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Imports within TYPE CHECKING can induce \u201ccyclic-import\u201d Suppose you have two modules: a.py and b.py. \u2018a\u2018 imports \u2018b\u2018, but \u2018b\u2018 needs \u2018a\u2018 in order to do type annotations, then this is usually done by importing \u2018a\u2018 within a \u2018TYPE CHECKING\u2018 block. Unfortunately, this causes pylint to report \u2018cyclic-import\u2018.\nPossibly related to https://github.com/PyCQA/pylint/issues/3285"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py --- a/pylint/checkers/imports.py +++ b/pylint/checkers/imports.py @@ -813,7 +813,9 @@ def _get_imported_module(self, importnode, modname): - def _add_imported_module(self, node, importedmodname): + def _add_imported_module( + self, node: Union[astroid.Import, astroid.ImportFrom],\nimportedmodname: str + ) -> None:\n\"\"\"notify an imported module, used to analyze dependencies\"\"\" module_file = node.root().file context_name = node.root().name\n@@ -826,6 +828,10 @@ def _add_imported_module(self, node, importedmodname ):\nexcept ImportError: pass\n+ in_type_checking_block = ( + isinstance(node.parent, astroid.If) and node.parent.\nis_typing_guard() + ) +\nif context_name == importedmodname: self.add_message(\"import-self\", node=node)\n@@ -845,7 +851,10 @@ def _add_imported_module(self, node, importedmodname ):\n# update import graph self.import_graph[context_name].add(importedmodname)\n- if not self.linter.is_message_enabled(\"cyclic-import\", line= node.lineno): + if ( + not self.linter.is_message_enabled(\"cyclic-import\", line=\nnode.lineno) + or in_type_checking_block + ):\nself._excluded_edges[context_name].add(importedmodname)"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py index 4f3eed2..2b74a8d 100644 --- a/pylint/checkers/imports.py +++ b/pylint/checkers/imports.py @@ -49,6 +49,7 @@ import copy import os import sys from distutils import sysconfig +from typing import TYPE_CHECKING from typing import Dict, List, Union\nimport astroid @@ -61,6 +62,9 @@ from pylint.checkers.utils import ( node_ignores_exception, ) from pylint.exceptions import EmptyReportError +if TYPE_CHECKING: + from pylint.lint import PyLinter + from pylint.graph import DotBackend, get_cycles from pylint.interfaces import IAstroidChecker from pylint.reporters.ureports.nodes import Paragraph, VerbatimText,\nVNode"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\ntests/_marks/test_bar.py::TestBars::test_log_scale\nPass to Pass (11) tests/test_func.py::test_functionality[func_w0401_disabled_in_func.py] tests/test_func.py::test_functionality[func_i0022.py] tests/test_func.py::test_functionality[func_w0401.py] tests/test_func.py::test_functionality[func_w0801.py] tests/test_func.py::test_functionality[func_w0401_package]\nAdditional Pass to Pass Tests omitted...\nDiscussion. In this problem, the model is being asked to provide TYPE_CHECKING based handling for resolving cyclic imports, which pylint currently throws an error for. The gold patch has a detailed solution that involves conditional handling within the TYPE_CHECKING block, excludes the cyclic import messages, and has generally more specific handling. The model generated patch employs a \u201cStack Overlow\u201d like solution; while creating a TYPE_CHECKING block is a popular solution for resolving imports, solving this issue for the codebase in particular requires a more nuanced solution than a general answer that may be available online."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "When displaying a DatasetGroupBy in an interactive Python session, the first line of output contains a trailing whitespace. The first example in the documentation demonstrate this:\n>>> import xarray as xr, numpy as np >>> ds = xr.Dataset( ... {\"foo\": ((\"x\", \"y\"), np.random.rand(4, 3))}, ... coords={\"x\": [10, 20, 30, 40], \"letters\": (\"x\", list(\"abba\"))}, ... ) >>> ds.groupby(\"letters\") DatasetGroupBy, grouped over \u2019letters\u2019 2 groups with labels \u2019a\u2019, \u2019b\u2019.\nThere is a trailing whitespace in the first line of output which is \u201dDatasetGroupBy, grouped over \u2018letters\u2019 \u201d. This can be seen more clearly by converting the object to a string (note the whitespace before n ):\n>>> str(ds.groupby(\"letters\")) \"DatasetGroupBy, grouped over \u2019letters\u2019 \\n2 groups with labels \u2019a\u2019, \u2019b\u2019.\"\nWhile this isn\u2019t a problem in itself, it causes an issue for us because we use flake8 in continuous integration to verify that our code is correctly formatted... [20 more lines]"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/xarray/core/groupby.py b/xarray/core/groupby.py --- a/xarray/core/groupby.py +++ b/xarray/core/groupby.py @@ -436,7 +436,7 @@ def __iter__(self):\nreturn zip(self._unique_coord.values, self._iter_grouped())\ndef __repr__(self): - return \"{}, grouped over {!r} \\n{!r} groups with labels {}.\".format( + return \"{}, grouped over {!r}\\n{!r} groups with labels {}.\".format(\nself.__class__.__name__,"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/xarray/core/groupby.py b/xarray/core/groupby.py --- a/xarray/core/groupby.py +++ b/xarray/core/groupby.py @@ -436,7 +436,7 @@ def __iter__(self):\nreturn zip(self._unique_coord.values, self._iter_grouped())\ndef __repr__(self): - return \"{}, grouped over {!r} \\n{!r} groups with labels {}.\".format( + return \"{}, grouped over {!r}\\n{!r} groups with labels {}.\".format(\nself.__class__.__name__,"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (10)\nxarray/tests/test_groupby.py::test_groupby_repr[obj0-x] xarray/tests/test_groupby.py::test_groupby_repr[obj0-y] xarray/tests/test_groupby.py::test_groupby_repr[obj0-z] xarray/tests/test_groupby.py::test_groupby_repr[obj0-month] xarray/tests/test_groupby.py::test_groupby_repr[obj1-x] xarray/tests/test_groupby.py::test_groupby_repr[obj1-y] xarray/tests/test_groupby.py::test_groupby_repr[obj1-z] xarray/tests/test_groupby.py::test_groupby_repr[obj1-month] xarray/tests/test_groupby.py::test_groupby_repr_datetime[obj0] xarray/tests/test_groupby.py::test_groupby_repr_datetime[obj1]\nPass to Pass (16) xarray/tests/test_groupby.py::test_consolidate_slices xarray/tests/test_groupby.py::test_groupby_da_datetime xarray/tests/test_groupby.py::test_groupby_duplicate_coordinate_labels xarray/tests/test_groupby.py::test_groupby_input_mutation xarray/tests/test_groupby.py::test_groupby_map_shrink_groups[obj0]\nAdditional Pass to Pass Tests omitted...\nDiscussion. In this problem, the model is asked to correct a trailing whitespace issue, and the issue shows a demonstration of the error that arises during usage, but does not explicitly point out the function to fix in the model. In the oracle retrieval setting, the model is given the xarray/core/groupby.py file to edit directly, but most locate the line to edit. In this situation, the model successfully reasons that in the interactive Python setting, the underlying function that is being invoked is actually the repr function. After locating the function, it must figure out where in the return statement the whitespace is located. At this point, the fix is quite evident, as there is an explicit space that the model removes. In this case, the model successfully passes all tests for verifying the correctness of this fix explicitly (10 fail to pass tests) while also maintaining the existing behavior of the file (16 pass to pass tests)."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Unicode method names cause UnicodeDecodeError for some requests in Python 2.7.2 The following example works fine:\nfiles = {u\u2019file\u2019: open(u\u2019/usr/bin/diff\u2019, u\u2019rb\u2019)} response = requests.request(method=\u2019POST\u2019, url=u\u2019http://httpbin.org/post\u2019\n, files=files)\nBut the following example (using \u2018method=u\u2019POST\u2019\u2018 instead of \u2018method=\u2019POST\u2019\u2018) produces a UnicodeDecodeError:\nfiles = {u\u2019file\u2019: open(u\u2019/usr/bin/diff\u2019, u\u2019rb\u2019)} response = requests.request(method=u\u2019POST\u2019, url=u\u2019http://httpbin.org/post\n\u2019, files=files)\nTraceback (most recent call last): [Full stack trace hidden] File \"/System/Library/Frameworks/Python.framework/Versions/2.7/... msg += message_body UnicodeDecodeError: \u2019ascii\u2019 codec can\u2019t decode byte 0xcf in position 140:\nordinal not in range(128)\nMy guess is that \u2018u\u2019POST\u2019\u2018 is infecting the header with unicode when it should be a string. This is because \u2018sessions.py:313\u2018 is simply:\nreq.method = method.upper()\n[Additional lines hidden...]"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/requests/sessions.py b/requests/sessions.py --- a/requests/sessions.py +++ b/requests/sessions.py @@ -12,7 +12,7 @@ from collections import Mapping from datetime import datetime -from .compat import cookielib, OrderedDict, [3 more omitted] +from .compat import cookielib, OrderedDict, [3 omitted, + builtin_str from .cookies import cookiejar_from_dict, extract_cookies_to_jar,\nRequestsCookieJar from .models import Request, PreparedRequest from .hooks import default_hooks, dispatch_hook @@ -309,6 +309,9 @@ def request(self, method, url,\n:param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, (\u2019cert\u2019, \u2019key\u2019) pair.\n\"\"\" + + method = builtin_str(method)"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/requests/sessions.py b/requests/sessions.py --- a/requests/sessions.py +++ b/requests/sessions.py @@ -254,7 +254,7 @@ def prepare_request(self, request):\np = PreparedRequest() p.prepare(\n- method=request.method.upper(), + method=str(request.method).upper(),\nurl=request.url, files=request.files, data=request.data,"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (6)\ntest_requests.py::RequestsTestCase::test_DIGEST_AUTH_RETURNS_COOKIE test_requests.py::RequestsTestCase::test_DIGEST_HTTP_200_OK_GET test_requests.py::RequestsTestCase::test_different_encodings_dont_break test_requests.py::RequestsTestCase::test_generic_cookiejar_works test_requests.py::RequestsTestCase::test_uppercase_scheme_redirect\nPass to Pass (75) test_requests.py::RequestsTestCase::test_DIGEST_AUTH_SETS_SESSION_COOKIES test_requests.py::RequestsTestCase::test_DIGEST_STREAM test_requests.py::RequestsTestCase::test_HTTP_200_OK_GET_ALTERNATIVE test_requests.py::RequestsTestCase::test_HTTP_200_OK_GET_WITH_PARAMS test_requests.py::RequestsTestCase::test_HTTP_200_OK_HEAD\nAdditional Pass to Pass Tests omitted...\nDiscussion. Unlike the problem presented in Table 30, instead of an interactive python input, the model is given an error trace from a function invocation, where the steps to recreate the problem from a user\u2019s standpoint is offered. In addition, the issue also provides a suggestion during the last line on a potential fix for the problem. Once again in the oracle setting, the model takes advantage of the natural language suggestion and localizes the change to a line that is semantically quite similar to the suggestion ( req.method = method.upper() compared to method=str(request.method).upper() . The model correctly addresses the issue, as reflected by all the passing tests. However, in this situation, we can see that the model is actually quite \u201clucky\u201d in its success. First, while the gold patch leverages built in functions that are used for uniformity in handling string formatting, the model\u2019s decision to use more primitive Python to tackle this issue would likely not be well-received by a human reviewer due to its inconsistency with the rest of the codebase. Further inspection of the builtin_str function, not shown in this figure, also reveals that it handles additional string formatting cases beyond what was portrayed in the issue. While the model solves the task this time, it is questionable whether this solution is robust to future issues."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Allow hiding the \u201dSave and Add Another\u201d button with a show_save_and_add_another context variable To provide better adjustability, to introduce new context var - show_save_and_add_another . E.g. if I want to hide button \u201dSave and add another\u201d, I can just modify extra_context - write False to the variable. For other buttons - \u201dSave\u201d and \u201dSave and continue editing\u201d, this already works exactly in this manner."
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/django/contrib/admin/templatetags/admin_modify.py b/django\n/... --- a/django/contrib/admin/templatetags/admin_modify.py +++ b/django/contrib/admin/templatetags/admin_modify.py @@ -54,12 +54,20 @@ def submit_row(context):\nis_popup = context[\u2019is_popup\u2019] save_as = context[\u2019save_as\u2019] show_save = context.get(\u2019show_save\u2019, True)\n+ show_save_and_add_another = context.get(\u2019show_save_and_add_another\u2019, True) (7 lines omitted...) or (has_add_permission and add) or has_editable_inline_admin_formsets + can_save_and_add_another = ( + has_add_permission and + not is_popup and + (not save_as or add) and + can_save and + show_save_and_add_another + )\ncan_save_and_continue = not is_popup and can_save and has_view_permission and show_save_and_continue can_change = has_change_permission or has_editable_inline_admin_formsets\nctx = Context(context) @@ -70,10 +78,7 @@ def submit_row(context):\nchange and context.get(\u2019show_delete\u2019, True) ), \u2019show_save_as_new\u2019: not is_popup and has_change_permission\nand change and save_as, - \u2019show_save_and_add_another\u2019: ( - has_add_permission and not is_popup and - (not save_as or add) and can_save - ), + \u2019show_save_and_add_another\u2019: can_save_and_add_another,\n\u2019show_save_and_continue\u2019: can_save_and_continue, \u2019show_save\u2019: show_save and can_save,"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/django/contrib/admin/templatetags/admin_modify.py b/django\n/... --- a/django/contrib/admin/templatetags/admin_modify.py +++ b/django/contrib/admin/templatetags/admin_modify.py @@ -72,7 +72,7 @@ def submit_row(context):\n\u2019show_save_as_new\u2019: not is_popup and has_change_permission and change and save_as, \u2019show_save_and_add_another\u2019: ( has_add_permission and not is_popup and\n- (not save_as or add) and can_save + (not save_as or add) and can_save and context\n.get(\u2019show_save_and_add_another\u2019, True) ), \u2019show_save_and_continue\u2019: can_save_and_continue, \u2019show_save\u2019: show_save and can_save,"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (2)\ntest_override_show_save_and_add_another test_submit_row (admin_views.test_templatetags.Admin...)\nPass to Pass (3) test_choice_links (admin_views.test_templatetags.DateHierarchyTests) test_override_change_form_template_tags test_override_change_list_template_tags\nDiscussion. For this task instance that comes from the django/django repository, the model is asked to introduce a context variable that would allow a user to hide the \u201cSave and Add Another\u201d button via a context variable, similar to how it is done for two other existing buttons. The task is a bit more difficult compared to the prior two settings because no explicit stack trace or programmatic demonstration of the issue is offered. In this relatively under-specified setting that does not provide suggestion with regards to localizing the function correctly, the model successfully reasons that it should adjust the existing show_save_and_add_another key/value pair. When comparing the gold patch solution, it can be argued that the model generated patch produces a much more efficient solution in terms of lines edited, as it makes the smallest edit necessary to incorporate context as a flag for setting the show_save_and_add_another hidden status. However, similar to the discussion in Table 31, stylistically, the gold patch edits are much more consistent with the codebase, and additional changes that are not explicitly discussed in the issue are also made to adhere to what has been done in the codebase (i.e. the addition of a can_save_and_add_another field . This task is an example of a potentially exciting direction where via human guidance or better understanding of a codebase in general, models would then adjust their generations to not just make the functionally correct changes, but also the stylistically right ones, too."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Using rst_prolog removes top level headings containing a domain directive\n### Describe the bug If rst_prolog is set, then any documents that contain a domain directive as the first heading (eg :mod: ) do not render the heading correctly or include the heading in the toctree. In the example below, if the heading of docs/mypackage.rst were mypackage2 instead of :mod:mypackage2 then the heading displays correctly. Similarly, if you do not set rst_prolog then the heading will display correctly. This appears to have been broken for some time because I can reproduce it in v4.0.0 of Sphinx\n### How to Reproduce\n$ sphinx-quickstart --no-sep --project mypackage --author me -v 0.1.0 --release 0.1.0 --language en docs $ echo -e \u2019Welcome\\n=======\\n\\n.. toctree::\\n\\n mypackage\\n\u2019 > docs/index.rst $ echo -e \u2019:mod:\u2018mypackage2\u2018\\n=================\\n\\nContent\\n\\n Subheading\\n----------\\n\u2019 > docs/mypackage.rst $ echo -e \u2019rst_prolog = \"\"\"\\n.. |psf| replace:: Python Software Foundation\\n\"\"\"\\n\u2019 >> docs/conf.py $ sphinx-build -b html . _build $ grep \u2019mypackage2\u2019 docs/_build/index.html"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py --- a/sphinx/util/rst.py +++ b/sphinx/util/rst.py @@ -25,7 +25,7 @@\nlogger = logging.getLogger(__name__) -docinfo_re = re.compile(\u2019:\\\\w+:.*?\u2019) +docinfo_re = re.compile(\u2019:\\\\w+:.*?\\n\u2019) symbols_re = re.compile(r\u2019([!-\\-/:-@\\[-\u2018{-\u02dc])\u2019) SECTIONING_CHARS = [\u2019=\u2019, \u2019-\u2019, \u2019\u02dc\u2019]"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (2)\ntests/test_util_rst.py::test_prepend_prolog_with_roles_with_newline tests/test_util_rst.py::test_prepend_prolog_with_roles_without_newline\nPass to Pass (8) tests/test_util_rst.py::test_prepend_prolog tests/test_util_rst.py::test_prepend_prolog_with_CR tests/test_util_rst.py::test_prepend_prolog_without_CR\nAdditional Pass to Pass Tests omitted..."
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py --- a/sphinx/util/rst.py +++ b/sphinx/util/rst.py @@ -10,22 +10,17 @@\nfrom docutils.parsers.rst import roles from docutils.parsers.rst.languages import en as english +from docutils.parsers.rst.states import Body from docutils.statemachine import StringList from docutils.utils import Reporter -from jinja2 import Environment +from jinja2 import Environment, pass_environment\nfrom sphinx.locale import __ from sphinx.util import docutils, logging\n-try: - from jinja2.utils import pass_environment -except ImportError: - from jinja2 import environmentfilter as pass_environment - - logger = logging.getLogger(__name__)\n-docinfo_re = re.compile(\u2019:\\\\w+:.*?\u2019) +FIELD_NAME_RE = re.compile(Body.patterns[\u2019field_marker\u2019]) symbols_re = re.compile(r\u2019([!-\\-/:-@\\[-\u2018{-\u02dc])\u2019) # symbols without dot(0\nx2e) SECTIONING_CHARS = [\u2019=\u2019, \u2019-\u2019, \u2019\u02dc\u2019]\n@@ -80,7 +75,7 @@ def prepend_prolog(content: StringList, prolog: str) -> None: if prolog:\npos = 0 for line in content:\n- if docinfo_re.match(line): + if FIELD_NAME_RE.match(line):\npos += 1 else:\nbreak @@ -91,6 +86,7 @@ def prepend_prolog(content: StringList, prolog: str) ->\nNone: pos += 1\n# insert prolog (after docinfo if exists) + lineno = 0\nfor lineno, line in enumerate(prolog.splitlines()): content.insert(pos + lineno, line, \u2019<rst_prolog>\u2019, lineno)\nDiscussion. For this task instance from the sphinx-doc/sphinx repository, a model is asked to write logic to fix a case where the title is incorrectly being rendered. Simply understanding the jargon being used and mapping such words to logic within the codebase is a significant challenge faced by the model. The model is given a command line call that can help with this, but grounding the terminology presented in the issues within the codebase is essential. From comparing the gold patch and model generated patch, it is clear that the model does not come close to solving the task. The model does generally identify that fixing the regex pattern is the correct action, as this is what the gold patch does, too. However, where the model and oracle retrieval setting collectively fall short is mainly due to the significant use of additional modules from both the codebase itself and third party libraries. This example highlights the importance and potential for training language models and designing inference procedures that allow for the automated discovery of such information."
        },
        {
            "heading": "Setting",
            "text": ""
        },
        {
            "heading": "Issue",
            "text": "Differences among the results of KernelPCA with rbf kernel\n#### Description When I run KernelPCA for dimension reduction for the same datasets, the results are different in signs.\n#### Steps/Code to Reproduce Just to reduce the dimension to 7 with rbf kernel: pca = KernelPCA(n_components=7, kernel=\u2019rbf\u2019, copy_X=False, n_jobs=-1) pca.fit_transform(X)\n#### Expected Results The same result.\n#### Actual Results The results are the same except for their signs: [[-0.44457 -0.18155 -0.10873 0.13548 -0.14371 -0.05746 0.18124]] [[ 0.44457 0.18155 0.10873 -0.13548 -0.14371 -0.05746 -0.18124]] [[-0.44457 -0.18155 0.10873 0.13548 0.14371 0.057469 0.18124]]"
        },
        {
            "heading": "Gold Patch",
            "text": "diff --git a/sklearn/decomposition/kernel_pca.py b/sklearn/decompos... --- a/sklearn/decomposition/kernel_pca.py +++ b/sklearn/decomposition/kernel_pca.py @@ -8,6 +8,7 @@ from scipy.sparse.linalg import eigsh\nfrom ..utils import check_random_state +from ..utils.extmath import svd_flip from ..utils.validation import check_is_fitted, check_array from ..exceptions import NotFittedError from ..base import BaseEstimator, TransformerMixin, _UnstableOn32BitMixin @@ -210,6 +211,10 @@ def _fit_transform(self, K):\nmaxiter=self.max_iter, v0=v0)\n+ # flip eigenvectors\u2019 sign to enforce deterministic output + self.alphas_, _ = svd_flip(self.alphas_, + np.empty_like(self.alphas_).T) +\n# sort eigenvectors in descending order indices = self.lambdas_.argsort()[::-1] self.lambdas_ = self.lambdas_[indices]"
        },
        {
            "heading": "Model Generated Patch",
            "text": "diff --git a/sklearn/decomposition/kernel_pca.py b/sklearn/decompos... --- a/sklearn/decomposition/kernel_pca.py +++ b/sklearn/decomposition/kernel_pca.py @@ -220,7 +220,7 @@ def _fit_transform(self, K):\nself.alphas_ = self.alphas_[:, self.lambdas_ > 0] self.lambdas_ = self.lambdas_[self.lambdas_ > 0]\n- return K + return K / self.lambdas_\ndef _fit_inverse_transform(self, X_transformed, X): if hasattr(X, \"tocsr\"):"
        },
        {
            "heading": "Tests",
            "text": "Fail to Pass (1)\nsklearn/tests/test_kernel_pca.py::test_kernel_pca_deterministic_output\nPass to Pass (54) sklearn/tests/test_kernel_pca.py::test_kernel_pca sklearn/tests/test_kernel_pca.py::test_kernel_pca_consistent_transform sklearn/tests/test_kernel_pca.py::test_kernel_pca_deterministic_output sklearn/tests/test_kernel_pca.py::test_kernel_pca_sparse sklearn/tests/test_kernel_pca.py::test_kernel_pca_linear_kernel sklearn/tests/test_kernel_pca.py::test_kernel_pca_n_components sklearn/tests/test_kernel_pca.py::test_remove_zero_eig sklearn/tests/test_kernel_pca.py::test_kernel_pca_precomputed sklearn/tests/test_kernel_pca.py::test_gridsearch_pipeline sklearn/tests/test_kernel_pca.py::test_gridsearch_pipeline_precomputed sklearn/tests/test_pca.py::test_pca_dtype_preservation[randomized] sklearn/tests/test_pca.py::test_pca_dtype_preservation[auto] sklearn/tests/test_pca.py::test_pca_deterministic_output\nAdditional Pass to Pass Tests omitted...\nDiscussion. In this example from the scikit-learn/scikit-learn library, a model is given an observation that the parities of the output from a call to the fit_transform function are flipped. The model is also given lines of Python code and its standard output that recreates the issue. The gold patch imports and uses the svd_flip function to solve this issue within a different line of the _fit_transform function. What\u2019s different about the model\u2019s failure for this task beyond the points discussed for the Table 33 example is that, in addition to understanding third party dependencies that its edits rely on, it is also important for a model to understand what other parts of the codebase in turn depend on the function it is changing. This example presents a different facet as to why processing long contexts extend beyond the local edit scope is a difficult but worthwhile challenge."
        }
    ],
    "title": "SWE-BENCH: CAN LANGUAGE MODELS RESOLVE REAL-WORLD GITHUB ISSUES?",
    "year": 2024
}