{
    "abstractText": "Continual learning has gained increasing importance as it facilitates the acquisition and refinement of scalable knowledge and skills in language models. However, existing methods typically encounter strict limitations and challenges in real-world scenarios, such as reliance on experience replay, optimization constraints, and inference task-ID. In this study, we introduce the Scalable Language Model (SLM) to overcome these limitations within a more challenging and generalized setting, representing a significant advancement toward practical applications for continual learning. Specifically, we propose the Joint Adaptive ReParameterization (JARe), integrated with Dynamic Task-related Knowledge Retrieval (DTKR), to enable adaptive adjustment of language models based on specific downstream tasks. This approach leverages the task distribution within the vector space, aiming to achieve a smooth and effortless continual learning process. Our method demonstrates state-of-the-art performance on diverse backbones and benchmarks, achieving effective continual learning in both full-set and few-shot scenarios with minimal forgetting. Moreover, while prior research primarily focused on a single task type such as classification, our study goes beyond, with the large language model, i.e., LLaMA-2, to explore the effects across diverse domains and task types, such that a single language model can be decently scaled to broader applications. The code is available on the project website1.",
    "authors": [
        {
            "affiliations": [],
            "name": "CONTINUAL LEARNING"
        },
        {
            "affiliations": [],
            "name": "Bohao PENG"
        },
        {
            "affiliations": [],
            "name": "Zhuotao TIAN"
        },
        {
            "affiliations": [],
            "name": "Shu LIU"
        },
        {
            "affiliations": [],
            "name": "Mingchang YANG"
        },
        {
            "affiliations": [],
            "name": "Jiaya JIA"
        }
    ],
    "id": "SP:1d761ac60fd1b77c1c0bf6cf7c13a9da26c7f65a",
    "references": [
        {
            "authors": [
                "Rahaf Aljundi",
                "Francesca Babiloni",
                "Mohamed Elhoseiny",
                "Marcus Rohrbach",
                "Tinne Tuytelaars"
            ],
            "title": "Memory aware synapses: Learning what (not) to forget",
            "venue": "In Proceedings of the European conference on computer vision (ECCV),",
            "year": 2018
        },
        {
            "authors": [
                "Michael W Berry",
                "Zlatko Drmac",
                "Elizabeth R Jessup"
            ],
            "title": "Matrices, vector spaces, and information retrieval",
            "venue": "SIAM review,",
            "year": 1999
        },
        {
            "authors": [
                "Yonatan Bisk",
                "Rowan Zellers",
                "Ronan Le Bras",
                "Jianfeng Gao",
                "Yejin Choi"
            ],
            "title": "Piqa: Reasoning about physical commonsense in natural language",
            "venue": "In Thirty-Fourth AAAI Conference on Artificial Intelligence,",
            "year": 2020
        },
        {
            "authors": [
                "Arslan Chaudhry",
                "Puneet K Dokania",
                "Thalaiyasingam Ajanthan",
                "Philip HS Torr"
            ],
            "title": "Riemannian walk for incremental learning: Understanding forgetting and intransigence",
            "venue": "In Proceedings of the European conference on computer vision (ECCV),",
            "year": 2018
        },
        {
            "authors": [
                "Jiaao Chen",
                "Zichao Yang",
                "Diyi Yang"
            ],
            "title": "Mixtext: Linguistically-informed interpolation of hidden space for semi-supervised text classification",
            "venue": "arXiv preprint arXiv:2004.12239,",
            "year": 2020
        },
        {
            "authors": [
                "Peter Clark",
                "Isaac Cowhey",
                "Oren Etzioni",
                "Tushar Khot",
                "Ashish Sabharwal",
                "Carissa Schoenick",
                "Oyvind Tafjord"
            ],
            "title": "Think you have solved question answering? try arc, the ai2 reasoning challenge",
            "venue": "arXiv preprint arXiv:1803.05457,",
            "year": 2018
        },
        {
            "authors": [
                "Taner Danisman",
                "Adil Alpkocak"
            ],
            "title": "Feeler: Emotion classification of text using vector space model",
            "venue": "In AISB 2008 convention communication, interaction and social intelligence,",
            "year": 2008
        },
        {
            "authors": [
                "Cyprien de Masson D\u2019Autume",
                "Sebastian Ruder",
                "Lingpeng Kong",
                "Dani Yogatama"
            ],
            "title": "Episodic memory in lifelong language learning",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2019
        },
        {
            "authors": [
                "Jacob Devlin",
                "Ming-Wei Chang",
                "Kenton Lee",
                "Kristina Toutanova. Bert"
            ],
            "title": "Pre-training of deep bidirectional transformers for language understanding",
            "venue": "arXiv preprint arXiv:1810.04805,",
            "year": 2018
        },
        {
            "authors": [
                "Chelsea Finn",
                "Pieter Abbeel",
                "Sergey Levine"
            ],
            "title": "Model-agnostic meta-learning for fast adaptation of deep networks",
            "venue": "In International conference on machine learning,",
            "year": 2017
        },
        {
            "authors": [
                "Leo Gao",
                "Jonathan Tow",
                "Stella Biderman",
                "Sid Black",
                "Anthony DiPofi",
                "Charles Foster",
                "Laurence Golding",
                "Jeffrey Hsu",
                "Kyle McDonell",
                "Niklas Muennighoff"
            ],
            "title": "A framework for few-shot language model evaluation",
            "venue": "Version v0",
            "year": 2021
        },
        {
            "authors": [
                "Tianxing He",
                "Jun Liu",
                "Kyunghyun Cho",
                "Myle Ott",
                "Bing Liu",
                "James Glass",
                "Fuchun Peng"
            ],
            "title": "Analyzing the forgetting problem in pretrain-finetuning of open-domain dialogue response models",
            "venue": "In Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume,",
            "year": 2021
        },
        {
            "authors": [
                "Dan Hendrycks",
                "Collin Burns",
                "Steven Basart",
                "Andrew Critch",
                "Jerry Li",
                "Dawn Song",
                "Jacob Steinhardt"
            ],
            "title": "Aligning ai with shared human values",
            "venue": "Proceedings of the International Conference on Learning Representations (ICLR),",
            "year": 2021
        },
        {
            "authors": [
                "Dan Hendrycks",
                "Collin Burns",
                "Steven Basart",
                "Andy Zou",
                "Mantas Mazeika",
                "Dawn Song",
                "Jacob Steinhardt"
            ],
            "title": "Measuring massive multitask language understanding",
            "venue": "Proceedings of the International Conference on Learning Representations (ICLR),",
            "year": 2021
        },
        {
            "authors": [
                "Neil Houlsby",
                "Andrei Giurgiu",
                "Stanislaw Jastrzebski",
                "Bruna Morrone",
                "Quentin De Laroussilhe",
                "Andrea Gesmundo",
                "Mona Attariyan",
                "Sylvain Gelly"
            ],
            "title": "Parameter-efficient transfer learning for nlp",
            "venue": "In International Conference on Machine Learning,",
            "year": 2019
        },
        {
            "authors": [
                "Edward J Hu",
                "Yelong Shen",
                "Phillip Wallis",
                "Zeyuan Allen-Zhu",
                "Yuanzhi Li",
                "Shean Wang",
                "Lu Wang",
                "Weizhu Chen"
            ],
            "title": "Lora: Low-rank adaptation of large language models",
            "venue": "arXiv preprint arXiv:2106.09685,",
            "year": 2021
        },
        {
            "authors": [
                "Yufan Huang",
                "Yanzhe Zhang",
                "Jiaao Chen",
                "Xuezhi Wang",
                "Diyi Yang"
            ],
            "title": "Continual learning for text classification with information disentanglement based regularization",
            "venue": "arXiv preprint arXiv:2104.05489,",
            "year": 2021
        },
        {
            "authors": [
                "Xiang Lisa Li",
                "Percy Liang"
            ],
            "title": "Prefix-tuning: Optimizing continuous prompts for generation",
            "venue": "arXiv preprint arXiv:2101.00190,",
            "year": 2021
        },
        {
            "authors": [
                "Yunxiang Li",
                "Zihan Li",
                "Kai Zhang",
                "Ruilong Dan",
                "Steve Jiang",
                "You Zhang"
            ],
            "title": "Chatdoctor: A medical chat model fine-tuned on a large language model meta-ai (llama) using medical domain knowledge",
            "year": 2023
        },
        {
            "authors": [
                "Ilya Loshchilov",
                "Frank Hutter"
            ],
            "title": "Decoupled weight decay regularization",
            "venue": "arXiv preprint arXiv:1711.05101,",
            "year": 2017
        },
        {
            "authors": [
                "Andrea Madotto",
                "Zhaojiang Lin",
                "Zhenpeng Zhou",
                "Seungwhan Moon",
                "Paul Crook",
                "Bing Liu",
                "Zhou Yu",
                "Eunjoon Cho",
                "Zhiguang Wang"
            ],
            "title": "Continual learning in task-oriented dialogue systems",
            "year": 2012
        },
        {
            "authors": [
                "Arun Mallya",
                "Svetlana Lazebnik"
            ],
            "title": "Packnet: Adding multiple tasks to a single network by iterative pruning",
            "venue": "In Proceedings of the IEEE conference on Computer Vision and Pattern Recognition,",
            "year": 2018
        },
        {
            "authors": [
                "Michael McCloskey",
                "Neal J Cohen"
            ],
            "title": "Catastrophic interference in connectionist networks: The sequential learning problem",
            "venue": "In Psychology of learning and motivation,",
            "year": 1989
        },
        {
            "authors": [
                "Bohao Peng",
                "Zhuotao Tian",
                "Xiaoyang Wu",
                "Chengyao Wang",
                "Shu Liu",
                "Jingyong Su",
                "Jiaya Jia"
            ],
            "title": "Hierarchical dense correlation distillation for few-shot segmentation",
            "venue": "In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition,",
            "year": 2023
        },
        {
            "authors": [
                "Chengwei Qin",
                "Shafiq Joty"
            ],
            "title": "Lfpt5: A unified framework for lifelong few-shot language learning based on prompt tuning of t5",
            "venue": "arXiv preprint arXiv:2110.07298,",
            "year": 2021
        },
        {
            "authors": [
                "Colin Raffel",
                "Noam Shazeer",
                "Adam Roberts",
                "Katherine Lee",
                "Sharan Narang",
                "Michael Matena",
                "Yanqi Zhou",
                "Wei Li",
                "Peter J Liu"
            ],
            "title": "Exploring the limits of transfer learning with a unified text-to-text transformer",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2020
        },
        {
            "authors": [
                "Jeff Rasley",
                "Samyam Rajbhandari",
                "Olatunji Ruwase",
                "Yuxiong He"
            ],
            "title": "Deepspeed: System optimizations enable training deep learning models with over 100 billion parameters",
            "venue": "In Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining,",
            "year": 2020
        },
        {
            "authors": [
                "Anastasia Razdaibiedina",
                "Yuning Mao",
                "Rui Hou",
                "Madian Khabsa",
                "Mike Lewis",
                "Amjad Almahairi"
            ],
            "title": "Progressive prompts: Continual learning for language models",
            "venue": "arXiv preprint arXiv:2301.12314,",
            "year": 2023
        },
        {
            "authors": [
                "Sylvestre-Alvise Rebuffi",
                "Alexander Kolesnikov",
                "Georg Sperl",
                "Christoph H Lampert"
            ],
            "title": "icarl: Incremental classifier and representation learning",
            "venue": "In Proceedings of the IEEE conference on Computer Vision and Pattern Recognition,",
            "year": 2017
        },
        {
            "authors": [
                "Nils Reimers",
                "Iryna Gurevych"
            ],
            "title": "Sentence-bert: Sentence embeddings using siamese bertnetworks",
            "venue": "arXiv preprint arXiv:1908.10084,",
            "year": 2019
        },
        {
            "authors": [
                "Alexey Romanov",
                "Anna Rumshisky",
                "Anna Rogers",
                "David Donahue"
            ],
            "title": "Adversarial decomposition of text representation",
            "venue": "arXiv preprint arXiv:1808.09042,",
            "year": 2018
        },
        {
            "authors": [
                "Keisuke Sakaguchi",
                "Ronan Le Bras",
                "Chandra Bhagavatula",
                "Yejin Choi"
            ],
            "title": "Winogrande: An adversarial winograd schema challenge at scale",
            "venue": "Communications of the ACM,",
            "year": 2021
        },
        {
            "authors": [
                "Andrew M Saxe",
                "James L McClelland",
                "Surya Ganguli"
            ],
            "title": "Exact solutions to the nonlinear dynamics of learning in deep linear neural networks",
            "venue": "arXiv preprint arXiv:1312.6120,",
            "year": 2013
        },
        {
            "authors": [
                "Hanul Shin",
                "Jung Kwon Lee",
                "Jaehong Kim",
                "Jiwon Kim"
            ],
            "title": "Continual learning with deep generative replay",
            "venue": "Advances in neural information processing systems,",
            "year": 2017
        },
        {
            "authors": [
                "Amit Singhal"
            ],
            "title": "Modern information retrieval: A brief overview",
            "venue": "IEEE Data Eng. Bull.,",
            "year": 2001
        },
        {
            "authors": [
                "Rohan Taori",
                "Ishaan Gulrajani",
                "Tianyi Zhang",
                "Yann Dubois",
                "Xuechen Li",
                "Carlos Guestrin",
                "Percy Liang",
                "Tatsunori B. Hashimoto"
            ],
            "title": "Stanford alpaca: An instruction-following llama model",
            "venue": "https://github.com/tatsu-lab/stanford_alpaca,",
            "year": 2023
        },
        {
            "authors": [
                "Hugo Touvron",
                "Louis Martin",
                "Kevin Stone",
                "Peter Albert",
                "Amjad Almahairi",
                "Yasmine Babaei",
                "Nikolay Bashlykov",
                "Soumya Batra",
                "Prajjwal Bhargava",
                "Shruti Bhosale"
            ],
            "title": "Llama 2: Open foundation and fine-tuned chat models",
            "venue": "arXiv preprint arXiv:2307.09288,",
            "year": 2023
        },
        {
            "authors": [
                "Eleni Triantafillou",
                "Hugo Larochelle",
                "Richard Zemel",
                "Vincent Dumoulin"
            ],
            "title": "Learning a universal template for few-shot dataset generalization",
            "venue": "In International Conference on Machine Learning,",
            "year": 2021
        },
        {
            "authors": [
                "Laurens Van der Maaten",
                "Geoffrey Hinton"
            ],
            "title": "Visualizing data using t-sne",
            "venue": "Journal of machine learning research,",
            "year": 2008
        },
        {
            "authors": [
                "Ashish Vaswani",
                "Noam Shazeer",
                "Niki Parmar",
                "Jakob Uszkoreit",
                "Llion Jones",
                "Aidan N Gomez",
                "\u0141ukasz Kaiser",
                "Illia Polosukhin"
            ],
            "title": "Attention is all you need",
            "venue": "Advances in neural information processing systems,",
            "year": 2017
        },
        {
            "authors": [
                "Zifeng Wang",
                "Zizhao Zhang",
                "Chen-Yu Lee",
                "Han Zhang",
                "Ruoxi Sun",
                "Xiaoqi Ren",
                "Guolong Su",
                "Vincent Perot",
                "Jennifer Dy",
                "Tomas Pfister"
            ],
            "title": "Learning to prompt for continual learning",
            "venue": "In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition,",
            "year": 2022
        },
        {
            "authors": [
                "Zirui Wang",
                "Sanket Vaibhav Mehta",
                "Barnab\u00e1s P\u00f3czos",
                "Jaime Carbonell"
            ],
            "title": "Efficient meta lifelonglearning with limited memory",
            "venue": "arXiv preprint arXiv:2010.02500,",
            "year": 2020
        },
        {
            "authors": [
                "Thomas Wolf",
                "Lysandre Debut",
                "Victor Sanh",
                "Julien Chaumond",
                "Clement Delangue",
                "Anthony Moi",
                "Pierric Cistac",
                "Tim Rault",
                "R\u00e9mi Louf",
                "Morgan Funtowicz"
            ],
            "title": "Transformers: State-of-the-art natural language processing",
            "venue": "In Proceedings of the 2020 conference on empirical methods in natural language processing: system demonstrations,",
            "year": 2020
        },
        {
            "authors": [
                "S.K. Michael Wong",
                "Wojciech Ziarko",
                "Vijay V. Raghavan",
                "Patrick CN Wong"
            ],
            "title": "On modeling of information retrieval concepts in vector spaces",
            "venue": "ACM Transactions on Database Systems (TODS),",
            "year": 1987
        },
        {
            "authors": [
                "Mitchell Wortsman",
                "Gabriel Ilharco",
                "Samir Ya Gadre",
                "Rebecca Roelofs",
                "Raphael Gontijo-Lopes",
                "Ari S Morcos",
                "Hongseok Namkoong",
                "Ali Farhadi",
                "Yair Carmon",
                "Simon Kornblith"
            ],
            "title": "Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time",
            "venue": "In International Conference on Machine Learning,",
            "year": 2022
        },
        {
            "authors": [
                "Dengsheng Zhang",
                "Guojun Lu"
            ],
            "title": "Evaluation of similarity measurement for image retrieval",
            "venue": "In International Conference on Neural Networks and Signal Processing,",
            "year": 2003
        },
        {
            "authors": [
                "Renrui Zhang",
                "Jiaming Han",
                "Aojun Zhou",
                "Xiangfei Hu",
                "Shilin Yan",
                "Pan Lu",
                "Hongsheng Li",
                "Peng Gao",
                "Yu Qiao"
            ],
            "title": "Llama-adapter: Efficient fine-tuning of language models with zero-init attention",
            "venue": "arXiv preprint arXiv:2303.16199,",
            "year": 2023
        },
        {
            "authors": [
                "Tianyi Zhang",
                "Varsha Kishore",
                "Felix Wu",
                "Kilian Q Weinberger",
                "Yoav Artzi"
            ],
            "title": "Bertscore: Evaluating text generation with bert",
            "year": 1904
        },
        {
            "authors": [
                "Xiang Zhang",
                "Junbo Zhao",
                "Yann LeCun"
            ],
            "title": "Character-level convolutional networks for text classification",
            "venue": "Advances in neural information processing systems,",
            "year": 2015
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "Human-level intelligence demonstrates the remarkable ability to continuously acquire new knowledge and skills while retaining previously learned information. Although deep learning in language models has achieved significant advancements recently, it still faces challenges in retaining and accumulating knowledge when dealing with sequential tasks. It is also known as the \u201ccatastrophic forgetting\u201d phenomenon, which refers to the potential loss of previously learned information caused by the distribution shift during the fine-tuning process for novel tasks (McCloskey & Cohen, 1989).\nDespite considerable efforts to tackle the aforementioned challenges, recent studies on continual learning in language models still encounter significant limitations. Specifically, shown in Fig. 1 (a), the replay-based methods (Rebuffi et al., 2017; Romanov et al., 2018), require access to the previously learned data, leading to additional demands on resources for continual training. This approach also raises potential privacy concerns. Then, the regularization-based approaches Huang et al. (2021); Aljundi et al. (2018) (Fig. 1 (b)) exhibit vulnerability in long task sequences and struggle to strike a balance between forgetting and adaptability to specific tasks. And, certain architecturebased methods (Razdaibiedina et al., 2023) (Fig. 1 (c)) rely on task-ID during inference, which poses challenges in practical scenarios where obtaining task-IDs for individual runs may not be feasible. Besides, most previous methods have primarily focused on a single task type, such as text classification, neglecting the broader spectrum of language-related tasks (Qin & Joty, 2021). These issues deprecate the efficacy and greatly hinder the practical applications of continual learning.\nIn this paper, our objective is to extend the application of continual learning to a more practical and generalized setting without relying on experience replay, optimization constraints, or inference taskID, which enables agile adaptation to novel tasks. To this end, we propose the Scalable Language\n1https://github.com/Pbihao/SLM 2Correspondence to Zhuotao Tian(tianzhuotao@gmail.com).\nModel (SLM), which efficiently scales base language model to novel tasks in different domains without compromising the performance of the witnessed ones.\nSLM incorporates vector space retrieval into the language model, which aids in achieving scalable knowledge expansion and management, ultimately enhancing its capabilities and skill set. It comprises two primary components: Joint Adaptive Re-parameterization (JARe) and Dynamic Taskrelated Knowledge Retrieval (DTKR). Assuming that each task is associated with a distinct distribution in the vector space (Finn et al., 2017), the DTKR technique is utilized to identify the most relevant knowledge for each input instance. The relevant knowledge is preserved as a compilation of weight increments that leverage low-rank adaptation techniques to mitigate computational expenses (Hu et al., 2021). Then, these weight increments are employed by JARe techniques to achieve adaptive re-parameterization of the pre-trained model, with the objective of effectively aligning it with specific downstream tasks according to the task distribution.\nExtensive experiments demonstrate remarkable efficacy and stability of our method on widely recognized benchmarks, reaching state-of-the-art performance on various models, including BERT, T5 and the latest LLaMA-2 (Devlin et al., 2018; Qin & Joty, 2021; Touvron et al., 2023). Our method achieves an impressive up to 80% reduction in forgetting, with only a minimal 0.5% performance degradation on the BERT benchmark. Unlike previous literature that primarily focuses on a single task like classification, our study pushes the boundaries by exploring continual learning across multiple task types in various domains. This comprehensive analysis highlights the superior generalization ability of our approach, making it applicable to a wider range of real-world applications.\nIn summary, the primary contributions of this paper can be summarized as follows:\n\u2022 We propose the Scalable Language Model (SLM) as a model-agnostic solution for scalable acquisition of knowledge and skills. SLM eliminates dependencies on experience replay, optimization constraints, and inference task-IDs in a generalized continual learning setting.\n\u2022 SLM incorporates vector space retrieval into the language model, with two primary components: Joint Adaptive Re-parameterization (JARe) and Dynamic Task-related Knowledge Retrieval (DTKR). Extensive experiments conducted on standard continual learning benchmarks demonstrate its remarkable superiority over previous state-of-the-art methods.\n\u2022 Our study goes beyond previous literature by exploring continual learning across multiple task types from diverse domains, showcasing the superior generalization ability."
        },
        {
            "heading": "2 PRELIMINARIES",
            "text": "Continual learning aims to facilitate ongoing knowledge acquisition from sequential tasks while mitigating the issue of catastrophic forgetting. Specifically, the language model is exposed to a sequence of M tasks denoted as T = {T 1, . . . , T M}. Each task T t consists of a collection of training samples {(xti, yti)} Nt i=1, where x t i represents the input instance, and y t i denotes its corresponding label. Assuming that the language model is parameterized by \u03b8 and the loss function is L, the learning objective across all tasks is to minimize the generalization error:\nargmin \u03b8 M\u2211 t=1 \u2211 (xt,yt)\u2208T t L(f\u03b8(xt), yt) (1)\nHowever, current continual learning approaches always encounter practical limitations and challenges due to their stringent constraints, which are difficult to achieve in real-life scenarios.\nGeneralized continual learning. We propose addressing this challenging problem in a more generalized setting, which effectively eliminates auxiliary operations by solely leveraging new task data, and encompasses a wider range of task types. Our goal is to achieve incremental knowledge acquisition and retention without relying on experience replay of past data, model optimization constraints, or artificial auxiliary information. Furthermore, unlike prior methods that are primarily limited to single tasks such as classification, we extend the scope of our approach to encompass diverse domains and task types within the broader spectrum of language-related tasks. This expansion allows for a more comprehensive and practical application of our proposed methodology."
        },
        {
            "heading": "3 SCALABLE LANGUAGE MODEL",
            "text": "In this study, we introduce two novel techniques, namely Joint Adaptive Re-parameterization (JARe) and Dynamic Task-related Knowledge Retrieval (DTKR), which are detailed in Sec. 3.1 and Sec. 3.2 respectively. JARe dynamically adjusts the model\u2019s weights to suit various task contexts, leveraging the knowledge priors obtained from DTKR. This adaptive mechanism enables effective scaling of the language model as illustrated in Fig. 2. Consequently, we refer to any language model that efficiently integrates and extends novel knowledge using JARe and DTKR techniques as the Scalable Language Model (SLM)."
        },
        {
            "heading": "3.1 JOINT ADAPTIVE RE-PARAMETERIZATION",
            "text": "Efficient tuning for continual learning. Recent research has shown that optimizing a small subset of the model or incorporating minimal trainable parameters enables the pre-trained model to adapt to downstream tasks (Li & Liang, 2021; Houlsby et al., 2019). Based on this, recent continual learning methods have proposed to incrementally incorporate new parameters like prompts for sequential tasks while keeping the pre-trained models frozen (Razdaibiedina et al., 2023; Qin & Joty, 2021; Wang et al., 2022; Madotto et al., 2020). However, they still face certain limitations:\n\u2022 Appending new parameters without pre-training may result in convergence challenges, performance degradation, and increased cost. Especially when scaling up to large language models and long prompts (Li & Liang, 2021; Hu et al., 2021), it can introduce additional training challenges.\n\u2022 The new parameters are commonly stacked and accumulated together without distinguishing or relying on task-IDs before being incorporated into the model. These approaches (Razdaibiedina et al., 2023; Qin & Joty, 2021; Wang et al., 2022) still lack the capability to adaptively adjust the importance of each element based on the task distribution.\nMore discussions regarding the parameter-efficient tuning methods can be found in Appendix A.5.\nJoint adaptive re-parameterization. To address these challenges, we propose an alternative model-agnostic approach called Joint Adaptive Re-parameterization (JARe), which adaptively reparameterizes pretrained models to effectively adapt to downstream tasks based on the joint task distribution. Let f\u03b8 represent the pretrained model, which is parametrized with the initial parameters \u03b8. The goal during fine-tuning is to adapt the language model to a specific downstream task T\nusing gradient-based learning. This adaptation is guided by the following objective:\nargmin \u03b8\u2032 \u2211 (x,y)\u2208T LT (f\u03b8\u2032(x), y), \u03b8\u2032 = \u03b8 +\u2206\u03b8, (2)\nwhere LT denotes the loss function specific to task T , and \u2206\u03b8 represents the weight increment. We regard the process of assigning the corresponding weight increment from memory to fit a specific instance as the \u201cadaptive re-parameterization\u201d.\nDirectly preserving all weight increments of the pre-trained models would result in excessive resource consumption. Therefore, following Hu et al. (2021), we only selectively update minimal weight matrices in the dense layers and leverage low-rank adaptation technique to achieve additional cost savings. Consider a specific pre-trained weight matrix of the linear layer W0. It is updated as:\ny = W \u2032x = (W0 +\u2206W )x = (W0 +BA)x, (3)\nwhere W0 \u2208 Rd\u00d7k is frozen, B \u2208 Rd\u00d7r and A \u2208 Rr\u00d7k are trainable parameters, and r \u226a min(d, k). Thus each task only requires minimal trainable parameters and utilizes acceptable memory. More implementation details can be found in A.6 in the appendix.\nSubsequently, we introduce the process of adaptively re-parameterizing the pre-trained models based on the joint task distribution. In the context of a specific task T t, the corresponding task distribution is denoted as pt. Thus, after learning a sequence of tasks, a set of weight increments {\u2206\u03b81, ...,\u2206\u03b8M} is derived, where each increment is associated with one of the M distributions, namely {p1, ..., pM}. Given a specific instance x drawn from the distribution p, i.e. x \u223c p, the objective is to adapt the pretrained model f\u03b8 to the corresponding distribution, resulting in f\u03b8 \u2192 f\u03b8+\u2206\u03b8p . Given the discrete nature of preserved values, direct computation of precise weight increments in continuous space is infeasible. Consequently, we resort to utilizing a set of interrelated elements to approximate and estimate similar, similar to the linear interpolations used in meta-learning Triantafillou et al. (2021). To be specific, we first employ the K-nearest neighbors (KNN) algorithm to select a subset of K weight increments from the most relevant distributions, denoted as {\u2206\u03b81, ...,\u2206\u03b8K}, where K \u2264 M . Then, the pre-trained models are re-parametrized towards the target task as shown in Fig 2(c), which can be formulated as:\n\u03b8\u2032 = \u03b8 +\u2206\u03b8p = \u03b8 + \u2211K i=1D(p, pi) \u00b7\u2206\u03b8i\u2211K\ni=1D(p, pi) (4)\nHere, D(\u00b7) represents the function that measures the correlation between two distributions. In practice, we approximate the correlation by using query-key similarity distance.\nDiscussion. A single dataset can also be allocated and partitioned into multiple distributions. In practical scenarios, there are situations where the model may inadvertently retrieve unrelated or incorrect information, resulting in the erroneously selected information and worse performance. The proposed JARe effectively alleviates this issue by employing joint re-parameterization that reaches a consensus among multiple feasible directions for optimization, thus mitigating the negative impacts. Moreover, it is noteworthy that even different datasets can often share transferable knowledge. This approach leverages the shared common knowledge among closely related tasks to enhance the model\u2019s performance and improve its generalization ability."
        },
        {
            "heading": "3.2 DYNAMIC TASK-RELATED KNOWLEDGE RETRIEVAL",
            "text": "Overview. This section outlines the process of retrieving the most relevant knowledge. As previously mentioned, the sequentially learned knowledge can be represented as a collection of weight increments {\u2206\u03b81, ...,\u2206\u03b8M}. Subsequently, each \u2206\u03b8i is correlated with a key vector ki \u2208 Rc (i \u2208 1, ...,M ), which serves to estimate the centroid of its corresponding task distribution pi. This forms the key-value pair, i.e., [ki,\u2206\u03b8i]. During the inference phase, given query obtained from the input, the proposed Dynamic Task-related Knowledge Retrieval (DTKR) identifies the most relevant pairs based on the correlations between the query and key vectors and then re-parameterizes the pretrained model using the corresponding values as Eq. 4. As for the training phase, we divide it into the preparation stage and the fine-tune stage. The preparation stage exclusively serves the purpose of keys generation. In the subsequent fine-tune stage, the keys are frozen, and the values are utilized for fine-tuning specific tasks, which follows the same procedure as the inference phase.\nKeys generation and knowledge retrieval. To begin, we initialize a set of learnable parameters with a (semi) orthogonal matrix, following the methodology described in Saxe et al. (2013); Wang et al. (2022). This initialization yields a collection of initial keys, ensuring orthogonality between any two keys within the set. After that, given a tokenized input x, we employ Sentence-BERT (Reimers & Gurevych, 2019), denoted as fs, to extract its semantic features. This extraction process maps the original text x to a hidden feature space, resulting in the generation of the query vector q. Mathematically, this process can be represented as q = fs(x) (x \u2208 Rl\u00d7c, q \u2208 Rc ), where l represents the sequence length and c denotes the number of channels. It is important to note that, to maintain consistency in the mapping process during training, fs remains frozen and unchanged.\nThen, we calculate the correlations between the query and keys, and employ the K-nearest neighbors algorithm to retrieve the top K most similar keys Kq = {k1, . . . ,kK}, where K \u2264 M . The cosine similarity distance is utilized as the metric to measure the distance between the query and the keys.\nDuring the preparation stage, the selected keys Kq undergo optimization to improve their alignment with the distribution of input instances and perform centroid estimation. The other unselected keys remain unchanged and are not affected, which can be written as:\nk\u2032 \u2190 k + \u03b3\u2207kcos(q,k), k \u2208 Kq, (5) where \u03b3 is the learning rate and cos(\u00b7) represents the cosine similarity. However, directly utilizing such an operation for keys generation may inadvertently result in getting stuck in a local optimum, as elaborated in Appendix A.8. This occurs when only a subset of keys is constantly selected and optimized throughout the entire process, while the remaining keys are ignored and never updated. To address this problem, we propose two strategies:\n\u2022 Group-based retrieval. Insipired by Vaswani et al. (2017), rather than retrieving directly from the entire keys set, we first partition the set into multiple equal groups. Simultaneously, the query vector q \u2208 Rc is also segmented into equal parts as follows:\nq = [ q\u20321, . . . , q \u2032 g ], q \u2032 i = q(i\u22121)\u00b7c/g:i\u00b7c/g, (6)\nwhere q\u2032i \u2208 Rc/g , and g represents the number of groups, which is a hyperparameter. The retrieval process is conducted independently within each qi in distinct groups, while the outcomes are subsequently aggregated across multiple groups. Group retrieval enables the model to simultaneously capture diverse patterns and relationships presented in the input data by attending to different aspects and subsets of features. Additionally, this approach enhances the robustness of the retrieval system by compensating for any potential failure of any group to capture relevant information. As a result, it facilitates a more comprehensive and expressive representation.\n\u2022 Random keys mask. To mitigate the retriever\u2019s tendency to overly prioritize specific keys, we introduce a method called random keys mask. This technique involves randomly masking certain keys during the training process, which encourages the model to allocate attention to other elements. In practice, this objective is accomplished by randomly assigning some cosine similarity results to -Inf, effectively excluding them from retrieval during training. Specially,\nSi,j = cos(q\u2032i,ki,j) \u00b7 (1\u2212 B(p))\u2212 Inf \u00b7 B(p), (7) where B(p) represents a Bernoulli random variable that takes the value 1 with probability p.\nNotably, only keys are optimized during the preparation stage as Eq. 5, and values are unchanged and still remain as the initialized learnable parameters. After the keys have been generated during the preparation stage, they are subsequently frozen and the associated values are adopted as adaptable weight increments to align the language models with the forthcoming tasks of continual learning. The overall training pipeline is illustrated in Algorithm 1."
        },
        {
            "heading": "4 EXPERIMENTS",
            "text": ""
        },
        {
            "heading": "4.1 EXPERIMENT SETUP",
            "text": "Datasets. We evaluate across various benchmarks with different backbones, demonstrating strong generalization capabilities. We first test our method on the widely adopted continual learning benchmarks for language models following de Masson D\u2019Autume et al. (2019), which use five text classification datasets (Zhang et al., 2015; Chen et al., 2020) including AG News (news classification),\nAlgorithm 1 The training pipeline of Scalable Language Model\nInput: Training sets {T 1, . . . , T M}, T t = {(xti,yti)} Nt i=1\nOutput: Grouped key-value pairs V1,...,g = {[k,\u2206\u03b8 ]} 1: for t = 1, . . . ,M do 2: Initialize the t-th task\u2019s grouped key-value pairs Vt1,...,g 3: for (xti, ) \u2208 T t do # The preparation stage for task T t 4: Feature extraction and Group partition [ q\u20321, . . . , q \u2032 g ]\u2190 q = fs(xti) via Eq. 6 5: Calculate similarities Si,j = cos(q\u2032i,ki,j) \u00b7 (1\u2212 B(p))\u2212 Inf \u00b7 B(p) via Eq. 7 6: K = K1 \u222a \u00b7 \u00b7 \u00b7 \u222a Kg , where Kj \u2190 Top-K similar keys of group j (j \u2208 {1, ..., g}) 7: Update ki,j \u2208 K by ki,j \u2190 ki,j + \u03b3\u2207ki,j cos(q\u2032i,ki,j) as Eq. 5 8: end for 9: for (xti,yti) \u2208 T t do # The fine-tune stage for task T t\n10: Retrieve most related weight increments {\u2206\u03b81 . . .\u2206\u03b8K} with similarity distances D 11: Obtain the weight increment \u2206\u03b8 = \u2211K i=1 Di\u00b7\u2206\u03b8i/ \u2211K i=1 Di used in Eq. 4 12: Calculate sample loss Li = L(f\u03b8+\u2206\u03b8(xti),yti) 13: Back-propagate the gradients \u2206\u03b8Li to update {\u2206\u03b81 . . .\u2206\u03b8K} 14: end for 15: V1,...,g \u2190 V1,...,g \u222a Vt1,...,g 16: end for\nYelp (sentiment analysis), DBPedia (Wikipedia article classification), Amazon (sentiment analysis) and Yahoo Answers (Q&A classification).\nIn our experiments with BERT-base backbone (Devlin et al., 2018), we follow the approaches of IDBR and ProgPromt (Razdaibiedina et al., 2023; Huang et al., 2021) employing four different task orders from the five tasks. We adopt the full supervised continual setting, where the training set and test set are the same as MbPA++ and LAMOL (de Masson D\u2019Autume et al., 2019; Romanov et al., 2018), consisting of 115,000 training examples and 7,600 test examples for each task. On the contrary, we conduct the few-shot continual learning setup with T5-large backbone (Raffel et al., 2020), following the approach of LFPT5 (Qin & Joty, 2021). This setup involves sampling 16 examples per class in the training and validation sets to evaluate the performance of our proposed method on limited training resources.\nWe further extend our method to large generation language models with LLaMA-2 backbone (Touvron et al., 2023) and introduce a new benchmark that spans multiple domains and task types. This benchmark includes three types of tasks: question answering (medical), multiple-choice examination (mmlu), and sentiment classification (finance) (Li et al., 2023; Hendrycks et al., 2021b;a). These tasks are drawn from domains such as medical, history, finance, and more. For each task, we randomly allocate 85% of the data to the training set and the remaining portion to the test set.\nMethods Compared. In order to compare and evaluate the performance of our method, we have selected several baselines. The selected baselines include: Fine-tune (de Masson D\u2019Autume et al., 2019; Wang et al., 2020), Replay (Razdaibiedina et al., 2023), MBPA++ (de Masson D\u2019Autume et al., 2019), IDBR (Huang et al., 2021), LFPT5 (Qin & Joty, 2021) and ProgPromt (Razdaibiedina et al., 2023). Detailed descriptions of these methods can be found in A.12 in the Appendix."
        },
        {
            "heading": "4.2 IMPLEMENTATION DETAILS",
            "text": "Backbones. Our proposed method, Scalable Language Model (SLM), is a model-agnostic approach to continual learning that can be applied to various backbones. In our study, we specifically selected three different models: encoder-only BERT-base model (Devlin et al., 2018), encoderdecoder T5-large model (Qin & Joty, 2021), and decoder-only LLaMA2-7B model Touvron et al. (2023), covering various scales and architectures. To ensure consistency, we replicate all models from HuggingFace Transformers (Wolf et al., 2020) with corresponding pretrained weights.\nConfiguration. We conducted trials using the BERT and T5 backbones with 4 NVIDIA GeForce RTX 3090 GPUs. We set the batch size to 8 and the maximum sequence length to 512 for these experiments. Additionally, for experiments involving the LLaMA2-7B backbone, we utilized 4 NVIDIA A100 GPUs with a batch size of 2. To enhance training efficiency, we employed\nDeepSpeed (Rasley et al., 2020) as a training optimization. AdamW is employed as the optimizer (Loshchilov & Hutter, 2017) for our experiments. For the preparation stage, we set the learning rate lr = 1e\u22123 and the random mask rate p = 20% for all scenarios. Specifically, we set the learning rate to 2e\u22124 for fully continual learning using the BERT and LLaMA2 backbones. For the few-shot continual learning scenario with the T5 model, we set the learning rate to 2e\u22122. The weight decay is set to 0.01. More configuration details can be found in Appendix A.4."
        },
        {
            "heading": "4.3 RESULTS ON CONTINUAL LEARNING BENCHMARKS",
            "text": "In our evaluation, we initially fine-tune the pretrained models to adapt them to sequential tasks during the training stage. Then, we assess the performance of these models on the test sets associated with each task and report the averaged scores. Experiments without the inclusion of specific notation don\u2019t provide task-ID during inference. Further, Appendix A.1 shows detailed task orders, A.3 presents the dataset details, and A.9 investigates the number of learnable parameters.\nBERT benchmark. Tab. 1 showcases the performance of our proposed method on the BERT continual learning benchmark. Our method achieves a new state-of-the-art (SOTA) result, surpassing the alternatives, even without relying on experience replay or task-ID. Task-ID utilization simplifies the problem, particularly for methods that introduce new parameters (Razdaibiedina et al., 2023; Qin & Joty, 2021). It resembles fine-tuning on multiple tasks with distinct parameters. However, the practical determination of the input source remains challenging, such as in applications like online chatbot services where advanced knowledge of upcoming tasks may not be accessible. While our method does not depend on the task-ID, incorporating it yields a slight improvement, resulting in a remarkable performance of 80% as a first achievement.\nT5 benchmark. We conducted experiments on the few-shot continual learning benchmark for the T5 model, following Qin & Joty (2021). The results of our experiments are presented in Tab. 2, where we compare the performance of SLM with other methods. All selected methods do not require the task-ID, and only LFPT5 necessitates slight experience replay. In accordance with Qin et al. (2021) Qin & Joty (2021), we employ the text-to-text formulation for all T5 experiments, where classification labels are mapped into words. We employ accuracy as the comparative metric, considering only the first word selected as the answer from the generated output.\nLLaMA benchmark. We extend our method to the large language model, utilizing the decoderonly LLaMA2-7B (Touvron et al., 2023) as the backbone. In our study, we incorporate three types of\ntasks: question answering (medical), multiple-choice examination (mmlu), and sentiment classification (finance) across various domains. For the multiple-choice and classification tasks, we evaluate performance using accuracy. And we utilize BERTScore, following Zhang et al. (2019), to assess the medical answers generation quantity. Specially, we assign a score of 0 to the answers that do not align with the given tasks. The performance comparison with the baseline is presented in Tab. 3 and Fig. 3 provides more intuitive sampled examples. We conduct the replay methods following previous related work (He et al., 2021; Huang et al., 2021) with 1% sampled instances. It is evident that after fine-tuning sequential tasks, the baseline model has almost completely forgotten the first-learned knowledge and skills, suffering from catastrophic forgetting. And as the interval between tasks increases, the severity of forgetting tends to worsen. Indeed, our method demonstrates outstanding performance without significant forgetting. More examples can be found in Fig. 5 and Fig. 6 in the Appendix."
        },
        {
            "heading": "4.4 ANALYSIS",
            "text": "Table 4: The comparison of forgetting which is calculated each time after completing the training on a new task of the BERT benchmark.\nMethod SLM IDBR Order 4 5 6 Avg Avg After 2 tasks 0.0 0.0 0.0 0.0 0.8 After 3 tasks 0.0 0.6 0.4 0.3 2.4 After 4 tasks 0.2 0.4 0.8 0.5 2.7 After 5 tasks 0.5 0.5 0.5 0.5 2.9\nFigure 4: t-SNE visualization of keys distribution. Different spans indicate distinct groups, and the same tasks are linked by lines.\nInfluence of task sequence length on forgetting. In addition to accuracy, forgetting is another important indicator for assessing continual learning. Following the approach of Huang et al. (2021) and Chaudhry et al. (2018), we conduct experiments on the BERT benchmark and measure forgetting Fk after training on task t using the following formula:\nFk = Ej=1...t\u22121fkj , fkj = max l\u2208{1...,t\u22121} al,j \u2212 at,j , (8)\nwhere al,j is the accuracy on task j after trained on task l. We report the forgetting evaluated on each new task and report the results compared with IDBR in Tab. 4. Our method demonstrates a remarkable improvement of up to 82.8% compared to the previous state-of-the-art (SOTA) approaches and all indicators are less than 0.5%. It effectively minimizes the forgetting of previously learned knowledge while acquiring new knowledge. Additional discussions are in Appendix A.7.\nVisualization of the keys\u2019 distribution. To investigate the partitioning of distinct knowledge domains and assess the impact of the grouping strategy, we adopt t-SNE (Van der Maaten & Hinton, 2008) to visualize the distributions of the keys, as demonstrated in Fig. 4. In this figure, different cluster spans indicate different groups, and the keys belonging to the same task are connected by lines within each group. We can observe that different groups correspond to varied distributions, demonstrating the effectiveness of the grouping strategy in capturing diverse patterns and improving robustness. This is crucial because a single group may fail to retrieve the related information, and the presence of multiple groups helps mitigate this limitation.\nEffects of JARe. Multiple ablation experiments were conducted to examine the impact of our proposed Joint Adaptive Re-Parameterization (JARe), and the results are presented in Tab. 5. Specifically, we replaced the weight increments in our DTKR with prompts and adapters (Li & Liang, 2021; Zhang et al., 2023). The \u201cSeparate Fine-tune\u201d approach involves individually fine-tuning on different tasks instead of continual learning among multiple tasks. By demonstrating a marginal deviation of only 0.8%, the proposed JARe manifests its superiority over the competitors.\nTable 5: Results of the ablation studies on various storage values on BERT benchmark.\nOrder Method 4 5 6 Avg DTKR + Prompt 54.7 55.8 49.4 53.3 DTKR + Adapter 71.2 71.2 70.2 70.9 DTKR + JARe 79.2 78.8 79.0 79.0 Separate Fine-tune - - - 79.8\nTable 6: Zero-shot evaluation on open benchmarks to assess the phenomena of forgetting and knowledge transfer.\nTask Method Arc-c Arc-e Piqa Wino Finetune 31.8 42.6 67.9 64.3 SLM 44.7 76.0 76.3 67.7 LLaMA2 43.9 74.4 76.7 66.4\nZero-shot evaluation. We further evaluate our method in a zero-shot setting on four open benchmarks (Arc-c, Arc-e, Piqa, Wino) (Clark et al., 2018; Sakaguchi et al., 2021; Bisk et al., 2020) following Gao et al. (2021). We first fine-tune the LLaMA-2 backbone following the order: Medical \u2192 MMLU \u2192 Finance, and then evaluate the models on the above four benchmarks. Ther results are shown in Tab. 6 and more detailed comparison can be found in A.10. It can be seen that directly utilizing fully fine-tune will result in a deterioration of the overall performance because of catastrophic forgetting. In constract to deterioriting the performance, our method even slightly improves the baseline on several tasks. It demonstrates the dual capability of our method to alleviate forgetting and effectively transfer knowledge."
        },
        {
            "heading": "5 RELATED WORK",
            "text": "Continual Learning, also known as lifelong learning or incremental learning, aims to improve a learning system to progressively acquire and preserve knowledge from various tasks. Existing methods for continual learning can be broadly classified into three primary categories: (1) Replay-based methods: periodically replay past experiences and knowledge from the observed tasks and data (Rebuffi et al., 2017; Romanov et al., 2018). The experiential data can be sampled from the previous tasks (de Masson D\u2019Autume et al., 2019; Rebuffi et al., 2017) or synthesized using generative models (Romanov et al., 2018; Shin et al., 2017). (2) Regularization-based methods: impose constraints on the parameter changes of the model to prevent forgetting of previously learned tasks (Aljundi et al., 2018; Huang et al., 2021). (3) Architecture-based methods: employ distinct components and separate sets of parameters within the model for different tasks (Rusu et al., 2016; Mallya & Lazebnik, 2018; Razdaibiedina et al., 2023).\nVector space model. Compared to traditional retrieval methods, such as the keyword-based or the rule-based, the Vector Space Model (VSM) has emerged as a prominent paradigm in information retrieval (Berry et al., 1999; Wong et al., 1987; Singhal et al., 2001). The VSM represents queries as vectors in a high-dimensional space. This representation enables the application of various similarity measures, such as cosine similarity, to determine the relevance between documents and queries (Zhang & Lu, 2003). Previous methods have endeavored to incorporate vector space retrieval into diverse endeavors (Peng et al., 2023; Danisman & Alpkocak, 2008; Wang et al., 2022), and Wang et al. (2022) adopts VSM for in-context learining. In contrast, our work introduces the use of VSM to enable dynamic transfering and adaptation of models for downstream tasks, incorporating meta-learning techniques similar to the \u201cmodel soup\u201d (Wortsman et al., 2022)."
        },
        {
            "heading": "6 CONCLUSION",
            "text": "This paper presents Scalable Language Model (SLM), which enables incremental learning of sequential tasks while effectively mitigating catastrophic forgetting in a generalized setting. Notably, our approach eliminates the requirement for experience replay, optimization constraints and inference task-ID, enhancing its applicability to practical scenarios. We propose the integration of Joint Adaptive Re-Parameterization (JARe) with Dynamic Task-related Knowledge Retrieval (DTKR) to adaptively re-parameterize pretrained models based on the distance between task distributions. Our approach demonstrates remarkable stability and effectiveness across diverse model scales, leading to state-of-the-art performance on multiple benchmarks encompassing different tasks types.\nThe weakness of our method lies in the introduction of an additional retrieval framework, which may lead to increased computational and memory storage costs. However, when compared to the resource requirements of large models used for inference generation, this additional consumption is relatively small. Further quantitative analysis regarding this weakness can be found in Section A.11."
        },
        {
            "heading": "A APPENDIX",
            "text": ""
        },
        {
            "heading": "A.1 TASK SEQUENCE ORDERS",
            "text": "In standard continual learning benchmarks, the BERT and T5 models (Devlin et al., 2018; Raffel et al., 2020) utilize a total of 7 orders, as described by Huang et al. (2021); Qin & Joty (2021). The specific orders are presented in Tab. 7 as follows:\nIn all benchmark experiments, we initially train the pretrained model on the specific dataset, following the predefined orders mentioned above. Subsequently, we evaluate the fine-tuned model on all test sets simultaneously to test the model\u2019s performance and alleviating forgetting ability.\nIn the LLaMA benchmark, we use two orders due to resource constraints. The specific orders are listed as follows:\n\u2022 Order 8: Medical\u2192MMLU\u2192 Finance \u2022 Order 9: Finance\u2192MMLU\u2192Medical"
        },
        {
            "heading": "A.2 EXAMPLES DEMO",
            "text": "Large Language Model (LLM) has achieved a significant success in recent years, demonstrating their distinguished ability to excel in various tasks. Furthermore, numerous applications are have been proposed that leverage fine-tuning on the pretrained large language models to adapt them to specific domains (Taori et al., 2023; Li et al., 2023). However, such operation only let the LLM grasp single domain-specific skills while potentially causing catastrophic forgetting of its general abilities.\nThe objective of this study is to enable the large language model (LLM) to acquire diverse skills and knowledge across multiple domains, while also possessing the potential for lifelong learning capability. More examples about the comparison of our method and the baseline, which involves direct fine-tuning of the pretrained LLM on sequence tasks, are presented in Fig. 5 and Fig. 6.\n\u2022 Fig. 5: Medical\u2192MMLU\u2192 Finance. \u2022 Fig. 6: Finance\u2192MMLU\u2192Medical.\nThe results clearly demonstrate that while fine-tuning enables the model to acquire specific knowledge, it suffers from catastrophic forgetting, which can only answer following the formats of the last task. This is even detrimental to LLM\u2019s general abilities, which is supported by the zero-shot evaluation on the open benchmarks in Sec. 4.4. In contrast, our method significantly alleviates these issues, allowing the pretrained LLM to acquire a wide range of skills across multiple domains without experiencing catastrophic forgetting.\nDisclaimer of liability. The examples provided is for demonstration purposes only and should not be relied upon as professional advice."
        },
        {
            "heading": "A.3 DATASETS",
            "text": "BERT and T5 benchmarks. More details about the five datasets used for the BERT and T5 benchmarks are listed in Tab. 8. For the BERT benchmarks, we adopt a fully supervised training approach as described in the works by Huang et al. (2021); de Masson D\u2019Autume et al. (2019). As for the experiments conducted with T5 backbones, we use the few-shot setting where 16 examples are sampled for each class, following the methodology outlined in (Qin & Joty, 2021).\nLLaMA benchmarks. In this study, we utilize three distinct datasets(Li et al., 2023; Hendrycks et al., 2021b;a) for conducting experiments on the LLaMA benchmark. We adopt instruction tuning similar to Taori et al. (2023), while replacing the training datasets with our selected datasets. We present the sampled examples in Tab. 9 to show more details, including the instructions used in the experiments. It can be seen that in the LLaMA benchmark, the models should learn to adapt to distinct tasks across various domains with different generation formats.\nA.4 IMPLEMENTATION DETAILS\nTask-ID. In this work, we mainly focus on the scenarios where inference is conducted without the task ID. In such cases, we don\u2019t know that which task or dataset is the input come from for each input instance. In particular, for architecture-based methods, having knowledge of the task ID significantly simplifies the problem by enabling direct determination of the target parameters, which\nis similar to fine-tune on separate tasks independently. However, in the practical scenarios, it is always unable to determine the input task-ID directly. Such as a customer service chatbot, it doesn\u2019t have the feasibility to provide the model with the task source from the user.\nLabels. For the T5 models, we employ a mapping technique to convert the classification labels into words, following the methodology outlined in Raffel et al. (2020). The same operation is also applied to the MMLU and Finance tasks in the LLaMA benchmark. During the evaluation phase, we select only the first word and compare it with the labels to measure accuracy, following Raffel et al. (2020). The excess part of the generation results will be ignored. Regarding the Medical task, we utilize the entire generated outputs with a maximum length of 512 and compare them with the labels using the BERTScore metric introduced by Zhang et al. (2019) following Li et al. (2023).\nOptimization hyperparameter. AdamW (Loshchilov & Hutter, 2017) is adopted as the optimizer in all experiments. The details of the optimization hyperparameter are listed in the Tab. 10."
        },
        {
            "heading": "A.5 DISCUSSION OF VARIOUS PEFT METHODS",
            "text": "In this section, we delve into further details and compare different parameter efficient fine-tuning (PEFT) methods as the retrieved targets using the vector space retrieval framework. We replace our Joint Adaptive Re-Parameterization (JARe) with alternative components and perform ablation experiments on various individual tasks.\nPrior continual learning methods have made attempts to introduce PEFT techniques like prompt tuning, which involves tuning prompts for better adaptation to new tasks. (Razdaibiedina et al., 2023; Qin & Joty, 2021; Wang et al., 2022). Specially, for a novel incremental task Tk, the learining objective is to minimize the log probability of training examples:\nLlm(\u03b8Pk) = \u2212 \u2211\n(x,y)\u2208Tk\nlog p(y | [Pk,x], \u03b8, \u03b8Pk), (9)\nwhere Pk is a learnable prompt with its corresponding parameters \u03b8k. Similar to prompt tuning, another alternative is to replace prompts with adapters, such as prefix-tuning (Li & Liang, 2021), which also provide a flexible and modular approach to incorporate task-specific information without modifying its base parameters. We conduct the ablation experiments on the different single tasks, and the results are shown in Fig. 7.\nAdaptability. In contrast to JARe, replacing it with prompts and adapters only allows them to be retrieved without the ability to dynamically adjust the importance and significance of each element based on the distribution distance in the vector space. As a result, all the responsibility is placed on the pretrained model itself to determine the importance of attention without the additional task distribution information, which, although lost, can be valuable for effective adaptation.\nLimited trainable parameters. Directly introducing more learnable parameters through prompts and adapters did not lead to significant improvements and fitting abilities. As more prompts and adapters are added, the input length increases significantly. However, the rate of improvement gradually slows down (Hu et al., 2021).To solve this problem, Razdaibiedina et al. (2023) proposes to introduce a res-mlp layer, specifically,\nP \u2032k = MLPk(Pk) + Pk, (10)\nwhere MLPk(\u00b7) is a learnable MLP layer for the task Tk. However, the inclusion of task-ID information is inevitable when determining which MLP layer to use. But in the practical scenarios, such as a customer service chatbot, it is impossible to provide the task-ID from the users.\nLarge language model. The direct incorporation of prompt-tuning or adapters into large language models can lead to convergence difficulties and training instability. This issue primarily arises from the fact that all newly introduced parameters are randomly initialized without pretraining, which can make the model fragile when dealing with a large number of parameters. To alleviate this problem, Zhang et al. (2023) proposes to introduce a gate variable, specifically,\nP \u2032i = gate \u00b7 Pi, (11)\nwhere gate \u2208 R is a learnable parameter that is initialized as zero. This initialization ensures that the introduced parameters have no influence on the original model at first and provides a slow warm-up process. But the gate variable also limits the influences of the prompts and determining its optimal value can be challenging.\nIn our practical experiments, we discovered an alternative approach where the introduced prompts can be initialized with tokens from the pretrained embedding layers. This initialization strategy can be effective in improving the performance and stability of the model during training. Specifically,\nPi \u2190 \u03b3(E), (12)\nwhere E \u2208 Rn\u00d7c represents the pretrained embedding tokens, and \u03b3 denotes the random selection function that returns a token randomly.\nHowever, while these strategies may improve stability, they often do not fully overcome the upper limit bottleneck. Additionally, they can make models and inputs redundant and increase the time cost of the inference with more and more incremental tasks added."
        },
        {
            "heading": "A.6 MODEL RE-PARAMETERIZATION",
            "text": "In the Sec. 3.1, we have introduce that we utilize a single group of weight increments to reparameterize the pretrained models to adapt to a specific downstream task following Hu et al. (2021). Specifically, we freeze all the pretrained parameters without further optimization and introduce a limited number of learnable parameters to store the weight increments during training. We empoly the low-rank adaptation techniques to reduce more costs, as more details are shown in Fig. 8. Recent research further shows that optimizing all pretrained parameters for fine-tuning is unnecessary. Instead, selectively optimizing a limited set of parameters can achieve comparable performance to fully fine-tuning (Hu et al., 2021; Li & Liang, 2021; Zhang et al., 2023). Another question arises regarding which part of the pretrained models should be selected for optimization. In this work, we\nfocus on optimizing the weight matrix within the out linear layer in the attention module as shown in Fig. 8. For saving more memories, we only select a single part from the attention module, and additional ablation experiment results, showcasing the impact of different parts, are presented in Tab. 11."
        },
        {
            "heading": "A.7 FORGETTING EVALUATION",
            "text": "Apart from the performance, the ability to mitigate forgetting is another crucial indicator for assessing a continual learning method. To evaluate this ability, we conduct separate tests to assess our model\u2019s performance on all previously learned tasks after training of each single incremental task. This evaluation reflects the extent to which the model retains past knowledge. The results for four different task orders on BERT benchmark are shown in Fig. 9. It is worthy to notice that as the sequence of learned tasks grows, our proposed method exhibits no significant degradation, demonstrating its remarkable ability to mitigate forgetting."
        },
        {
            "heading": "A.8 KEYS GENERATION",
            "text": "Local optimization. In this section, we will delve into further details about the key generation process, focusing on strategies to address the issue of local optimization. When selecting and updating keys using gradient descent, it is possible that only certain keys are optimized while others are left untouched, leading to a situation of being stuck in local optimization. To tackle this issue, we propose two easy yet effective strategies: Group-based retrieval and Random keys mask. These strategies aim to capture diverse patterns and relationships within the input data by attending to different aspects and subsets of features. To evaluate the impact of these two strategies, we conducted ablation experiments, and the results are presented in Tab. 12. Specifically, with JARe, the retrieved keys are not constrained to belonging to the same task as the query, and more details we have discussed abovee. So we calculate the accuracy as follows:\nAcc = \u2211 q\u2208T \u03b4(|{k \u2208 Kq : k \u2208 p(T }| > |Kq| 2 ) / |T |, (13)\nwhere \u03b4(\u00b7) is a condition function that returns 1 if the condition is satisfied. In other words, We calculate the percentage of inputs for which the retrieved keys from the same task distribution con-\nstitute more than half of the total retrieved keys. It can be seen that our proposed strategies have significantly improved the performance, particularly in the case of the group partition operation.\nTime consumption. For each incremental task, we split the process into two stages: (1) Preparation stage: generating keys for each stored value [k,\u2206\u03b8]. In this stage, we generate keys that correspond to the stored key-value pairs. These keys play a critical role in retrieving the correct information during the subsequent fine-tuning process. (2)Finetune stage: fine-tune the models and preserve corresponding values. In this stage, we fine-tune the models to adapt them to the specific requirements of the downstream task. So another important consideration is the computational time required for key generation. We display the training time in Tab. 13. All experiments are conducted on 4 NVIDIA GTX 3090 GPUs, batch size per device is set to 4 and epoch is 3. The results show that the training time for key generation is approximately 11 minutes, which is minimal and has negligible impact on the overall process.\nSimilarity matrix. To provide a visual representation of the relationships and similarities among all the generated key vectors, we present the visualization of the similarity matrix in Fig. 10. We randomly sampled some groups, where each group consists of 5 tasks and each task is associated with four keys. The visualization reveals that the keys belonging to the same task generally exhibit similar distributions, resulting in higher similarities among them. This characteristic ensures that the keys from a particular task can be easily distinguished from those of other tasks."
        },
        {
            "heading": "A.9 THE NUMBER OF LEARNABLE PARAMETERS",
            "text": "The size of the introduced learnable parameters does not always follow a \u201cless is better\u201d principle. Insufficient learnable parameters for certain tasks may result in underfitting, leading to unsatisfactory performance. Compared to the prompt tuning and adapters discussed in the previous sections, another advantage is its ability to dynamically adjust the size of learnable parameters within the range of 0 as the lower bound and the size of the entire model as the upper bound. This adaptability ensures its ability to dynamically adjust to diverse tasks with varying requirements.\nIt is important to note that while the size of the learnable parameters is a critical factor in evaluating a method, it does not have any impact on the inference process in terms of delays or computational burdens. This advantage is derived from the complete decoupling of the continual learned knowledge from the pretrained model. The cost of the retrieval process remains constant, and the retrieved values are solely utilized for model re-parameterization, without affecting the input or model scales.\nTo assess the impact of learnable parameter size on performance across different tasks, we conducted experiments with various hyperparameter settings, specifically modifying the size of the learnable parameters. These experiments were conducted individually for each task to evaluate the influence on performance with the BERT as the backbone.\nAll the experimental results are presented in Tab. 14, revealing several interesting findings and conclusions. Different tasks necessitate varying sizes of learnable parameters, and increasing the parameter size yields distinct improvements depending on the task at hand. In the case of the \u201cyahoo\u201d task, increasing the parameter size beyond a certain point does not provide notable benefits same as \u201cag\u201d task. Our method allows us a probability to assign different sizes to the respective tasks based on their specific requirements.\nRegarding the memory usage for storing these additional parameters, we provide a statistical analysis in Tab. 15. The introduced parameters in our approach are considered acceptable and relatively small compared to the size of the original pretrained large models."
        },
        {
            "heading": "A.10 ZERO-SHOT EVALUATION ON VARIOUS TASKS",
            "text": "Table 16 presents a more detailed zero-shot evaluation of our method using the LLaMA2 backbone finetuned on various downstream tasks. It has been observed that fine-tuning on small-scale datasets that differ significantly from the training data can have a negative impact on the LLM\u2019s generality and adaptability. Our aim is to address this issue and mitigate the catastrophic forgetting."
        },
        {
            "heading": "A.11 WEAKNESS DISCUSSION",
            "text": "We humbly acknowledge that the proposed method indeed introduces a cost associated with the retrieval process. However, we find the additional cost to be acceptable because:\n1. Compared to the subsequent inference models, the retrieval stage model used is notably smaller, lighter, and operates at a faster speed. This distinction is particularly significant for the T5 and Llama models.\n2. In the case of generation models with the decoder architecture, each inference only produces a single token, necessitating multiple inferences to generate a complete sentence. However, the retrieval process is executed only once. Therefor, given tr as the retrivak time, ti as the inference time, n as the tokens number, the proportion of time consumed is:\ntr tr + n \u2217 ti \u2217 100%\nWe conducted an experimental comparison to measure the time consumption of different parts of various tasks using Llama on a single A100 GPU. And the results are shown in Tab. 17.\nIn terms of storage, we show the memories used for the additional parameters in Tab. 15. Moreover, it is worth noting that while our method requires additional parameters, these parameters are only used to store the weight increments. They do not incur any computational cost or increase the complexity of the original models."
        },
        {
            "heading": "A.12 COMPARED METHODS",
            "text": "Below are the detailed descriptions of the methods we have chosen to compare:\n\u2022 Fine-tune (de Masson D\u2019Autume et al., 2019; Wang et al., 2020): Fully fine-tune all model parameters to adapt to sequential downstream tasks without additional episodic or modular components.\n\u2022 Replay (Razdaibiedina et al., 2023): incorporates a mechanism to replay samples from previous tasks stored in the memory buffer during whole model fine-tuning, ensuring that the model retains knowledge from old tasks.\n\u2022 MBPA++ (de Masson D\u2019Autume et al., 2019): augments the BERT model with an episodic memory module, storing all seen examples. It performs experience replay during training and uses K-nearest neighbors for local adaptation at test time.\n\u2022 IDBR (Huang et al., 2021): divides the representation learning process into task-specific and taskgeneric spaces to attain effective representation for BERT model. This method involves continual training of the model while incorporating data replay and a regularization loss.\n\u2022 LFPT5 (Qin & Joty, 2021): leverages prompt tuning (PT) from T5 to simultaneously train the model as a task solver and a data generator. It leverages experience replaying during the learning process, requiring only a limited amount of resources.\n\u2022 ProgPromt (Razdaibiedina et al., 2023): utilizes prompt tuning to adapt models for individual downstream tasks by employing a distinct set of prompts for each task and sequentially concatenating them with previously learned prompts. During inference, Progressive Prompts assumes that the task identifier is known, enabling the model to appropriately select the corresponding prompts."
        }
    ],
    "year": 2024
}